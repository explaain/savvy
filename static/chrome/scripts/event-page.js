/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5);


/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*
	* loglevel - https://github.com/pimterry/loglevel
	*
	* Copyright (c) 2013 Tim Perry
	* Licensed under the MIT license.
	*/
	(function (root, definition) {
	    "use strict";
	
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
	        module.exports = definition();
	    } else {
	        root.log = definition();
	    }
	})(undefined, function () {
	    "use strict";
	
	    // Slightly dubious tricks to cut down minimized file size
	
	    var noop = function noop() {};
	    var undefinedType = "undefined";
	
	    var logMethods = ["trace", "debug", "info", "warn", "error"];
	
	    // Cross-browser bind equivalent that works at least back to IE6
	    function bindMethod(obj, methodName) {
	        var method = obj[methodName];
	        if (typeof method.bind === 'function') {
	            return method.bind(obj);
	        } else {
	            try {
	                return Function.prototype.bind.call(method, obj);
	            } catch (e) {
	                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
	                return function () {
	                    return Function.prototype.apply.apply(method, [obj, arguments]);
	                };
	            }
	        }
	    }
	
	    // Build the best logging method possible for this env
	    // Wherever possible we want to bind, not wrap, to preserve stack traces
	    function realMethod(methodName) {
	        if (methodName === 'debug') {
	            methodName = 'log';
	        }
	
	        if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType) {
	            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
	        } else if (console[methodName] !== undefined) {
	            return bindMethod(console, methodName);
	        } else if (console.log !== undefined) {
	            return bindMethod(console, 'log');
	        } else {
	            return noop;
	        }
	    }
	
	    // These private functions always need `this` to be set properly
	
	    function replaceLoggingMethods(level, loggerName) {
	        /*jshint validthis:true */
	        for (var i = 0; i < logMethods.length; i++) {
	            var methodName = logMethods[i];
	            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
	        }
	
	        // Define log.log as an alias for log.debug
	        this.log = this.debug;
	    }
	
	    // In old IE versions, the console isn't present until you first open it.
	    // We build realMethod() replacements here that regenerate logging methods
	    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
	        return function () {
	            if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== undefinedType) {
	                replaceLoggingMethods.call(this, level, loggerName);
	                this[methodName].apply(this, arguments);
	            }
	        };
	    }
	
	    // By default, we use closely bound real methods wherever possible, and
	    // otherwise we wait for a console to appear, and then try again.
	    function defaultMethodFactory(methodName, level, loggerName) {
	        /*jshint validthis:true */
	        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
	    }
	
	    function Logger(name, defaultLevel, factory) {
	        var self = this;
	        var currentLevel;
	        var storageKey = "loglevel";
	        if (name) {
	            storageKey += ":" + name;
	        }
	
	        function persistLevelIfPossible(levelNum) {
	            var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            // Use localStorage if available
	            try {
	                window.localStorage[storageKey] = levelName;
	                return;
	            } catch (ignore) {}
	
	            // Use session cookie as fallback
	            try {
	                window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
	            } catch (ignore) {}
	        }
	
	        function getPersistedLevel() {
	            var storedLevel;
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            try {
	                storedLevel = window.localStorage[storageKey];
	            } catch (ignore) {}
	
	            // Fallback to cookies if local storage gives us nothing
	            if ((typeof storedLevel === 'undefined' ? 'undefined' : _typeof(storedLevel)) === undefinedType) {
	                try {
	                    var cookie = window.document.cookie;
	                    var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
	                    if (location) {
	                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
	                    }
	                } catch (ignore) {}
	            }
	
	            // If the stored level is not valid, treat it as if nothing was stored.
	            if (self.levels[storedLevel] === undefined) {
	                storedLevel = undefined;
	            }
	
	            return storedLevel;
	        }
	
	        /*
	         *
	         * Public logger API - see https://github.com/pimterry/loglevel for details
	         *
	         */
	
	        self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
	            "ERROR": 4, "SILENT": 5 };
	
	        self.methodFactory = factory || defaultMethodFactory;
	
	        self.getLevel = function () {
	            return currentLevel;
	        };
	
	        self.setLevel = function (level, persist) {
	            if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
	                level = self.levels[level.toUpperCase()];
	            }
	            if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
	                currentLevel = level;
	                if (persist !== false) {
	                    // defaults to true
	                    persistLevelIfPossible(level);
	                }
	                replaceLoggingMethods.call(self, level, name);
	                if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType && level < self.levels.SILENT) {
	                    return "No console available for logging";
	                }
	            } else {
	                throw "log.setLevel() called with invalid level: " + level;
	            }
	        };
	
	        self.setDefaultLevel = function (level) {
	            if (!getPersistedLevel()) {
	                self.setLevel(level, false);
	            }
	        };
	
	        self.enableAll = function (persist) {
	            self.setLevel(self.levels.TRACE, persist);
	        };
	
	        self.disableAll = function (persist) {
	            self.setLevel(self.levels.SILENT, persist);
	        };
	
	        // Initialize with the right level
	        var initialLevel = getPersistedLevel();
	        if (initialLevel == null) {
	            initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
	        }
	        self.setLevel(initialLevel, false);
	    }
	
	    /*
	     *
	     * Top-level API
	     *
	     */
	
	    var defaultLogger = new Logger();
	
	    var _loggersByName = {};
	    defaultLogger.getLogger = function getLogger(name) {
	        if (typeof name !== "string" || name === "") {
	            throw new TypeError("You must supply a name when creating a logger.");
	        }
	
	        var logger = _loggersByName[name];
	        if (!logger) {
	            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
	        }
	        return logger;
	    };
	
	    // Grab the current global log variable in case of overwrite
	    var _log = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType ? window.log : undefined;
	    defaultLogger.noConflict = function () {
	        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType && window.log === defaultLogger) {
	            window.log = _log;
	        }
	
	        return defaultLogger;
	    };
	
	    return defaultLogger;
	});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(6);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _explaainSearch = __webpack_require__(12);
	
	var _explaainSearch2 = _interopRequireDefault(_explaainSearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var UserIDs = {
	  live: {
	    Jeremy: '1627888800569309',
	    Matt: '1455707247850069',
	    Carol: '1459068990878077',
	    Harriet: '1478776232161468',
	    Jonny: '1513554438729753'
	  },
	  staging: {
	    Jeremy: '1366746370089527',
	    Matt: '1528134990563202'
	  },
	  local: {
	    Jeremy: '1300120880110773',
	    Matt: '1428419100528438'
	  },
	  drive: {
	    Jeremy: '104380110279658920175',
	    ACME: '101118387301286232222'
	  }
	};
	
	var UserID = UserIDs.live.ACME;
	var PageResults = {};
	var UserCards = [];
	var LastRefresh = 0;
	
	var algoliaParams = { // Need to send these to app.vue to avoid duplication!
	  appID: 'I2VKMNNAXI',
	  apiKey: '2b8406f84cd4cc507da173032c46ee7b',
	  index: 'ForgetMeNot_Context_Test_Local'
	};
	_vue2.default.use(_explaainSearch2.default, algoliaParams);
	
	chrome.browserAction.onClicked.addListener(function (tab) {
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    chrome.tabs.sendMessage(tabs[0].id, { action: 'toggleDrawer' }, function (res) {
	      _loglevel2.default.info(res);
	    });
	  });
	});
	
	chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
	  try {
	    _loglevel2.default.debug(sender.tab ? "From a content script: " + sender.tab.url : "From the extension", request);
	
	    if (request.action == "getPageResults") {
	      getCurrentPageResults(request.data).then(function (res) {
	        _loglevel2.default.debug(res);
	        sendResponse(res);
	      });
	      return true;
	    }
	    if (request.action == "checkPage") {
	      _loglevel2.default.trace(request.data);
	      checkRefresh().then(function () {
	        return _explaainSearch2.default.getPageResults(UserID, request.data, UserCards);
	      }).then(function (res) {
	        addToPageResults(sender.tab.id, res);
	        PageResults = res;
	        sendResponse(res);
	      }).catch(function (e) {
	        _loglevel2.default.error(e);
	      });
	      return true;
	    }
	    if (request.action == "getUser") {
	      sendResponse(UserID);
	      return true;
	    }
	    if (request.action == "refreshCards") {
	      getAllUserCards();
	      return true;
	    }
	    if (request.event == "popupOpened") {
	      chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	        chrome.tabs.sendMessage(tabs[0].id, { event: 'popupOpened' }, function (response) {});
	      });
	      return true;
	    }
	  } catch (e) {
	    _loglevel2.default.error(e);
	  }
	});
	
	var getCurrentPageResults = function getCurrentPageResults(data) {
	  var d = _q2.default.defer();
	  var tabID;
	  _loglevel2.default.debug(1);
	  checkRefresh().then(getCurrentTab).then(function (tab) {
	    _loglevel2.default.debug(tab.id);
	    tabID = tab.id;
	    _loglevel2.default.debug(PageResults);
	    if (PageResults[tabID]) {
	      d.resolve(PageResults[tabID]);
	    } else {
	      if (!data) data = { tabID: tabID };
	      _loglevel2.default.debug(data);
	      getPageData(data).then(function (res) {
	        _loglevel2.default.debug(res);
	        return _explaainSearch2.default.getPageResults(UserID, res, UserCards);
	      }).then(function (res) {
	        _loglevel2.default.debug(res);
	        addToPageResults(tabID, res);
	        d.resolve(res);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	    }
	  }).catch(function (e) {
	    d.reject(e);
	  });
	  return d.promise;
	};
	
	var getCurrentTab = function getCurrentTab() {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    d.resolve(tabs[0]);
	  });
	  return d.promise;
	};
	
	var getPageData = function getPageData(data) {
	  var d = _q2.default.defer();
	  if (data.pageData) {
	    d.resolve(data.pageData);
	  } else if (data.tabID) {
	    sendMessageToTab(tabID, { action: 'getPageData' }).then(function (res) {
	      d.resolve(res);
	    });
	  } else {
	    d.reject();
	  }
	  return d.promise;
	};
	
	var sendMessageToTab = function sendMessageToTab(tabID, data) {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.sendMessage(tabID, data, function (res) {
	    _loglevel2.default.debug(res);
	    d.resolve(res);
	  });
	  return d.promise;
	};
	
	var addToPageResults = function addToPageResults(tabID, data) {
	  PageResults[tabID] = data;
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    Object.keys(PageResults).forEach(function (pageTabID) {
	      if (tabs.filter(function (tab) {
	        return tab.id == pageTabID;
	      }).length == 0) delete PageResults[pageTabID];
	    });
	    _loglevel2.default.debug(PageResults);
	  });
	};
	
	var checkRefresh = function checkRefresh() {
	  var d = _q2.default.defer();
	  var now = new Date();
	  if (now - LastRefresh > 300000) {
	    getAllUserCards().then(function () {
	      d.resolve();
	    }).catch(function (e) {
	      _loglevel2.default.error(e);
	      d.reject(e);
	    });
	  } else {
	    d.resolve();
	  }
	  return d.promise;
	};
	
	var getAllUserCards = function getAllUserCards() {
	  var d = _q2.default.defer();
	  LastRefresh = new Date();
	  _explaainSearch2.default.searchCards(UserID, '', 1000).then(function (results) {
	    UserCards = results;
	    _loglevel2.default.debug(UserCards);
	    d.resolve();
	  }).catch(function (e) {
	    _loglevel2.default.error(e);
	    d.reject(e);
	  });
	  return d.promise;
	};
	getAllUserCards();

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * Vue.js v2.4.2
	 * (c) 2014-2017 Evan You
	 * Released under the MIT License.
	 */
	/*  */
	
	// these helpers produces better vm code in JS engines due to their
	// explicitness and function inlining
	function isUndef(v) {
	  return v === undefined || v === null;
	}
	
	function isDef(v) {
	  return v !== undefined && v !== null;
	}
	
	function isTrue(v) {
	  return v === true;
	}
	
	function isFalse(v) {
	  return v === false;
	}
	
	/**
	 * Check if value is primitive
	 */
	function isPrimitive(value) {
	  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	}
	
	var _toString = Object.prototype.toString;
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	function isPlainObject(obj) {
	  return _toString.call(obj) === '[object Object]';
	}
	
	function isRegExp(v) {
	  return _toString.call(v) === '[object RegExp]';
	}
	
	/**
	 * Check if val is a valid array index.
	 */
	function isValidArrayIndex(val) {
	  var n = parseFloat(val);
	  return n >= 0 && Math.floor(n) === n && isFinite(val);
	}
	
	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function toString(val) {
	  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
	}
	
	/**
	 * Convert a input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber(val) {
	  var n = parseFloat(val);
	  return isNaN(n) ? val : n;
	}
	
	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap(str, expectsLowerCase) {
	  var map = Object.create(null);
	  var list = str.split(',');
	  for (var i = 0; i < list.length; i++) {
	    map[list[i]] = true;
	  }
	  return expectsLowerCase ? function (val) {
	    return map[val.toLowerCase()];
	  } : function (val) {
	    return map[val];
	  };
	}
	
	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);
	
	/**
	 * Check if a attribute is a reserved attribute.
	 */
	var isReservedAttribute = makeMap('key,ref,slot,is');
	
	/**
	 * Remove an item from an array
	 */
	function remove(arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1);
	    }
	  }
	}
	
	/**
	 * Check whether the object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Create a cached version of a pure function.
	 */
	function cached(fn) {
	  var cache = Object.create(null);
	  return function cachedFn(str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str));
	  };
	}
	
	/**
	 * Camelize a hyphen-delimited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	  return str.replace(camelizeRE, function (_, c) {
	    return c ? c.toUpperCase() : '';
	  });
	});
	
	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1);
	});
	
	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /([^-])([A-Z])/g;
	var hyphenate = cached(function (str) {
	  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
	});
	
	/**
	 * Simple bind, faster than native
	 */
	function bind(fn, ctx) {
	  function boundFn(a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  }
	  // record original fn length
	  boundFn._length = fn.length;
	  return boundFn;
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 */
	function extend(to, _from) {
	  for (var key in _from) {
	    to[key] = _from[key];
	  }
	  return to;
	}
	
	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject(arr) {
	  var res = {};
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i]) {
	      extend(res, arr[i]);
	    }
	  }
	  return res;
	}
	
	/**
	 * Perform no operation.
	 * Stubbing args to make Flow happy without leaving useless transpiled code
	 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
	 */
	function noop(a, b, c) {}
	
	/**
	 * Always return false.
	 */
	var no = function no(a, b, c) {
	  return false;
	};
	
	/**
	 * Return same value
	 */
	var identity = function identity(_) {
	  return _;
	};
	
	/**
	 * Generate a static keys string from compiler modules.
	 */
	function genStaticKeys(modules) {
	  return modules.reduce(function (keys, m) {
	    return keys.concat(m.staticKeys || []);
	  }, []).join(',');
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual(a, b) {
	  if (a === b) {
	    return true;
	  }
	  var isObjectA = isObject(a);
	  var isObjectB = isObject(b);
	  if (isObjectA && isObjectB) {
	    try {
	      var isArrayA = Array.isArray(a);
	      var isArrayB = Array.isArray(b);
	      if (isArrayA && isArrayB) {
	        return a.length === b.length && a.every(function (e, i) {
	          return looseEqual(e, b[i]);
	        });
	      } else if (!isArrayA && !isArrayB) {
	        var keysA = Object.keys(a);
	        var keysB = Object.keys(b);
	        return keysA.length === keysB.length && keysA.every(function (key) {
	          return looseEqual(a[key], b[key]);
	        });
	      } else {
	        /* istanbul ignore next */
	        return false;
	      }
	    } catch (e) {
	      /* istanbul ignore next */
	      return false;
	    }
	  } else if (!isObjectA && !isObjectB) {
	    return String(a) === String(b);
	  } else {
	    return false;
	  }
	}
	
	function looseIndexOf(arr, val) {
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	/**
	 * Ensure a function is called only once.
	 */
	function once(fn) {
	  var called = false;
	  return function () {
	    if (!called) {
	      called = true;
	      fn.apply(this, arguments);
	    }
	  };
	}
	
	var SSR_ATTR = 'data-server-rendered';
	
	var ASSET_TYPES = ['component', 'directive', 'filter'];
	
	var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];
	
	/*  */
	
	var config = {
	  /**
	   * Option merge strategies (used in core/util/options)
	   */
	  optionMergeStrategies: Object.create(null),
	
	  /**
	   * Whether to suppress warnings.
	   */
	  silent: false,
	
	  /**
	   * Show production mode tip message on boot?
	   */
	  productionTip: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to enable devtools
	   */
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to record perf
	   */
	  performance: false,
	
	  /**
	   * Error handler for watcher errors
	   */
	  errorHandler: null,
	
	  /**
	   * Warn handler for watcher warns
	   */
	  warnHandler: null,
	
	  /**
	   * Ignore certain custom elements
	   */
	  ignoredElements: [],
	
	  /**
	   * Custom user key aliases for v-on
	   */
	  keyCodes: Object.create(null),
	
	  /**
	   * Check if a tag is reserved so that it cannot be registered as a
	   * component. This is platform-dependent and may be overwritten.
	   */
	  isReservedTag: no,
	
	  /**
	   * Check if an attribute is reserved so that it cannot be used as a component
	   * prop. This is platform-dependent and may be overwritten.
	   */
	  isReservedAttr: no,
	
	  /**
	   * Check if a tag is an unknown element.
	   * Platform-dependent.
	   */
	  isUnknownElement: no,
	
	  /**
	   * Get the namespace of an element
	   */
	  getTagNamespace: noop,
	
	  /**
	   * Parse the real tag name for the specific platform.
	   */
	  parsePlatformTagName: identity,
	
	  /**
	   * Check if an attribute must be bound using property, e.g. value
	   * Platform-dependent.
	   */
	  mustUseProp: no,
	
	  /**
	   * Exposed for legacy reasons
	   */
	  _lifecycleHooks: LIFECYCLE_HOOKS
	};
	
	/*  */
	
	var emptyObject = Object.freeze({});
	
	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Define a property.
	 */
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Parse simple path.
	 */
	var bailRE = /[^\w.$]/;
	function parsePath(path) {
	  if (bailRE.test(path)) {
	    return;
	  }
	  var segments = path.split('.');
	  return function (obj) {
	    for (var i = 0; i < segments.length; i++) {
	      if (!obj) {
	        return;
	      }
	      obj = obj[segments[i]];
	    }
	    return obj;
	  };
	}
	
	/*  */
	
	var warn = noop;
	var tip = noop;
	var formatComponentName = null; // work around flow check
	
	if (process.env.NODE_ENV !== 'production') {
	  var hasConsole = typeof console !== 'undefined';
	  var classifyRE = /(?:^|[-_])(\w)/g;
	  var classify = function classify(str) {
	    return str.replace(classifyRE, function (c) {
	      return c.toUpperCase();
	    }).replace(/[-_]/g, '');
	  };
	
	  warn = function warn(msg, vm) {
	    var trace = vm ? generateComponentTrace(vm) : '';
	
	    if (config.warnHandler) {
	      config.warnHandler.call(null, msg, vm, trace);
	    } else if (hasConsole && !config.silent) {
	      console.error("[Vue warn]: " + msg + trace);
	    }
	  };
	
	  tip = function tip(msg, vm) {
	    if (hasConsole && !config.silent) {
	      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
	    }
	  };
	
	  formatComponentName = function formatComponentName(vm, includeFile) {
	    if (vm.$root === vm) {
	      return '<Root>';
	    }
	    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;
	
	    var file = vm._isVue && vm.$options.__file;
	    if (!name && file) {
	      var match = file.match(/([^/\\]+)\.vue$/);
	      name = match && match[1];
	    }
	
	    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
	  };
	
	  var repeat = function repeat(str, n) {
	    var res = '';
	    while (n) {
	      if (n % 2 === 1) {
	        res += str;
	      }
	      if (n > 1) {
	        str += str;
	      }
	      n >>= 1;
	    }
	    return res;
	  };
	
	  var generateComponentTrace = function generateComponentTrace(vm) {
	    if (vm._isVue && vm.$parent) {
	      var tree = [];
	      var currentRecursiveSequence = 0;
	      while (vm) {
	        if (tree.length > 0) {
	          var last = tree[tree.length - 1];
	          if (last.constructor === vm.constructor) {
	            currentRecursiveSequence++;
	            vm = vm.$parent;
	            continue;
	          } else if (currentRecursiveSequence > 0) {
	            tree[tree.length - 1] = [last, currentRecursiveSequence];
	            currentRecursiveSequence = 0;
	          }
	        }
	        tree.push(vm);
	        vm = vm.$parent;
	      }
	      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
	        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
	      }).join('\n');
	    } else {
	      return "\n\n(found in " + formatComponentName(vm) + ")";
	    }
	  };
	}
	
	/*  */
	
	function handleError(err, vm, info) {
	  if (config.errorHandler) {
	    config.errorHandler.call(null, err, vm, info);
	  } else {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
	    }
	    /* istanbul ignore else */
	    if (inBrowser && typeof console !== 'undefined') {
	      console.error(err);
	    } else {
	      throw err;
	    }
	  }
	}
	
	/*  */
	/* globals MutationObserver */
	
	// can we use __proto__?
	var hasProto = '__proto__' in {};
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
	var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
	
	// Firefix has a "watch" function on Object.prototype...
	var nativeWatch = {}.watch;
	
	var supportsPassive = false;
	if (inBrowser) {
	  try {
	    var opts = {};
	    Object.defineProperty(opts, 'passive', {
	      get: function get() {
	        /* istanbul ignore next */
	        supportsPassive = true;
	      }
	    }); // https://github.com/facebook/flow/issues/285
	    window.addEventListener('test-passive', null, opts);
	  } catch (e) {}
	}
	
	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function isServerRendering() {
	  if (_isServer === undefined) {
	    /* istanbul ignore if */
	    if (!inBrowser && typeof global !== 'undefined') {
	      // detect presence of vue-server-renderer and avoid
	      // Webpack shimming the process
	      _isServer = global['process'].env.VUE_ENV === 'server';
	    } else {
	      _isServer = false;
	    }
	  }
	  return _isServer;
	};
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	/* istanbul ignore next */
	function isNative(Ctor) {
	  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
	}
	
	var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
	
	/**
	 * Defer a task to execute it asynchronously.
	 */
	var nextTick = function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  // the nextTick behavior leverages the microtask queue, which can be accessed
	  // via either native Promise.then or MutationObserver.
	  // MutationObserver has wider support, however it is seriously bugged in
	  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	  // completely stops working after triggering a few times... so, if native
	  // Promise is available, we will use it:
	  /* istanbul ignore if */
	  if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p = Promise.resolve();
	    var logError = function logError(err) {
	      console.error(err);
	    };
	    timerFunc = function timerFunc() {
	      p.then(nextTickHandler).catch(logError);
	      // in problematic UIWebViews, Promise.then doesn't completely break, but
	      // it can get stuck in a weird state where callbacks are pushed into the
	      // microtask queue but the queue isn't being flushed, until the browser
	      // needs to do some other work, e.g. handle a timer. Therefore we can
	      // "force" the microtask queue to be flushed by adding an empty timer.
	      if (isIOS) {
	        setTimeout(noop);
	      }
	    };
	  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
	  // PhantomJS and iOS 7.x
	  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
	    // use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS IE11, iOS7, Android 4.4
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(String(counter));
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function timerFunc() {
	      counter = (counter + 1) % 2;
	      textNode.data = String(counter);
	    };
	  } else {
	    // fallback to setTimeout
	    /* istanbul ignore next */
	    timerFunc = function timerFunc() {
	      setTimeout(nextTickHandler, 0);
	    };
	  }
	
	  return function queueNextTick(cb, ctx) {
	    var _resolve;
	    callbacks.push(function () {
	      if (cb) {
	        try {
	          cb.call(ctx);
	        } catch (e) {
	          handleError(e, ctx, 'nextTick');
	        }
	      } else if (_resolve) {
	        _resolve(ctx);
	      }
	    });
	    if (!pending) {
	      pending = true;
	      timerFunc();
	    }
	    if (!cb && typeof Promise !== 'undefined') {
	      return new Promise(function (resolve, reject) {
	        _resolve = resolve;
	      });
	    }
	  };
	}();
	
	var _Set;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && isNative(Set)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    function Set() {
	      this.set = Object.create(null);
	    }
	    Set.prototype.has = function has(key) {
	      return this.set[key] === true;
	    };
	    Set.prototype.add = function add(key) {
	      this.set[key] = true;
	    };
	    Set.prototype.clear = function clear() {
	      this.set = Object.create(null);
	    };
	
	    return Set;
	  }();
	}
	
	/*  */
	
	var uid = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 */
	var Dep = function Dep() {
	  this.id = uid++;
	  this.subs = [];
	};
	
	Dep.prototype.addSub = function addSub(sub) {
	  this.subs.push(sub);
	};
	
	Dep.prototype.removeSub = function removeSub(sub) {
	  remove(this.subs, sub);
	};
	
	Dep.prototype.depend = function depend() {
	  if (Dep.target) {
	    Dep.target.addDep(this);
	  }
	};
	
	Dep.prototype.notify = function notify() {
	  // stabilize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	var targetStack = [];
	
	function pushTarget(_target) {
	  if (Dep.target) {
	    targetStack.push(Dep.target);
	  }
	  Dep.target = _target;
	}
	
	function popTarget() {
	  Dep.target = targetStack.pop();
	}
	
	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    var args = [],
	        len = arguments.length;
	    while (len--) {
	      args[len] = arguments[len];
	    }var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) {
	      ob.observeArray(inserted);
	    }
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/*  */
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However when passing down props,
	 * we don't want to force conversion because the value may be a nested value
	 * under a frozen data structure. Converting it would defeat the optimization.
	 */
	var observerState = {
	  shouldConvert: true
	};
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 */
	var Observer = function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  this.vmCount = 0;
	  def(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	};
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 */
	Observer.prototype.walk = function walk(obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0; i < keys.length; i++) {
	    defineReactive$$1(obj, keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 */
	Observer.prototype.observeArray = function observeArray(items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 */
	function protoAugment(target, src, keys) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 */
	/* istanbul ignore next */
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe(value, asRootData) {
	  if (!isObject(value)) {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (asRootData && ob) {
	    ob.vmCount++;
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive$$1(obj, key, val, customSetter, shallow) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = !shallow && observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          dependArray(value);
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      /* eslint-disable no-self-compare */
	      if (newVal === value || newVal !== newVal && value !== value) {
	        return;
	      }
	      /* eslint-enable no-self-compare */
	      if (process.env.NODE_ENV !== 'production' && customSetter) {
	        customSetter();
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = !shallow && observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 */
	function set(target, key, val) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.length = Math.max(target.length, key);
	    target.splice(key, 1, val);
	    return val;
	  }
	  if (hasOwn(target, key)) {
	    target[key] = val;
	    return val;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
	    return val;
	  }
	  if (!ob) {
	    target[key] = val;
	    return val;
	  }
	  defineReactive$$1(ob.value, key, val);
	  ob.dep.notify();
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 */
	function del(target, key) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.splice(key, 1);
	    return;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
	    return;
	  }
	  if (!hasOwn(target, key)) {
	    return;
	  }
	  delete target[key];
	  if (!ob) {
	    return;
	  }
	  ob.dep.notify();
	}
	
	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray(value) {
	  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
	    e = value[i];
	    e && e.__ob__ && e.__ob__.dep.depend();
	    if (Array.isArray(e)) {
	      dependArray(e);
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;
	
	/**
	 * Options with restrictions
	 */
	if (process.env.NODE_ENV !== 'production') {
	  strats.el = strats.propsData = function (parent, child, vm, key) {
	    if (!vm) {
	      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
	    }
	    return defaultStrat(parent, child);
	  };
	}
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData(to, from) {
	  if (!from) {
	    return to;
	  }
	  var key, toVal, fromVal;
	  var keys = Object.keys(from);
	  for (var i = 0; i < keys.length; i++) {
	    key = keys[i];
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	function mergeDataOrFn(parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	}
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    if (childVal && typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	
	      return parentVal;
	    }
	    return mergeDataOrFn.call(this, parentVal, childVal);
	  }
	
	  return mergeDataOrFn(parentVal, childVal, vm);
	};
	
	/**
	 * Hooks and props are merged as arrays.
	 */
	function mergeHook(parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
	}
	
	LIFECYCLE_HOOKS.forEach(function (hook) {
	  strats[hook] = mergeHook;
	});
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, childVal) : res;
	}
	
	ASSET_TYPES.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal) {
	  // work around Firefox's Object.prototype.watch...
	  if (parentVal === nativeWatch) {
	    parentVal = undefined;
	  }
	  if (childVal === nativeWatch) {
	    childVal = undefined;
	  }
	  /* istanbul ignore if */
	  if (!childVal) {
	    return Object.create(parentVal || null);
	  }
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !Array.isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  if (childVal) {
	    extend(ret, childVal);
	  }
	  return ret;
	};
	strats.provide = mergeDataOrFn;
	
	/**
	 * Default strategy.
	 */
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Validate component names
	 */
	function checkComponents(options) {
	  for (var key in options.components) {
	    var lower = key.toLowerCase();
	    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
	      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps(options) {
	  var props = options.props;
	  if (!props) {
	    return;
	  }
	  var res = {};
	  var i, val, name;
	  if (Array.isArray(props)) {
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        name = camelize(val);
	        res[name] = { type: null };
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('props must be strings when using array syntax.');
	      }
	    }
	  } else if (isPlainObject(props)) {
	    for (var key in props) {
	      val = props[key];
	      name = camelize(key);
	      res[name] = isPlainObject(val) ? val : { type: val };
	    }
	  }
	  options.props = res;
	}
	
	/**
	 * Normalize all injections into Object-based format
	 */
	function normalizeInject(options) {
	  var inject = options.inject;
	  if (Array.isArray(inject)) {
	    var normalized = options.inject = {};
	    for (var i = 0; i < inject.length; i++) {
	      normalized[inject[i]] = inject[i];
	    }
	  }
	}
	
	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives(options) {
	  var dirs = options.directives;
	  if (dirs) {
	    for (var key in dirs) {
	      var def = dirs[key];
	      if (typeof def === 'function') {
	        dirs[key] = { bind: def, update: def };
	      }
	    }
	  }
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions(parent, child, vm) {
	  if (process.env.NODE_ENV !== 'production') {
	    checkComponents(child);
	  }
	
	  if (typeof child === 'function') {
	    child = child.options;
	  }
	
	  normalizeProps(child);
	  normalizeInject(child);
	  normalizeDirectives(child);
	  var extendsFrom = child.extends;
	  if (extendsFrom) {
	    parent = mergeOptions(parent, extendsFrom, vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  var options = {};
	  var key;
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  // check local registration variations first
	  if (hasOwn(assets, id)) {
	    return assets[id];
	  }
	  var camelizedId = camelize(id);
	  if (hasOwn(assets, camelizedId)) {
	    return assets[camelizedId];
	  }
	  var PascalCaseId = capitalize(camelizedId);
	  if (hasOwn(assets, PascalCaseId)) {
	    return assets[PascalCaseId];
	  }
	  // fallback to prototype chain
	  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	/*  */
	
	function validateProp(key, propOptions, propsData, vm) {
	  var prop = propOptions[key];
	  var absent = !hasOwn(propsData, key);
	  var value = propsData[key];
	  // handle boolean props
	  if (isType(Boolean, prop.type)) {
	    if (absent && !hasOwn(prop, 'default')) {
	      value = false;
	    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
	      value = true;
	    }
	  }
	  // check default value
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop, key);
	    // since the default value is a fresh copy,
	    // make sure to observe it.
	    var prevShouldConvert = observerState.shouldConvert;
	    observerState.shouldConvert = true;
	    observe(value);
	    observerState.shouldConvert = prevShouldConvert;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    assertProp(prop, key, value, vm, absent);
	  }
	  return value;
	}
	
	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue(vm, prop, key) {
	  // no default, return undefined
	  if (!hasOwn(prop, 'default')) {
	    return undefined;
	  }
	  var def = prop.default;
	  // warn against non-factory defaults for Object & Array
	  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
	    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // the raw prop value was also undefined from previous render,
	  // return previous default value to avoid unnecessary watcher trigger
	  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
	    return vm._props[key];
	  }
	  // call factory function for non-Function types
	  // a value is Function if its prototype is function even across different execution context
	  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp(prop, name, value, vm, absent) {
	  if (prop.required && absent) {
	    warn('Missing required prop: "' + name + '"', vm);
	    return;
	  }
	  if (value == null && !prop.required) {
	    return;
	  }
	  var type = prop.type;
	  var valid = !type || type === true;
	  var expectedTypes = [];
	  if (type) {
	    if (!Array.isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType || '');
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
	    return;
	  }
	  var validator = prop.validator;
	  if (validator) {
	    if (!validator(value)) {
	      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
	    }
	  }
	}
	
	var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
	
	function assertType(value, type) {
	  var valid;
	  var expectedType = getType(type);
	  if (simpleCheckRE.test(expectedType)) {
	    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();
	  } else if (expectedType === 'Object') {
	    valid = isPlainObject(value);
	  } else if (expectedType === 'Array') {
	    valid = Array.isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType(fn) {
	  var match = fn && fn.toString().match(/^\s*function (\w+)/);
	  return match ? match[1] : '';
	}
	
	function isType(type, fn) {
	  if (!Array.isArray(fn)) {
	    return getType(fn) === getType(type);
	  }
	  for (var i = 0, len = fn.length; i < len; i++) {
	    if (getType(fn[i]) === getType(type)) {
	      return true;
	    }
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	/*  */
	
	var mark;
	var measure;
	
	if (process.env.NODE_ENV !== 'production') {
	  var perf = inBrowser && window.performance;
	  /* istanbul ignore if */
	  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
	    mark = function mark(tag) {
	      return perf.mark(tag);
	    };
	    measure = function measure(name, startTag, endTag) {
	      perf.measure(name, startTag, endTag);
	      perf.clearMarks(startTag);
	      perf.clearMarks(endTag);
	      perf.clearMeasures(name);
	    };
	  }
	}
	
	/* not type checking this file because flow doesn't play well with Proxy */
	
	var initProxy;
	
	if (process.env.NODE_ENV !== 'production') {
	  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
	  );
	
	  var warnNonPresent = function warnNonPresent(target, key) {
	    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
	  };
	
	  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);
	
	  if (hasProxy) {
	    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
	    config.keyCodes = new Proxy(config.keyCodes, {
	      set: function set(target, key, value) {
	        if (isBuiltInModifier(key)) {
	          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
	          return false;
	        } else {
	          target[key] = value;
	          return true;
	        }
	      }
	    });
	  }
	
	  var hasHandler = {
	    has: function has(target, key) {
	      var has = key in target;
	      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
	      if (!has && !isAllowed) {
	        warnNonPresent(target, key);
	      }
	      return has || !isAllowed;
	    }
	  };
	
	  var getHandler = {
	    get: function get(target, key) {
	      if (typeof key === 'string' && !(key in target)) {
	        warnNonPresent(target, key);
	      }
	      return target[key];
	    }
	  };
	
	  initProxy = function initProxy(vm) {
	    if (hasProxy) {
	      // determine which proxy handler to use
	      var options = vm.$options;
	      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
	      vm._renderProxy = new Proxy(vm, handlers);
	    } else {
	      vm._renderProxy = vm;
	    }
	  };
	}
	
	/*  */
	
	var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
	  this.tag = tag;
	  this.data = data;
	  this.children = children;
	  this.text = text;
	  this.elm = elm;
	  this.ns = undefined;
	  this.context = context;
	  this.functionalContext = undefined;
	  this.key = data && data.key;
	  this.componentOptions = componentOptions;
	  this.componentInstance = undefined;
	  this.parent = undefined;
	  this.raw = false;
	  this.isStatic = false;
	  this.isRootInsert = true;
	  this.isComment = false;
	  this.isCloned = false;
	  this.isOnce = false;
	  this.asyncFactory = asyncFactory;
	  this.asyncMeta = undefined;
	  this.isAsyncPlaceholder = false;
	};
	
	var prototypeAccessors = { child: {} };
	
	// DEPRECATED: alias for componentInstance for backwards compat.
	/* istanbul ignore next */
	prototypeAccessors.child.get = function () {
	  return this.componentInstance;
	};
	
	Object.defineProperties(VNode.prototype, prototypeAccessors);
	
	var createEmptyVNode = function createEmptyVNode(text) {
	  if (text === void 0) text = '';
	
	  var node = new VNode();
	  node.text = text;
	  node.isComment = true;
	  return node;
	};
	
	function createTextVNode(val) {
	  return new VNode(undefined, undefined, undefined, String(val));
	}
	
	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode(vnode) {
	  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
	  cloned.ns = vnode.ns;
	  cloned.isStatic = vnode.isStatic;
	  cloned.key = vnode.key;
	  cloned.isComment = vnode.isComment;
	  cloned.isCloned = true;
	  return cloned;
	}
	
	function cloneVNodes(vnodes) {
	  var len = vnodes.length;
	  var res = new Array(len);
	  for (var i = 0; i < len; i++) {
	    res[i] = cloneVNode(vnodes[i]);
	  }
	  return res;
	}
	
	/*  */
	
	var normalizeEvent = cached(function (name) {
	  var passive = name.charAt(0) === '&';
	  name = passive ? name.slice(1) : name;
	  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
	  name = once$$1 ? name.slice(1) : name;
	  var capture = name.charAt(0) === '!';
	  name = capture ? name.slice(1) : name;
	  return {
	    name: name,
	    once: once$$1,
	    capture: capture,
	    passive: passive
	  };
	});
	
	function createFnInvoker(fns) {
	  function invoker() {
	    var arguments$1 = arguments;
	
	    var fns = invoker.fns;
	    if (Array.isArray(fns)) {
	      var cloned = fns.slice();
	      for (var i = 0; i < cloned.length; i++) {
	        cloned[i].apply(null, arguments$1);
	      }
	    } else {
	      // return handler return value for single handlers
	      return fns.apply(null, arguments);
	    }
	  }
	  invoker.fns = fns;
	  return invoker;
	}
	
	function updateListeners(on, oldOn, add, remove$$1, vm) {
	  var name, cur, old, event;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    event = normalizeEvent(name);
	    if (isUndef(cur)) {
	      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
	    } else if (isUndef(old)) {
	      if (isUndef(cur.fns)) {
	        cur = on[name] = createFnInvoker(cur);
	      }
	      add(event.name, cur, event.once, event.capture, event.passive);
	    } else if (cur !== old) {
	      old.fns = cur;
	      on[name] = old;
	    }
	  }
	  for (name in oldOn) {
	    if (isUndef(on[name])) {
	      event = normalizeEvent(name);
	      remove$$1(event.name, oldOn[name], event.capture);
	    }
	  }
	}
	
	/*  */
	
	function mergeVNodeHook(def, hookKey, hook) {
	  var invoker;
	  var oldHook = def[hookKey];
	
	  function wrappedHook() {
	    hook.apply(this, arguments);
	    // important: remove merged hook to ensure it's called only once
	    // and prevent memory leak
	    remove(invoker.fns, wrappedHook);
	  }
	
	  if (isUndef(oldHook)) {
	    // no existing hook
	    invoker = createFnInvoker([wrappedHook]);
	  } else {
	    /* istanbul ignore if */
	    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
	      // already a merged invoker
	      invoker = oldHook;
	      invoker.fns.push(wrappedHook);
	    } else {
	      // existing plain hook
	      invoker = createFnInvoker([oldHook, wrappedHook]);
	    }
	  }
	
	  invoker.merged = true;
	  def[hookKey] = invoker;
	}
	
	/*  */
	
	function extractPropsFromVNodeData(data, Ctor, tag) {
	  // we are only extracting raw values here.
	  // validation and default values are handled in the child
	  // component itself.
	  var propOptions = Ctor.options.props;
	  if (isUndef(propOptions)) {
	    return;
	  }
	  var res = {};
	  var attrs = data.attrs;
	  var props = data.props;
	  if (isDef(attrs) || isDef(props)) {
	    for (var key in propOptions) {
	      var altKey = hyphenate(key);
	      if (process.env.NODE_ENV !== 'production') {
	        var keyInLowerCase = key.toLowerCase();
	        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
	          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
	        }
	      }
	      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
	    }
	  }
	  return res;
	}
	
	function checkProp(res, hash, key, altKey, preserve) {
	  if (isDef(hash)) {
	    if (hasOwn(hash, key)) {
	      res[key] = hash[key];
	      if (!preserve) {
	        delete hash[key];
	      }
	      return true;
	    } else if (hasOwn(hash, altKey)) {
	      res[key] = hash[altKey];
	      if (!preserve) {
	        delete hash[altKey];
	      }
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	// The template compiler attempts to minimize the need for normalization by
	// statically analyzing the template at compile time.
	//
	// For plain HTML markup, normalization can be completely skipped because the
	// generated render function is guaranteed to return Array<VNode>. There are
	// two cases where extra normalization is needed:
	
	// 1. When the children contains components - because a functional component
	// may return an Array instead of a single root. In this case, just a simple
	// normalization is needed - if any child is an Array, we flatten the whole
	// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
	// because functional components already normalize their own children.
	function simpleNormalizeChildren(children) {
	  for (var i = 0; i < children.length; i++) {
	    if (Array.isArray(children[i])) {
	      return Array.prototype.concat.apply([], children);
	    }
	  }
	  return children;
	}
	
	// 2. When the children contains constructs that always generated nested Arrays,
	// e.g. <template>, <slot>, v-for, or when the children is provided by user
	// with hand-written render functions / JSX. In such cases a full normalization
	// is needed to cater to all possible types of children values.
	function normalizeChildren(children) {
	  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
	}
	
	function isTextNode(node) {
	  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
	}
	
	function normalizeArrayChildren(children, nestedIndex) {
	  var res = [];
	  var i, c, last;
	  for (i = 0; i < children.length; i++) {
	    c = children[i];
	    if (isUndef(c) || typeof c === 'boolean') {
	      continue;
	    }
	    last = res[res.length - 1];
	    //  nested
	    if (Array.isArray(c)) {
	      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
	    } else if (isPrimitive(c)) {
	      if (isTextNode(last)) {
	        // merge adjacent text nodes
	        // this is necessary for SSR hydration because text nodes are
	        // essentially merged when rendered to HTML strings
	        last.text += String(c);
	      } else if (c !== '') {
	        // convert primitive to vnode
	        res.push(createTextVNode(c));
	      }
	    } else {
	      if (isTextNode(c) && isTextNode(last)) {
	        // merge adjacent text nodes
	        res[res.length - 1] = createTextVNode(last.text + c.text);
	      } else {
	        // default key for nested array children (likely generated by v-for)
	        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
	          c.key = "__vlist" + nestedIndex + "_" + i + "__";
	        }
	        res.push(c);
	      }
	    }
	  }
	  return res;
	}
	
	/*  */
	
	function ensureCtor(comp, base) {
	  if (comp.__esModule && comp.default) {
	    comp = comp.default;
	  }
	  return isObject(comp) ? base.extend(comp) : comp;
	}
	
	function createAsyncPlaceholder(factory, data, context, children, tag) {
	  var node = createEmptyVNode();
	  node.asyncFactory = factory;
	  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
	  return node;
	}
	
	function resolveAsyncComponent(factory, baseCtor, context) {
	  if (isTrue(factory.error) && isDef(factory.errorComp)) {
	    return factory.errorComp;
	  }
	
	  if (isDef(factory.resolved)) {
	    return factory.resolved;
	  }
	
	  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
	    return factory.loadingComp;
	  }
	
	  if (isDef(factory.contexts)) {
	    // already pending
	    factory.contexts.push(context);
	  } else {
	    var contexts = factory.contexts = [context];
	    var sync = true;
	
	    var forceRender = function forceRender() {
	      for (var i = 0, l = contexts.length; i < l; i++) {
	        contexts[i].$forceUpdate();
	      }
	    };
	
	    var resolve = once(function (res) {
	      // cache resolved
	      factory.resolved = ensureCtor(res, baseCtor);
	      // invoke callbacks only if this is not a synchronous resolve
	      // (async resolves are shimmed as synchronous during SSR)
	      if (!sync) {
	        forceRender();
	      }
	    });
	
	    var reject = once(function (reason) {
	      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
	      if (isDef(factory.errorComp)) {
	        factory.error = true;
	        forceRender();
	      }
	    });
	
	    var res = factory(resolve, reject);
	
	    if (isObject(res)) {
	      if (typeof res.then === 'function') {
	        // () => Promise
	        if (isUndef(factory.resolved)) {
	          res.then(resolve, reject);
	        }
	      } else if (isDef(res.component) && typeof res.component.then === 'function') {
	        res.component.then(resolve, reject);
	
	        if (isDef(res.error)) {
	          factory.errorComp = ensureCtor(res.error, baseCtor);
	        }
	
	        if (isDef(res.loading)) {
	          factory.loadingComp = ensureCtor(res.loading, baseCtor);
	          if (res.delay === 0) {
	            factory.loading = true;
	          } else {
	            setTimeout(function () {
	              if (isUndef(factory.resolved) && isUndef(factory.error)) {
	                factory.loading = true;
	                forceRender();
	              }
	            }, res.delay || 200);
	          }
	        }
	
	        if (isDef(res.timeout)) {
	          setTimeout(function () {
	            if (isUndef(factory.resolved)) {
	              reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
	            }
	          }, res.timeout);
	        }
	      }
	    }
	
	    sync = false;
	    // return in case resolved synchronously
	    return factory.loading ? factory.loadingComp : factory.resolved;
	  }
	}
	
	/*  */
	
	function getFirstComponentChild(children) {
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      var c = children[i];
	      if (isDef(c) && isDef(c.componentOptions)) {
	        return c;
	      }
	    }
	  }
	}
	
	/*  */
	
	/*  */
	
	function initEvents(vm) {
	  vm._events = Object.create(null);
	  vm._hasHookEvent = false;
	  // init parent attached events
	  var listeners = vm.$options._parentListeners;
	  if (listeners) {
	    updateComponentListeners(vm, listeners);
	  }
	}
	
	var target;
	
	function add(event, fn, once$$1) {
	  if (once$$1) {
	    target.$once(event, fn);
	  } else {
	    target.$on(event, fn);
	  }
	}
	
	function remove$1(event, fn) {
	  target.$off(event, fn);
	}
	
	function updateComponentListeners(vm, listeners, oldListeners) {
	  target = vm;
	  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
	}
	
	function eventsMixin(Vue) {
	  var hookRE = /^hook:/;
	  Vue.prototype.$on = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    if (Array.isArray(event)) {
	      for (var i = 0, l = event.length; i < l; i++) {
	        this$1.$on(event[i], fn);
	      }
	    } else {
	      (vm._events[event] || (vm._events[event] = [])).push(fn);
	      // optimize hook:event cost by using a boolean flag marked at registration
	      // instead of a hash lookup
	      if (hookRE.test(event)) {
	        vm._hasHookEvent = true;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$once = function (event, fn) {
	    var vm = this;
	    function on() {
	      vm.$off(event, on);
	      fn.apply(vm, arguments);
	    }
	    on.fn = fn;
	    vm.$on(event, on);
	    return vm;
	  };
	
	  Vue.prototype.$off = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    // all
	    if (!arguments.length) {
	      vm._events = Object.create(null);
	      return vm;
	    }
	    // array of events
	    if (Array.isArray(event)) {
	      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
	        this$1.$off(event[i$1], fn);
	      }
	      return vm;
	    }
	    // specific event
	    var cbs = vm._events[event];
	    if (!cbs) {
	      return vm;
	    }
	    if (arguments.length === 1) {
	      vm._events[event] = null;
	      return vm;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$emit = function (event) {
	    var vm = this;
	    if (process.env.NODE_ENV !== 'production') {
	      var lowerCaseEvent = event.toLowerCase();
	      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
	        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
	      }
	    }
	    var cbs = vm._events[event];
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        try {
	          cbs[i].apply(vm, args);
	        } catch (e) {
	          handleError(e, vm, "event handler for \"" + event + "\"");
	        }
	      }
	    }
	    return vm;
	  };
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving raw children VNodes into a slot object.
	 */
	function resolveSlots(children, context) {
	  var slots = {};
	  if (!children) {
	    return slots;
	  }
	  var defaultSlot = [];
	  for (var i = 0, l = children.length; i < l; i++) {
	    var child = children[i];
	    // named slots should only be respected if the vnode was rendered in the
	    // same context.
	    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {
	      var name = child.data.slot;
	      var slot = slots[name] || (slots[name] = []);
	      if (child.tag === 'template') {
	        slot.push.apply(slot, child.children);
	      } else {
	        slot.push(child);
	      }
	    } else {
	      defaultSlot.push(child);
	    }
	  }
	  // ignore whitespace
	  if (!defaultSlot.every(isWhitespace)) {
	    slots.default = defaultSlot;
	  }
	  return slots;
	}
	
	function isWhitespace(node) {
	  return node.isComment || node.text === ' ';
	}
	
	function resolveScopedSlots(fns, // see flow/vnode
	res) {
	  res = res || {};
	  for (var i = 0; i < fns.length; i++) {
	    if (Array.isArray(fns[i])) {
	      resolveScopedSlots(fns[i], res);
	    } else {
	      res[fns[i].key] = fns[i].fn;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var activeInstance = null;
	var isUpdatingChildComponent = false;
	
	function initLifecycle(vm) {
	  var options = vm.$options;
	
	  // locate first non-abstract parent
	  var parent = options.parent;
	  if (parent && !options.abstract) {
	    while (parent.$options.abstract && parent.$parent) {
	      parent = parent.$parent;
	    }
	    parent.$children.push(vm);
	  }
	
	  vm.$parent = parent;
	  vm.$root = parent ? parent.$root : vm;
	
	  vm.$children = [];
	  vm.$refs = {};
	
	  vm._watcher = null;
	  vm._inactive = null;
	  vm._directInactive = false;
	  vm._isMounted = false;
	  vm._isDestroyed = false;
	  vm._isBeingDestroyed = false;
	}
	
	function lifecycleMixin(Vue) {
	  Vue.prototype._update = function (vnode, hydrating) {
	    var vm = this;
	    if (vm._isMounted) {
	      callHook(vm, 'beforeUpdate');
	    }
	    var prevEl = vm.$el;
	    var prevVnode = vm._vnode;
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    vm._vnode = vnode;
	    // Vue.prototype.__patch__ is injected in entry points
	    // based on the rendering backend used.
	    if (!prevVnode) {
	      // initial render
	      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
	      , vm.$options._parentElm, vm.$options._refElm);
	      // no need for the ref nodes after initial patch
	      // this prevents keeping a detached DOM tree in memory (#5851)
	      vm.$options._parentElm = vm.$options._refElm = null;
	    } else {
	      // updates
	      vm.$el = vm.__patch__(prevVnode, vnode);
	    }
	    activeInstance = prevActiveInstance;
	    // update __vue__ reference
	    if (prevEl) {
	      prevEl.__vue__ = null;
	    }
	    if (vm.$el) {
	      vm.$el.__vue__ = vm;
	    }
	    // if parent is an HOC, update its $el as well
	    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	      vm.$parent.$el = vm.$el;
	    }
	    // updated hook is called by the scheduler to ensure that children are
	    // updated in a parent's updated hook.
	  };
	
	  Vue.prototype.$forceUpdate = function () {
	    var vm = this;
	    if (vm._watcher) {
	      vm._watcher.update();
	    }
	  };
	
	  Vue.prototype.$destroy = function () {
	    var vm = this;
	    if (vm._isBeingDestroyed) {
	      return;
	    }
	    callHook(vm, 'beforeDestroy');
	    vm._isBeingDestroyed = true;
	    // remove self from parent
	    var parent = vm.$parent;
	    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	      remove(parent.$children, vm);
	    }
	    // teardown watchers
	    if (vm._watcher) {
	      vm._watcher.teardown();
	    }
	    var i = vm._watchers.length;
	    while (i--) {
	      vm._watchers[i].teardown();
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (vm._data.__ob__) {
	      vm._data.__ob__.vmCount--;
	    }
	    // call the last hook...
	    vm._isDestroyed = true;
	    // invoke destroy hooks on current rendered tree
	    vm.__patch__(vm._vnode, null);
	    // fire destroyed hook
	    callHook(vm, 'destroyed');
	    // turn off all instance listeners.
	    vm.$off();
	    // remove __vue__ reference
	    if (vm.$el) {
	      vm.$el.__vue__ = null;
	    }
	  };
	}
	
	function mountComponent(vm, el, hydrating) {
	  vm.$el = el;
	  if (!vm.$options.render) {
	    vm.$options.render = createEmptyVNode;
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
	        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
	      } else {
	        warn('Failed to mount component: template or render function not defined.', vm);
	      }
	    }
	  }
	  callHook(vm, 'beforeMount');
	
	  var updateComponent;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	    updateComponent = function updateComponent() {
	      var name = vm._name;
	      var id = vm._uid;
	      var startTag = "vue-perf-start:" + id;
	      var endTag = "vue-perf-end:" + id;
	
	      mark(startTag);
	      var vnode = vm._render();
	      mark(endTag);
	      measure(name + " render", startTag, endTag);
	
	      mark(startTag);
	      vm._update(vnode, hydrating);
	      mark(endTag);
	      measure(name + " patch", startTag, endTag);
	    };
	  } else {
	    updateComponent = function updateComponent() {
	      vm._update(vm._render(), hydrating);
	    };
	  }
	
	  vm._watcher = new Watcher(vm, updateComponent, noop);
	  hydrating = false;
	
	  // manually mounted instance, call mounted on self
	  // mounted is called for render-created child components in its inserted hook
	  if (vm.$vnode == null) {
	    vm._isMounted = true;
	    callHook(vm, 'mounted');
	  }
	  return vm;
	}
	
	function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = true;
	  }
	
	  // determine whether component has slot children
	  // we need to do this before overwriting $options._renderChildren
	  var hasChildren = !!(renderChildren || // has new static slots
	  vm.$options._renderChildren || // has old static slots
	  parentVnode.data.scopedSlots || // has new scoped slots
	  vm.$scopedSlots !== emptyObject // has old scoped slots
	  );
	
	  vm.$options._parentVnode = parentVnode;
	  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
	
	  if (vm._vnode) {
	    // update child tree's parent
	    vm._vnode.parent = parentVnode;
	  }
	  vm.$options._renderChildren = renderChildren;
	
	  // update $attrs and $listensers hash
	  // these are also reactive so they may trigger child update if the child
	  // used them during render
	  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
	  vm.$listeners = listeners;
	
	  // update props
	  if (propsData && vm.$options.props) {
	    observerState.shouldConvert = false;
	    var props = vm._props;
	    var propKeys = vm.$options._propKeys || [];
	    for (var i = 0; i < propKeys.length; i++) {
	      var key = propKeys[i];
	      props[key] = validateProp(key, vm.$options.props, propsData, vm);
	    }
	    observerState.shouldConvert = true;
	    // keep a copy of raw propsData
	    vm.$options.propsData = propsData;
	  }
	
	  // update listeners
	  if (listeners) {
	    var oldListeners = vm.$options._parentListeners;
	    vm.$options._parentListeners = listeners;
	    updateComponentListeners(vm, listeners, oldListeners);
	  }
	  // resolve slots + force update if has children
	  if (hasChildren) {
	    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
	    vm.$forceUpdate();
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = false;
	  }
	}
	
	function isInInactiveTree(vm) {
	  while (vm && (vm = vm.$parent)) {
	    if (vm._inactive) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function activateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = false;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  } else if (vm._directInactive) {
	    return;
	  }
	  if (vm._inactive || vm._inactive === null) {
	    vm._inactive = false;
	    for (var i = 0; i < vm.$children.length; i++) {
	      activateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'activated');
	  }
	}
	
	function deactivateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = true;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  }
	  if (!vm._inactive) {
	    vm._inactive = true;
	    for (var i = 0; i < vm.$children.length; i++) {
	      deactivateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'deactivated');
	  }
	}
	
	function callHook(vm, hook) {
	  var handlers = vm.$options[hook];
	  if (handlers) {
	    for (var i = 0, j = handlers.length; i < j; i++) {
	      try {
	        handlers[i].call(vm);
	      } catch (e) {
	        handleError(e, vm, hook + " hook");
	      }
	    }
	  }
	  if (vm._hasHookEvent) {
	    vm.$emit('hook:' + hook);
	  }
	}
	
	/*  */
	
	var MAX_UPDATE_COUNT = 100;
	
	var queue = [];
	var activatedChildren = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;
	
	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState() {
	  index = queue.length = activatedChildren.length = 0;
	  has = {};
	  if (process.env.NODE_ENV !== 'production') {
	    circular = {};
	  }
	  waiting = flushing = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue() {
	  flushing = true;
	  var watcher, id;
	
	  // Sort queue before flush.
	  // This ensures that:
	  // 1. Components are updated from parent to child. (because parent is always
	  //    created before the child)
	  // 2. A component's user watchers are run before its render watcher (because
	  //    user watchers are created before the render watcher)
	  // 3. If a component is destroyed during a parent component's watcher run,
	  //    its watchers can be skipped.
	  queue.sort(function (a, b) {
	    return a.id - b.id;
	  });
	
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (index = 0; index < queue.length; index++) {
	    watcher = queue[index];
	    id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > MAX_UPDATE_COUNT) {
	        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
	        break;
	      }
	    }
	  }
	
	  // keep copies of post queues before resetting state
	  var activatedQueue = activatedChildren.slice();
	  var updatedQueue = queue.slice();
	
	  resetSchedulerState();
	
	  // call component updated and activated hooks
	  callActivatedHooks(activatedQueue);
	  callUpdatedHooks(updatedQueue);
	
	  // devtool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }
	}
	
	function callUpdatedHooks(queue) {
	  var i = queue.length;
	  while (i--) {
	    var watcher = queue[i];
	    var vm = watcher.vm;
	    if (vm._watcher === watcher && vm._isMounted) {
	      callHook(vm, 'updated');
	    }
	  }
	}
	
	/**
	 * Queue a kept-alive component that was activated during patch.
	 * The queue will be processed after the entire tree has been patched.
	 */
	function queueActivatedComponent(vm) {
	  // setting _inactive to false here so that a render function can
	  // rely on checking whether it's in an inactive tree (e.g. router-view)
	  vm._inactive = false;
	  activatedChildren.push(vm);
	}
	
	function callActivatedHooks(queue) {
	  for (var i = 0; i < queue.length; i++) {
	    queue[i]._inactive = true;
	    activateChildComponent(queue[i], true /* true */);
	  }
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    has[id] = true;
	    if (!flushing) {
	      queue.push(watcher);
	    } else {
	      // if already flushing, splice the watcher based on its id
	      // if already past its id, it will be run next immediately.
	      var i = queue.length - 1;
	      while (i > index && queue[i].id > watcher.id) {
	        i--;
	      }
	      queue.splice(i + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushSchedulerQueue);
	    }
	  }
	}
	
	/*  */
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 */
	var Watcher = function Watcher(vm, expOrFn, cb, options) {
	  this.vm = vm;
	  vm._watchers.push(this);
	  // options
	  if (options) {
	    this.deep = !!options.deep;
	    this.user = !!options.user;
	    this.lazy = !!options.lazy;
	    this.sync = !!options.sync;
	  } else {
	    this.deep = this.user = this.lazy = this.sync = false;
	  }
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
	  // parse expression for getter
	  if (typeof expOrFn === 'function') {
	    this.getter = expOrFn;
	  } else {
	    this.getter = parsePath(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
	    }
	  }
	  this.value = this.lazy ? undefined : this.get();
	};
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	Watcher.prototype.get = function get() {
	  pushTarget(this);
	  var value;
	  var vm = this.vm;
	  try {
	    value = this.getter.call(vm, vm);
	  } catch (e) {
	    if (this.user) {
	      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
	    } else {
	      throw e;
	    }
	  } finally {
	    // "touch" every property so they are all tracked as
	    // dependencies for deep watching
	    if (this.deep) {
	      traverse(value);
	    }
	    popTarget();
	    this.cleanupDeps();
	  }
	  return value;
	};
	
	/**
	 * Add a dependency to this directive.
	 */
	Watcher.prototype.addDep = function addDep(dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	Watcher.prototype.cleanupDeps = function cleanupDeps() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this$1.deps[i];
	    if (!this$1.newDepIds.has(dep.id)) {
	      dep.removeSub(this$1);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 */
	Watcher.prototype.update = function update() {
	  /* istanbul ignore else */
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync) {
	    this.run();
	  } else {
	    queueWatcher(this);
	  }
	};
	
	/**
	 * Scheduler job interface.
	 * Will be called by the scheduler.
	 */
	Watcher.prototype.run = function run() {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated.
	    isObject(value) || this.deep) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      if (this.user) {
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	Watcher.prototype.evaluate = function evaluate() {
	  this.value = this.get();
	  this.dirty = false;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	Watcher.prototype.depend = function depend() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    this$1.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subscriber list.
	 */
	Watcher.prototype.teardown = function teardown() {
	  var this$1 = this;
	
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed.
	    if (!this.vm._isBeingDestroyed) {
	      remove(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this$1.deps[i].removeSub(this$1);
	    }
	    this.active = false;
	  }
	};
	
	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	var seenObjects = new _Set();
	function traverse(val) {
	  seenObjects.clear();
	  _traverse(val, seenObjects);
	}
	
	function _traverse(val, seen) {
	  var i, keys;
	  var isA = Array.isArray(val);
	  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
	    return;
	  }
	  if (val.__ob__) {
	    var depId = val.__ob__.dep.id;
	    if (seen.has(depId)) {
	      return;
	    }
	    seen.add(depId);
	  }
	  if (isA) {
	    i = val.length;
	    while (i--) {
	      _traverse(val[i], seen);
	    }
	  } else {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      _traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	/*  */
	
	var sharedPropertyDefinition = {
	  enumerable: true,
	  configurable: true,
	  get: noop,
	  set: noop
	};
	
	function proxy(target, sourceKey, key) {
	  sharedPropertyDefinition.get = function proxyGetter() {
	    return this[sourceKey][key];
	  };
	  sharedPropertyDefinition.set = function proxySetter(val) {
	    this[sourceKey][key] = val;
	  };
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function initState(vm) {
	  vm._watchers = [];
	  var opts = vm.$options;
	  if (opts.props) {
	    initProps(vm, opts.props);
	  }
	  if (opts.methods) {
	    initMethods(vm, opts.methods);
	  }
	  if (opts.data) {
	    initData(vm);
	  } else {
	    observe(vm._data = {}, true /* asRootData */);
	  }
	  if (opts.computed) {
	    initComputed(vm, opts.computed);
	  }
	  if (opts.watch && opts.watch !== nativeWatch) {
	    initWatch(vm, opts.watch);
	  }
	}
	
	function checkOptionType(vm, name) {
	  var option = vm.$options[name];
	  if (!isPlainObject(option)) {
	    warn("component option \"" + name + "\" should be an object.", vm);
	  }
	}
	
	function initProps(vm, propsOptions) {
	  var propsData = vm.$options.propsData || {};
	  var props = vm._props = {};
	  // cache prop keys so that future props updates can iterate using Array
	  // instead of dynamic object key enumeration.
	  var keys = vm.$options._propKeys = [];
	  var isRoot = !vm.$parent;
	  // root instance props should be converted
	  observerState.shouldConvert = isRoot;
	  var loop = function loop(key) {
	    keys.push(key);
	    var value = validateProp(key, propsOptions, propsData, vm);
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
	        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
	      }
	      defineReactive$$1(props, key, value, function () {
	        if (vm.$parent && !isUpdatingChildComponent) {
	          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
	        }
	      });
	    } else {
	      defineReactive$$1(props, key, value);
	    }
	    // static props are already proxied on the component's prototype
	    // during Vue.extend(). We only need to proxy props defined at
	    // instantiation here.
	    if (!(key in vm)) {
	      proxy(vm, "_props", key);
	    }
	  };
	
	  for (var key in propsOptions) {
	    loop(key);
	  }observerState.shouldConvert = true;
	}
	
	function initData(vm) {
	  var data = vm.$options.data;
	  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
	  if (!isPlainObject(data)) {
	    data = {};
	    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var props = vm.$options.props;
	  var methods = vm.$options.methods;
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods && hasOwn(methods, key)) {
	        warn("method \"" + key + "\" has already been defined as a data property.", vm);
	      }
	    }
	    if (props && hasOwn(props, key)) {
	      process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
	    } else if (!isReserved(key)) {
	      proxy(vm, "_data", key);
	    }
	  }
	  // observe data
	  observe(data, true /* asRootData */);
	}
	
	function getData(data, vm) {
	  try {
	    return data.call(vm);
	  } catch (e) {
	    handleError(e, vm, "data()");
	    return {};
	  }
	}
	
	var computedWatcherOptions = { lazy: true };
	
	function initComputed(vm, computed) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');
	  var watchers = vm._computedWatchers = Object.create(null);
	
	  for (var key in computed) {
	    var userDef = computed[key];
	    var getter = typeof userDef === 'function' ? userDef : userDef.get;
	    if (process.env.NODE_ENV !== 'production' && getter == null) {
	      warn("Getter is missing for computed property \"" + key + "\".", vm);
	    }
	    // create internal watcher for the computed property.
	    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
	
	    // component-defined computed properties are already defined on the
	    // component prototype. We only need to define computed properties defined
	    // at instantiation here.
	    if (!(key in vm)) {
	      defineComputed(vm, key, userDef);
	    } else if (process.env.NODE_ENV !== 'production') {
	      if (key in vm.$data) {
	        warn("The computed property \"" + key + "\" is already defined in data.", vm);
	      } else if (vm.$options.props && key in vm.$options.props) {
	        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function defineComputed(target, key, userDef) {
	  if (typeof userDef === 'function') {
	    sharedPropertyDefinition.get = createComputedGetter(key);
	    sharedPropertyDefinition.set = noop;
	  } else {
	    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
	    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
	  }
	  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
	    sharedPropertyDefinition.set = function () {
	      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
	    };
	  }
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function createComputedGetter(key) {
	  return function computedGetter() {
	    var watcher = this._computedWatchers && this._computedWatchers[key];
	    if (watcher) {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    }
	  };
	}
	
	function initMethods(vm, methods) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');
	  var props = vm.$options.props;
	  for (var key in methods) {
	    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods[key] == null) {
	        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
	      }
	      if (props && hasOwn(props, key)) {
	        warn("method \"" + key + "\" has already been defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function initWatch(vm, watch) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');
	  for (var key in watch) {
	    var handler = watch[key];
	    if (Array.isArray(handler)) {
	      for (var i = 0; i < handler.length; i++) {
	        createWatcher(vm, key, handler[i]);
	      }
	    } else {
	      createWatcher(vm, key, handler);
	    }
	  }
	}
	
	function createWatcher(vm, keyOrFn, handler, options) {
	  if (isPlainObject(handler)) {
	    options = handler;
	    handler = handler.handler;
	  }
	  if (typeof handler === 'string') {
	    handler = vm[handler];
	  }
	  return vm.$watch(keyOrFn, handler, options);
	}
	
	function stateMixin(Vue) {
	  // flow somehow has problems with directly declared definition object
	  // when using Object.defineProperty, so we have to procedurally build up
	  // the object here.
	  var dataDef = {};
	  dataDef.get = function () {
	    return this._data;
	  };
	  var propsDef = {};
	  propsDef.get = function () {
	    return this._props;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    dataDef.set = function (newData) {
	      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
	    };
	    propsDef.set = function () {
	      warn("$props is readonly.", this);
	    };
	  }
	  Object.defineProperty(Vue.prototype, '$data', dataDef);
	  Object.defineProperty(Vue.prototype, '$props', propsDef);
	
	  Vue.prototype.$set = set;
	  Vue.prototype.$delete = del;
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    if (isPlainObject(cb)) {
	      return createWatcher(vm, expOrFn, cb, options);
	    }
	    options = options || {};
	    options.user = true;
	    var watcher = new Watcher(vm, expOrFn, cb, options);
	    if (options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	}
	
	/*  */
	
	function initProvide(vm) {
	  var provide = vm.$options.provide;
	  if (provide) {
	    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
	  }
	}
	
	function initInjections(vm) {
	  var result = resolveInject(vm.$options.inject, vm);
	  if (result) {
	    observerState.shouldConvert = false;
	    Object.keys(result).forEach(function (key) {
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        defineReactive$$1(vm, key, result[key], function () {
	          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
	        });
	      } else {
	        defineReactive$$1(vm, key, result[key]);
	      }
	    });
	    observerState.shouldConvert = true;
	  }
	}
	
	function resolveInject(inject, vm) {
	  if (inject) {
	    // inject is :any because flow is not smart enough to figure out cached
	    var result = Object.create(null);
	    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
	
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var provideKey = inject[key];
	      var source = vm;
	      while (source) {
	        if (source._provided && provideKey in source._provided) {
	          result[key] = source._provided[provideKey];
	          break;
	        }
	        source = source.$parent;
	      }
	      if (process.env.NODE_ENV !== 'production' && !source) {
	        warn("Injection \"" + key + "\" not found", vm);
	      }
	    }
	    return result;
	  }
	}
	
	/*  */
	
	function createFunctionalComponent(Ctor, propsData, data, context, children) {
	  var props = {};
	  var propOptions = Ctor.options.props;
	  if (isDef(propOptions)) {
	    for (var key in propOptions) {
	      props[key] = validateProp(key, propOptions, propsData || {});
	    }
	  } else {
	    if (isDef(data.attrs)) {
	      mergeProps(props, data.attrs);
	    }
	    if (isDef(data.props)) {
	      mergeProps(props, data.props);
	    }
	  }
	  // ensure the createElement function in functional components
	  // gets a unique context - this is necessary for correct named slot check
	  var _context = Object.create(context);
	  var h = function h(a, b, c, d) {
	    return createElement(_context, a, b, c, d, true);
	  };
	  var vnode = Ctor.options.render.call(null, h, {
	    data: data,
	    props: props,
	    children: children,
	    parent: context,
	    listeners: data.on || {},
	    injections: resolveInject(Ctor.options.inject, context),
	    slots: function slots() {
	      return resolveSlots(children, context);
	    }
	  });
	  if (vnode instanceof VNode) {
	    vnode.functionalContext = context;
	    vnode.functionalOptions = Ctor.options;
	    if (data.slot) {
	      (vnode.data || (vnode.data = {})).slot = data.slot;
	    }
	  }
	  return vnode;
	}
	
	function mergeProps(to, from) {
	  for (var key in from) {
	    to[camelize(key)] = from[key];
	  }
	}
	
	/*  */
	
	// hooks to be invoked on component VNodes during patch
	var componentVNodeHooks = {
	  init: function init(vnode, hydrating, parentElm, refElm) {
	    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
	      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
	      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	    } else if (vnode.data.keepAlive) {
	      // kept-alive components, treat as a patch
	      var mountedNode = vnode; // work around flow
	      componentVNodeHooks.prepatch(mountedNode, mountedNode);
	    }
	  },
	
	  prepatch: function prepatch(oldVnode, vnode) {
	    var options = vnode.componentOptions;
	    var child = vnode.componentInstance = oldVnode.componentInstance;
	    updateChildComponent(child, options.propsData, // updated props
	    options.listeners, // updated listeners
	    vnode, // new parent vnode
	    options.children // new children
	    );
	  },
	
	  insert: function insert(vnode) {
	    var context = vnode.context;
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isMounted) {
	      componentInstance._isMounted = true;
	      callHook(componentInstance, 'mounted');
	    }
	    if (vnode.data.keepAlive) {
	      if (context._isMounted) {
	        // vue-router#1212
	        // During updates, a kept-alive component's child components may
	        // change, so directly walking the tree here may call activated hooks
	        // on incorrect children. Instead we push them into a queue which will
	        // be processed after the whole patch process ended.
	        queueActivatedComponent(componentInstance);
	      } else {
	        activateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  },
	
	  destroy: function destroy(vnode) {
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isDestroyed) {
	      if (!vnode.data.keepAlive) {
	        componentInstance.$destroy();
	      } else {
	        deactivateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  }
	};
	
	var hooksToMerge = Object.keys(componentVNodeHooks);
	
	function createComponent(Ctor, data, context, children, tag) {
	  if (isUndef(Ctor)) {
	    return;
	  }
	
	  var baseCtor = context.$options._base;
	
	  // plain options object: turn it into a constructor
	  if (isObject(Ctor)) {
	    Ctor = baseCtor.extend(Ctor);
	  }
	
	  // if at this stage it's not a constructor or an async component factory,
	  // reject.
	  if (typeof Ctor !== 'function') {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Invalid Component definition: " + String(Ctor), context);
	    }
	    return;
	  }
	
	  // async component
	  var asyncFactory;
	  if (isUndef(Ctor.cid)) {
	    asyncFactory = Ctor;
	    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
	    if (Ctor === undefined) {
	      // return a placeholder node for async component, which is rendered
	      // as a comment node but preserves all the raw information for the node.
	      // the information will be used for async server-rendering and hydration.
	      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
	    }
	  }
	
	  data = data || {};
	
	  // resolve constructor options in case global mixins are applied after
	  // component constructor creation
	  resolveConstructorOptions(Ctor);
	
	  // transform component v-model data into props & events
	  if (isDef(data.model)) {
	    transformModel(Ctor.options, data);
	  }
	
	  // extract props
	  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
	
	  // functional component
	  if (isTrue(Ctor.options.functional)) {
	    return createFunctionalComponent(Ctor, propsData, data, context, children);
	  }
	
	  // extract listeners, since these needs to be treated as
	  // child component listeners instead of DOM listeners
	  var listeners = data.on;
	  // replace with listeners with .native modifier
	  // so it gets processed during parent component patch.
	  data.on = data.nativeOn;
	
	  if (isTrue(Ctor.options.abstract)) {
	    // abstract components do not keep anything
	    // other than props & listeners & slot
	
	    // work around flow
	    var slot = data.slot;
	    data = {};
	    if (slot) {
	      data.slot = slot;
	    }
	  }
	
	  // merge component management hooks onto the placeholder node
	  mergeHooks(data);
	
	  // return a placeholder vnode
	  var name = Ctor.options.name || tag;
	  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
	  return vnode;
	}
	
	function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
	parent, // activeInstance in lifecycle state
	parentElm, refElm) {
	  var vnodeComponentOptions = vnode.componentOptions;
	  var options = {
	    _isComponent: true,
	    parent: parent,
	    propsData: vnodeComponentOptions.propsData,
	    _componentTag: vnodeComponentOptions.tag,
	    _parentVnode: vnode,
	    _parentListeners: vnodeComponentOptions.listeners,
	    _renderChildren: vnodeComponentOptions.children,
	    _parentElm: parentElm || null,
	    _refElm: refElm || null
	  };
	  // check inline-template render functions
	  var inlineTemplate = vnode.data.inlineTemplate;
	  if (isDef(inlineTemplate)) {
	    options.render = inlineTemplate.render;
	    options.staticRenderFns = inlineTemplate.staticRenderFns;
	  }
	  return new vnodeComponentOptions.Ctor(options);
	}
	
	function mergeHooks(data) {
	  if (!data.hook) {
	    data.hook = {};
	  }
	  for (var i = 0; i < hooksToMerge.length; i++) {
	    var key = hooksToMerge[i];
	    var fromParent = data.hook[key];
	    var ours = componentVNodeHooks[key];
	    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
	  }
	}
	
	function mergeHook$1(one, two) {
	  return function (a, b, c, d) {
	    one(a, b, c, d);
	    two(a, b, c, d);
	  };
	}
	
	// transform component v-model info (value and callback) into
	// prop and event handler respectively.
	function transformModel(options, data) {
	  var prop = options.model && options.model.prop || 'value';
	  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
	  var on = data.on || (data.on = {});
	  if (isDef(on[event])) {
	    on[event] = [data.model.callback].concat(on[event]);
	  } else {
	    on[event] = data.model.callback;
	  }
	}
	
	/*  */
	
	var SIMPLE_NORMALIZE = 1;
	var ALWAYS_NORMALIZE = 2;
	
	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
	  if (Array.isArray(data) || isPrimitive(data)) {
	    normalizationType = children;
	    children = data;
	    data = undefined;
	  }
	  if (isTrue(alwaysNormalize)) {
	    normalizationType = ALWAYS_NORMALIZE;
	  }
	  return _createElement(context, tag, data, children, normalizationType);
	}
	
	function _createElement(context, tag, data, children, normalizationType) {
	  if (isDef(data) && isDef(data.__ob__)) {
	    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
	    return createEmptyVNode();
	  }
	  // object syntax in v-bind
	  if (isDef(data) && isDef(data.is)) {
	    tag = data.is;
	  }
	  if (!tag) {
	    // in case of component :is set to falsy value
	    return createEmptyVNode();
	  }
	  // warn against non-primitive key
	  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
	    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
	  }
	  // support single function children as default scoped slot
	  if (Array.isArray(children) && typeof children[0] === 'function') {
	    data = data || {};
	    data.scopedSlots = { default: children[0] };
	    children.length = 0;
	  }
	  if (normalizationType === ALWAYS_NORMALIZE) {
	    children = normalizeChildren(children);
	  } else if (normalizationType === SIMPLE_NORMALIZE) {
	    children = simpleNormalizeChildren(children);
	  }
	  var vnode, ns;
	  if (typeof tag === 'string') {
	    var Ctor;
	    ns = config.getTagNamespace(tag);
	    if (config.isReservedTag(tag)) {
	      // platform built-in elements
	      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
	    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
	      // component
	      vnode = createComponent(Ctor, data, context, children, tag);
	    } else {
	      // unknown or unlisted namespaced elements
	      // check at runtime because it may get assigned a namespace when its
	      // parent normalizes children
	      vnode = new VNode(tag, data, children, undefined, undefined, context);
	    }
	  } else {
	    // direct component options / constructor
	    vnode = createComponent(tag, data, context, children);
	  }
	  if (isDef(vnode)) {
	    if (ns) {
	      applyNS(vnode, ns);
	    }
	    return vnode;
	  } else {
	    return createEmptyVNode();
	  }
	}
	
	function applyNS(vnode, ns) {
	  vnode.ns = ns;
	  if (vnode.tag === 'foreignObject') {
	    // use default namespace inside foreignObject
	    return;
	  }
	  if (isDef(vnode.children)) {
	    for (var i = 0, l = vnode.children.length; i < l; i++) {
	      var child = vnode.children[i];
	      if (isDef(child.tag) && isUndef(child.ns)) {
	        applyNS(child, ns);
	      }
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering v-for lists.
	 */
	function renderList(val, render) {
	  var ret, i, l, keys, key;
	  if (Array.isArray(val) || typeof val === 'string') {
	    ret = new Array(val.length);
	    for (i = 0, l = val.length; i < l; i++) {
	      ret[i] = render(val[i], i);
	    }
	  } else if (typeof val === 'number') {
	    ret = new Array(val);
	    for (i = 0; i < val; i++) {
	      ret[i] = render(i + 1, i);
	    }
	  } else if (isObject(val)) {
	    keys = Object.keys(val);
	    ret = new Array(keys.length);
	    for (i = 0, l = keys.length; i < l; i++) {
	      key = keys[i];
	      ret[i] = render(val[key], key, i);
	    }
	  }
	  if (isDef(ret)) {
	    ret._isVList = true;
	  }
	  return ret;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering <slot>
	 */
	function renderSlot(name, fallback, props, bindObject) {
	  var scopedSlotFn = this.$scopedSlots[name];
	  if (scopedSlotFn) {
	    // scoped slot
	    props = props || {};
	    if (bindObject) {
	      props = extend(extend({}, bindObject), props);
	    }
	    return scopedSlotFn(props) || fallback;
	  } else {
	    var slotNodes = this.$slots[name];
	    // warn duplicate slot usage
	    if (slotNodes && process.env.NODE_ENV !== 'production') {
	      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
	      slotNodes._rendered = true;
	    }
	    return slotNodes || fallback;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving filters
	 */
	function resolveFilter(id) {
	  return resolveAsset(this.$options, 'filters', id, true) || identity;
	}
	
	/*  */
	
	/**
	 * Runtime helper for checking keyCodes from config.
	 */
	function checkKeyCodes(eventKeyCode, key, builtInAlias) {
	  var keyCodes = config.keyCodes[key] || builtInAlias;
	  if (Array.isArray(keyCodes)) {
	    return keyCodes.indexOf(eventKeyCode) === -1;
	  } else {
	    return keyCodes !== eventKeyCode;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for merging v-bind="object" into a VNode's data.
	 */
	function bindObjectProps(data, tag, value, asProp, isSync) {
	  if (value) {
	    if (!isObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
	    } else {
	      if (Array.isArray(value)) {
	        value = toObject(value);
	      }
	      var hash;
	      var loop = function loop(key) {
	        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
	          hash = data;
	        } else {
	          var type = data.attrs && data.attrs.type;
	          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
	        }
	        if (!(key in hash)) {
	          hash[key] = value[key];
	
	          if (isSync) {
	            var on = data.on || (data.on = {});
	            on["update:" + key] = function ($event) {
	              value[key] = $event;
	            };
	          }
	        }
	      };
	
	      for (var key in value) {
	        loop(key);
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering static trees.
	 */
	function renderStatic(index, isInFor) {
	  var tree = this._staticTrees[index];
	  // if has already-rendered static tree and not inside v-for,
	  // we can reuse the same tree by doing a shallow clone.
	  if (tree && !isInFor) {
	    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
	  }
	  // otherwise, render a fresh tree.
	  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
	  markStatic(tree, "__static__" + index, false);
	  return tree;
	}
	
	/**
	 * Runtime helper for v-once.
	 * Effectively it means marking the node as static with a unique key.
	 */
	function markOnce(tree, index, key) {
	  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
	  return tree;
	}
	
	function markStatic(tree, key, isOnce) {
	  if (Array.isArray(tree)) {
	    for (var i = 0; i < tree.length; i++) {
	      if (tree[i] && typeof tree[i] !== 'string') {
	        markStaticNode(tree[i], key + "_" + i, isOnce);
	      }
	    }
	  } else {
	    markStaticNode(tree, key, isOnce);
	  }
	}
	
	function markStaticNode(node, key, isOnce) {
	  node.isStatic = true;
	  node.key = key;
	  node.isOnce = isOnce;
	}
	
	/*  */
	
	function bindObjectListeners(data, value) {
	  if (value) {
	    if (!isPlainObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
	    } else {
	      var on = data.on = data.on ? extend({}, data.on) : {};
	      for (var key in value) {
	        var existing = on[key];
	        var ours = value[key];
	        on[key] = existing ? [].concat(ours, existing) : ours;
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	function initRender(vm) {
	  vm._vnode = null; // the root of the child tree
	  vm._staticTrees = null;
	  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
	  var renderContext = parentVnode && parentVnode.context;
	  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
	  vm.$scopedSlots = emptyObject;
	  // bind the createElement fn to this instance
	  // so that we get proper render context inside it.
	  // args order: tag, data, children, normalizationType, alwaysNormalize
	  // internal version is used by render functions compiled from templates
	  vm._c = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, false);
	  };
	  // normalization is always applied for the public version, used in
	  // user-written render functions.
	  vm.$createElement = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, true);
	  };
	
	  // $attrs & $listeners are exposed for easier HOC creation.
	  // they need to be reactive so that HOCs using them are always updated
	  var parentData = parentVnode && parentVnode.data;
	  /* istanbul ignore else */
	  if (process.env.NODE_ENV !== 'production') {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
	      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
	    }, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
	      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
	    }, true);
	  } else {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);
	  }
	}
	
	function renderMixin(Vue) {
	  Vue.prototype.$nextTick = function (fn) {
	    return nextTick(fn, this);
	  };
	
	  Vue.prototype._render = function () {
	    var vm = this;
	    var ref = vm.$options;
	    var render = ref.render;
	    var staticRenderFns = ref.staticRenderFns;
	    var _parentVnode = ref._parentVnode;
	
	    if (vm._isMounted) {
	      // clone slot nodes on re-renders
	      for (var key in vm.$slots) {
	        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
	      }
	    }
	
	    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;
	
	    if (staticRenderFns && !vm._staticTrees) {
	      vm._staticTrees = [];
	    }
	    // set parent vnode. this allows render functions to have access
	    // to the data on the placeholder node.
	    vm.$vnode = _parentVnode;
	    // render self
	    var vnode;
	    try {
	      vnode = render.call(vm._renderProxy, vm.$createElement);
	    } catch (e) {
	      handleError(e, vm, "render function");
	      // return error render result,
	      // or previous vnode to prevent render error causing blank component
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
	      } else {
	        vnode = vm._vnode;
	      }
	    }
	    // return empty vnode in case the render function errored out
	    if (!(vnode instanceof VNode)) {
	      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
	        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
	      }
	      vnode = createEmptyVNode();
	    }
	    // set parent
	    vnode.parent = _parentVnode;
	    return vnode;
	  };
	
	  // internal render helpers.
	  // these are exposed on the instance prototype to reduce generated render
	  // code size.
	  Vue.prototype._o = markOnce;
	  Vue.prototype._n = toNumber;
	  Vue.prototype._s = toString;
	  Vue.prototype._l = renderList;
	  Vue.prototype._t = renderSlot;
	  Vue.prototype._q = looseEqual;
	  Vue.prototype._i = looseIndexOf;
	  Vue.prototype._m = renderStatic;
	  Vue.prototype._f = resolveFilter;
	  Vue.prototype._k = checkKeyCodes;
	  Vue.prototype._b = bindObjectProps;
	  Vue.prototype._v = createTextVNode;
	  Vue.prototype._e = createEmptyVNode;
	  Vue.prototype._u = resolveScopedSlots;
	  Vue.prototype._g = bindObjectListeners;
	}
	
	/*  */
	
	var uid$1 = 0;
	
	function initMixin(Vue) {
	  Vue.prototype._init = function (options) {
	    var vm = this;
	    // a uid
	    vm._uid = uid$1++;
	
	    var startTag, endTag;
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      startTag = "vue-perf-init:" + vm._uid;
	      endTag = "vue-perf-end:" + vm._uid;
	      mark(startTag);
	    }
	
	    // a flag to avoid this being observed
	    vm._isVue = true;
	    // merge options
	    if (options && options._isComponent) {
	      // optimize internal component instantiation
	      // since dynamic options merging is pretty slow, and none of the
	      // internal component options needs special treatment.
	      initInternalComponent(vm, options);
	    } else {
	      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
	    }
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      initProxy(vm);
	    } else {
	      vm._renderProxy = vm;
	    }
	    // expose real self
	    vm._self = vm;
	    initLifecycle(vm);
	    initEvents(vm);
	    initRender(vm);
	    callHook(vm, 'beforeCreate');
	    initInjections(vm); // resolve injections before data/props
	    initState(vm);
	    initProvide(vm); // resolve provide after data/props
	    callHook(vm, 'created');
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      vm._name = formatComponentName(vm, false);
	      mark(endTag);
	      measure(vm._name + " init", startTag, endTag);
	    }
	
	    if (vm.$options.el) {
	      vm.$mount(vm.$options.el);
	    }
	  };
	}
	
	function initInternalComponent(vm, options) {
	  var opts = vm.$options = Object.create(vm.constructor.options);
	  // doing this because it's faster than dynamic enumeration.
	  opts.parent = options.parent;
	  opts.propsData = options.propsData;
	  opts._parentVnode = options._parentVnode;
	  opts._parentListeners = options._parentListeners;
	  opts._renderChildren = options._renderChildren;
	  opts._componentTag = options._componentTag;
	  opts._parentElm = options._parentElm;
	  opts._refElm = options._refElm;
	  if (options.render) {
	    opts.render = options.render;
	    opts.staticRenderFns = options.staticRenderFns;
	  }
	}
	
	function resolveConstructorOptions(Ctor) {
	  var options = Ctor.options;
	  if (Ctor.super) {
	    var superOptions = resolveConstructorOptions(Ctor.super);
	    var cachedSuperOptions = Ctor.superOptions;
	    if (superOptions !== cachedSuperOptions) {
	      // super option changed,
	      // need to resolve new options.
	      Ctor.superOptions = superOptions;
	      // check if there are any late-modified/attached options (#4976)
	      var modifiedOptions = resolveModifiedOptions(Ctor);
	      // update base extend options
	      if (modifiedOptions) {
	        extend(Ctor.extendOptions, modifiedOptions);
	      }
	      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
	      if (options.name) {
	        options.components[options.name] = Ctor;
	      }
	    }
	  }
	  return options;
	}
	
	function resolveModifiedOptions(Ctor) {
	  var modified;
	  var latest = Ctor.options;
	  var extended = Ctor.extendOptions;
	  var sealed = Ctor.sealedOptions;
	  for (var key in latest) {
	    if (latest[key] !== sealed[key]) {
	      if (!modified) {
	        modified = {};
	      }
	      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
	    }
	  }
	  return modified;
	}
	
	function dedupe(latest, extended, sealed) {
	  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
	  // between merges
	  if (Array.isArray(latest)) {
	    var res = [];
	    sealed = Array.isArray(sealed) ? sealed : [sealed];
	    extended = Array.isArray(extended) ? extended : [extended];
	    for (var i = 0; i < latest.length; i++) {
	      // push original options and not sealed options to exclude duplicated options
	      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
	        res.push(latest[i]);
	      }
	    }
	    return res;
	  } else {
	    return latest;
	  }
	}
	
	function Vue$3(options) {
	  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
	    warn('Vue is a constructor and should be called with the `new` keyword');
	  }
	  this._init(options);
	}
	
	initMixin(Vue$3);
	stateMixin(Vue$3);
	eventsMixin(Vue$3);
	lifecycleMixin(Vue$3);
	renderMixin(Vue$3);
	
	/*  */
	
	function initUse(Vue) {
	  Vue.use = function (plugin) {
	    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
	    if (installedPlugins.indexOf(plugin) > -1) {
	      return this;
	    }
	
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else if (typeof plugin === 'function') {
	      plugin.apply(null, args);
	    }
	    installedPlugins.push(plugin);
	    return this;
	  };
	}
	
	/*  */
	
	function initMixin$1(Vue) {
	  Vue.mixin = function (mixin) {
	    this.options = mergeOptions(this.options, mixin);
	    return this;
	  };
	}
	
	/*  */
	
	function initExtend(Vue) {
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   */
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var SuperId = Super.cid;
	    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
	    if (cachedCtors[SuperId]) {
	      return cachedCtors[SuperId];
	    }
	
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
	      }
	    }
	
	    var Sub = function VueComponent(options) {
	      this._init(options);
	    };
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	
	    // For props and computed properties, we define the proxy getters on
	    // the Vue instances at extension time, on the extended prototype. This
	    // avoids Object.defineProperty calls for each instance created.
	    if (Sub.options.props) {
	      initProps$1(Sub);
	    }
	    if (Sub.options.computed) {
	      initComputed$1(Sub);
	    }
	
	    // allow further extension/mixin/plugin usage
	    Sub.extend = Super.extend;
	    Sub.mixin = Super.mixin;
	    Sub.use = Super.use;
	
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    ASSET_TYPES.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	
	    // keep a reference to the super options at extension time.
	    // later at instantiation we can check if Super's options have
	    // been updated.
	    Sub.superOptions = Super.options;
	    Sub.extendOptions = extendOptions;
	    Sub.sealedOptions = extend({}, Sub.options);
	
	    // cache constructor
	    cachedCtors[SuperId] = Sub;
	    return Sub;
	  };
	}
	
	function initProps$1(Comp) {
	  var props = Comp.options.props;
	  for (var key in props) {
	    proxy(Comp.prototype, "_props", key);
	  }
	}
	
	function initComputed$1(Comp) {
	  var computed = Comp.options.computed;
	  for (var key in computed) {
	    defineComputed(Comp.prototype, key, computed[key]);
	  }
	}
	
	/*  */
	
	function initAssetRegisters(Vue) {
	  /**
	   * Create asset registration methods.
	   */
	  ASSET_TYPES.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && config.isReservedTag(id)) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = definition.name || id;
	          definition = this.options._base.extend(definition);
	        }
	        if (type === 'directive' && typeof definition === 'function') {
	          definition = { bind: definition, update: definition };
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	}
	
	/*  */
	
	var patternTypes = [String, RegExp, Array];
	
	function getComponentName(opts) {
	  return opts && (opts.Ctor.options.name || opts.tag);
	}
	
	function matches(pattern, name) {
	  if (Array.isArray(pattern)) {
	    return pattern.indexOf(name) > -1;
	  } else if (typeof pattern === 'string') {
	    return pattern.split(',').indexOf(name) > -1;
	  } else if (isRegExp(pattern)) {
	    return pattern.test(name);
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	function pruneCache(cache, current, filter) {
	  for (var key in cache) {
	    var cachedNode = cache[key];
	    if (cachedNode) {
	      var name = getComponentName(cachedNode.componentOptions);
	      if (name && !filter(name)) {
	        if (cachedNode !== current) {
	          pruneCacheEntry(cachedNode);
	        }
	        cache[key] = null;
	      }
	    }
	  }
	}
	
	function pruneCacheEntry(vnode) {
	  if (vnode) {
	    vnode.componentInstance.$destroy();
	  }
	}
	
	var KeepAlive = {
	  name: 'keep-alive',
	  abstract: true,
	
	  props: {
	    include: patternTypes,
	    exclude: patternTypes
	  },
	
	  created: function created() {
	    this.cache = Object.create(null);
	  },
	
	  destroyed: function destroyed() {
	    var this$1 = this;
	
	    for (var key in this$1.cache) {
	      pruneCacheEntry(this$1.cache[key]);
	    }
	  },
	
	  watch: {
	    include: function include(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return matches(val, name);
	      });
	    },
	    exclude: function exclude(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return !matches(val, name);
	      });
	    }
	  },
	
	  render: function render() {
	    var vnode = getFirstComponentChild(this.$slots.default);
	    var componentOptions = vnode && vnode.componentOptions;
	    if (componentOptions) {
	      // check pattern
	      var name = getComponentName(componentOptions);
	      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
	        return vnode;
	      }
	      var key = vnode.key == null
	      // same constructor may get registered as different local components
	      // so cid alone is not enough (#3269)
	      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
	      if (this.cache[key]) {
	        vnode.componentInstance = this.cache[key].componentInstance;
	      } else {
	        this.cache[key] = vnode;
	      }
	      vnode.data.keepAlive = true;
	    }
	    return vnode;
	  }
	};
	
	var builtInComponents = {
	  KeepAlive: KeepAlive
	};
	
	/*  */
	
	function initGlobalAPI(Vue) {
	  // config
	  var configDef = {};
	  configDef.get = function () {
	    return config;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    configDef.set = function () {
	      warn('Do not replace the Vue.config object, set individual fields instead.');
	    };
	  }
	  Object.defineProperty(Vue, 'config', configDef);
	
	  // exposed util methods.
	  // NOTE: these are not considered part of the public API - avoid relying on
	  // them unless you are aware of the risk.
	  Vue.util = {
	    warn: warn,
	    extend: extend,
	    mergeOptions: mergeOptions,
	    defineReactive: defineReactive$$1
	  };
	
	  Vue.set = set;
	  Vue.delete = del;
	  Vue.nextTick = nextTick;
	
	  Vue.options = Object.create(null);
	  ASSET_TYPES.forEach(function (type) {
	    Vue.options[type + 's'] = Object.create(null);
	  });
	
	  // this is used to identify the "base" constructor to extend all plain-object
	  // components with in Weex's multi-instance scenarios.
	  Vue.options._base = Vue;
	
	  extend(Vue.options.components, builtInComponents);
	
	  initUse(Vue);
	  initMixin$1(Vue);
	  initExtend(Vue);
	  initAssetRegisters(Vue);
	}
	
	initGlobalAPI(Vue$3);
	
	Object.defineProperty(Vue$3.prototype, '$isServer', {
	  get: isServerRendering
	});
	
	Object.defineProperty(Vue$3.prototype, '$ssrContext', {
	  get: function get() {
	    /* istanbul ignore next */
	    return this.$vnode && this.$vnode.ssrContext;
	  }
	});
	
	Vue$3.version = '2.4.2';
	
	/*  */
	
	// these are reserved for web because they are directly compiled away
	// during template compilation
	var isReservedAttr = makeMap('style,class');
	
	// attributes that should be using props for binding
	var acceptValue = makeMap('input,textarea,option,select');
	var mustUseProp = function mustUseProp(tag, type, attr) {
	  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
	};
	
	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
	
	var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
	
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	
	var isXlink = function isXlink(name) {
	  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
	};
	
	var getXlinkProp = function getXlinkProp(name) {
	  return isXlink(name) ? name.slice(6, name.length) : '';
	};
	
	var isFalsyAttrValue = function isFalsyAttrValue(val) {
	  return val == null || val === false;
	};
	
	/*  */
	
	function genClassForVnode(vnode) {
	  var data = vnode.data;
	  var parentNode = vnode;
	  var childNode = vnode;
	  while (isDef(childNode.componentInstance)) {
	    childNode = childNode.componentInstance._vnode;
	    if (childNode.data) {
	      data = mergeClassData(childNode.data, data);
	    }
	  }
	  while (isDef(parentNode = parentNode.parent)) {
	    if (parentNode.data) {
	      data = mergeClassData(data, parentNode.data);
	    }
	  }
	  return renderClass(data.staticClass, data.class);
	}
	
	function mergeClassData(child, parent) {
	  return {
	    staticClass: concat(child.staticClass, parent.staticClass),
	    class: isDef(child.class) ? [child.class, parent.class] : parent.class
	  };
	}
	
	function renderClass(staticClass, dynamicClass) {
	  if (isDef(staticClass) || isDef(dynamicClass)) {
	    return concat(staticClass, stringifyClass(dynamicClass));
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function concat(a, b) {
	  return a ? b ? a + ' ' + b : a : b || '';
	}
	
	function stringifyClass(value) {
	  if (Array.isArray(value)) {
	    return stringifyArray(value);
	  }
	  if (isObject(value)) {
	    return stringifyObject(value);
	  }
	  if (typeof value === 'string') {
	    return value;
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function stringifyArray(value) {
	  var res = '';
	  var stringified;
	  for (var i = 0, l = value.length; i < l; i++) {
	    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
	      if (res) {
	        res += ' ';
	      }
	      res += stringified;
	    }
	  }
	  return res;
	}
	
	function stringifyObject(value) {
	  var res = '';
	  for (var key in value) {
	    if (value[key]) {
	      if (res) {
	        res += ' ';
	      }
	      res += key;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var namespaceMap = {
	  svg: 'http://www.w3.org/2000/svg',
	  math: 'http://www.w3.org/1998/Math/MathML'
	};
	
	var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');
	
	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
	
	var isPreTag = function isPreTag(tag) {
	  return tag === 'pre';
	};
	
	var isReservedTag = function isReservedTag(tag) {
	  return isHTMLTag(tag) || isSVG(tag);
	};
	
	function getTagNamespace(tag) {
	  if (isSVG(tag)) {
	    return 'svg';
	  }
	  // basic support for MathML
	  // note it doesn't support other MathML elements being component roots
	  if (tag === 'math') {
	    return 'math';
	  }
	}
	
	var unknownElementCache = Object.create(null);
	function isUnknownElement(tag) {
	  /* istanbul ignore if */
	  if (!inBrowser) {
	    return true;
	  }
	  if (isReservedTag(tag)) {
	    return false;
	  }
	  tag = tag.toLowerCase();
	  /* istanbul ignore if */
	  if (unknownElementCache[tag] != null) {
	    return unknownElementCache[tag];
	  }
	  var el = document.createElement(tag);
	  if (tag.indexOf('-') > -1) {
	    // http://stackoverflow.com/a/28210364/1070244
	    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	  } else {
	    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
	  }
	}
	
	/*  */
	
	/**
	 * Query an element selector if it's not an element already.
	 */
	function query(el) {
	  if (typeof el === 'string') {
	    var selected = document.querySelector(el);
	    if (!selected) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
	      return document.createElement('div');
	    }
	    return selected;
	  } else {
	    return el;
	  }
	}
	
	/*  */
	
	function createElement$1(tagName, vnode) {
	  var elm = document.createElement(tagName);
	  if (tagName !== 'select') {
	    return elm;
	  }
	  // false or null will remove the attribute but undefined will not
	  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
	    elm.setAttribute('multiple', 'multiple');
	  }
	  return elm;
	}
	
	function createElementNS(namespace, tagName) {
	  return document.createElementNS(namespaceMap[namespace], tagName);
	}
	
	function createTextNode(text) {
	  return document.createTextNode(text);
	}
	
	function createComment(text) {
	  return document.createComment(text);
	}
	
	function insertBefore(parentNode, newNode, referenceNode) {
	  parentNode.insertBefore(newNode, referenceNode);
	}
	
	function removeChild(node, child) {
	  node.removeChild(child);
	}
	
	function appendChild(node, child) {
	  node.appendChild(child);
	}
	
	function parentNode(node) {
	  return node.parentNode;
	}
	
	function nextSibling(node) {
	  return node.nextSibling;
	}
	
	function tagName(node) {
	  return node.tagName;
	}
	
	function setTextContent(node, text) {
	  node.textContent = text;
	}
	
	function setAttribute(node, key, val) {
	  node.setAttribute(key, val);
	}
	
	var nodeOps = Object.freeze({
	  createElement: createElement$1,
	  createElementNS: createElementNS,
	  createTextNode: createTextNode,
	  createComment: createComment,
	  insertBefore: insertBefore,
	  removeChild: removeChild,
	  appendChild: appendChild,
	  parentNode: parentNode,
	  nextSibling: nextSibling,
	  tagName: tagName,
	  setTextContent: setTextContent,
	  setAttribute: setAttribute
	});
	
	/*  */
	
	var ref = {
	  create: function create(_, vnode) {
	    registerRef(vnode);
	  },
	  update: function update(oldVnode, vnode) {
	    if (oldVnode.data.ref !== vnode.data.ref) {
	      registerRef(oldVnode, true);
	      registerRef(vnode);
	    }
	  },
	  destroy: function destroy(vnode) {
	    registerRef(vnode, true);
	  }
	};
	
	function registerRef(vnode, isRemoval) {
	  var key = vnode.data.ref;
	  if (!key) {
	    return;
	  }
	
	  var vm = vnode.context;
	  var ref = vnode.componentInstance || vnode.elm;
	  var refs = vm.$refs;
	  if (isRemoval) {
	    if (Array.isArray(refs[key])) {
	      remove(refs[key], ref);
	    } else if (refs[key] === ref) {
	      refs[key] = undefined;
	    }
	  } else {
	    if (vnode.data.refInFor) {
	      if (!Array.isArray(refs[key])) {
	        refs[key] = [ref];
	      } else if (refs[key].indexOf(ref) < 0) {
	        // $flow-disable-line
	        refs[key].push(ref);
	      }
	    } else {
	      refs[key] = ref;
	    }
	  }
	}
	
	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *
	
	/*
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */
	
	var emptyNode = new VNode('', {}, []);
	
	var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
	
	function sameVnode(a, b) {
	  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
	}
	
	// Some browsers do not support dynamically changing type for <input>
	// so they need to be treated as different nodes
	function sameInputType(a, b) {
	  if (a.tag !== 'input') {
	    return true;
	  }
	  var i;
	  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
	  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
	  return typeA === typeB;
	}
	
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, key;
	  var map = {};
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) {
	      map[key] = i;
	    }
	  }
	  return map;
	}
	
	function createPatchFunction(backend) {
	  var i, j;
	  var cbs = {};
	
	  var modules = backend.modules;
	  var nodeOps = backend.nodeOps;
	
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (isDef(modules[j][hooks[i]])) {
	        cbs[hooks[i]].push(modules[j][hooks[i]]);
	      }
	    }
	  }
	
	  function emptyNodeAt(elm) {
	    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
	  }
	
	  function createRmCb(childElm, listeners) {
	    function remove$$1() {
	      if (--remove$$1.listeners === 0) {
	        removeNode(childElm);
	      }
	    }
	    remove$$1.listeners = listeners;
	    return remove$$1;
	  }
	
	  function removeNode(el) {
	    var parent = nodeOps.parentNode(el);
	    // element may have already been removed due to v-html / v-text
	    if (isDef(parent)) {
	      nodeOps.removeChild(parent, el);
	    }
	  }
	
	  var inPre = 0;
	  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
	    vnode.isRootInsert = !nested; // for transition enter check
	    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	      return;
	    }
	
	    var data = vnode.data;
	    var children = vnode.children;
	    var tag = vnode.tag;
	    if (isDef(tag)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (data && data.pre) {
	          inPre++;
	        }
	        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
	        }
	      }
	      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
	      setScope(vnode);
	
	      /* istanbul ignore if */
	      {
	        createChildren(vnode, children, insertedVnodeQueue);
	        if (isDef(data)) {
	          invokeCreateHooks(vnode, insertedVnodeQueue);
	        }
	        insert(parentElm, vnode.elm, refElm);
	      }
	
	      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
	        inPre--;
	      }
	    } else if (isTrue(vnode.isComment)) {
	      vnode.elm = nodeOps.createComment(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    } else {
	      vnode.elm = nodeOps.createTextNode(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    }
	  }
	
	  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i = vnode.data;
	    if (isDef(i)) {
	      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
	      if (isDef(i = i.hook) && isDef(i = i.init)) {
	        i(vnode, false /* hydrating */, parentElm, refElm);
	      }
	      // after calling the init hook, if the vnode is a child component
	      // it should've created a child instance and mounted it. the child
	      // component also has set the placeholder vnode's elm.
	      // in that case we can just return the element and be done.
	      if (isDef(vnode.componentInstance)) {
	        initComponent(vnode, insertedVnodeQueue);
	        if (isTrue(isReactivated)) {
	          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
	        }
	        return true;
	      }
	    }
	  }
	
	  function initComponent(vnode, insertedVnodeQueue) {
	    if (isDef(vnode.data.pendingInsert)) {
	      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	      vnode.data.pendingInsert = null;
	    }
	    vnode.elm = vnode.componentInstance.$el;
	    if (isPatchable(vnode)) {
	      invokeCreateHooks(vnode, insertedVnodeQueue);
	      setScope(vnode);
	    } else {
	      // empty component root.
	      // skip all element-related modules except for ref (#3455)
	      registerRef(vnode);
	      // make sure to invoke the insert hook
	      insertedVnodeQueue.push(vnode);
	    }
	  }
	
	  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i;
	    // hack for #4339: a reactivated component with inner transition
	    // does not trigger because the inner node's created hooks are not called
	    // again. It's not ideal to involve module-specific logic in here but
	    // there doesn't seem to be a better way to do it.
	    var innerNode = vnode;
	    while (innerNode.componentInstance) {
	      innerNode = innerNode.componentInstance._vnode;
	      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
	        for (i = 0; i < cbs.activate.length; ++i) {
	          cbs.activate[i](emptyNode, innerNode);
	        }
	        insertedVnodeQueue.push(innerNode);
	        break;
	      }
	    }
	    // unlike a newly created component,
	    // a reactivated keep-alive component doesn't insert itself
	    insert(parentElm, vnode.elm, refElm);
	  }
	
	  function insert(parent, elm, ref$$1) {
	    if (isDef(parent)) {
	      if (isDef(ref$$1)) {
	        if (ref$$1.parentNode === parent) {
	          nodeOps.insertBefore(parent, elm, ref$$1);
	        }
	      } else {
	        nodeOps.appendChild(parent, elm);
	      }
	    }
	  }
	
	  function createChildren(vnode, children, insertedVnodeQueue) {
	    if (Array.isArray(children)) {
	      for (var i = 0; i < children.length; ++i) {
	        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
	      }
	    } else if (isPrimitive(vnode.text)) {
	      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
	    }
	  }
	
	  function isPatchable(vnode) {
	    while (vnode.componentInstance) {
	      vnode = vnode.componentInstance._vnode;
	    }
	    return isDef(vnode.tag);
	  }
	
	  function invokeCreateHooks(vnode, insertedVnodeQueue) {
	    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
	      cbs.create[i$1](emptyNode, vnode);
	    }
	    i = vnode.data.hook; // Reuse variable
	    if (isDef(i)) {
	      if (isDef(i.create)) {
	        i.create(emptyNode, vnode);
	      }
	      if (isDef(i.insert)) {
	        insertedVnodeQueue.push(vnode);
	      }
	    }
	  }
	
	  // set scope id attribute for scoped CSS.
	  // this is implemented as a special case to avoid the overhead
	  // of going through the normal attribute patching process.
	  function setScope(vnode) {
	    var i;
	    var ancestor = vnode;
	    while (ancestor) {
	      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
	        nodeOps.setAttribute(vnode.elm, i, '');
	      }
	      ancestor = ancestor.parent;
	    }
	    // for slot content they should also get the scopeId from the host instance.
	    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	  }
	
	  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
	    }
	  }
	
	  function invokeDestroyHook(vnode) {
	    var i, j;
	    var data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
	        i(vnode);
	      }
	      for (i = 0; i < cbs.destroy.length; ++i) {
	        cbs.destroy[i](vnode);
	      }
	    }
	    if (isDef(i = vnode.children)) {
	      for (j = 0; j < vnode.children.length; ++j) {
	        invokeDestroyHook(vnode.children[j]);
	      }
	    }
	  }
	
	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.tag)) {
	          removeAndInvokeRemoveHook(ch);
	          invokeDestroyHook(ch);
	        } else {
	          // Text node
	          removeNode(ch.elm);
	        }
	      }
	    }
	  }
	
	  function removeAndInvokeRemoveHook(vnode, rm) {
	    if (isDef(rm) || isDef(vnode.data)) {
	      var i;
	      var listeners = cbs.remove.length + 1;
	      if (isDef(rm)) {
	        // we have a recursively passed down rm callback
	        // increase the listeners count
	        rm.listeners += listeners;
	      } else {
	        // directly removing
	        rm = createRmCb(vnode.elm, listeners);
	      }
	      // recursively invoke hooks on child component root node
	      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
	        removeAndInvokeRemoveHook(i, rm);
	      }
	      for (i = 0; i < cbs.remove.length; ++i) {
	        cbs.remove[i](vnode, rm);
	      }
	      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
	        i(vnode, rm);
	      } else {
	        rm();
	      }
	    } else {
	      removeNode(vnode.elm);
	    }
	  }
	
	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	    var oldStartIdx = 0;
	    var newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, refElm;
	
	    // removeOnly is a special flag used only by <transition-group>
	    // to ensure removed elements stay in correct relative positions
	    // during leaving transitions
	    var canMove = !removeOnly;
	
	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) {
	        // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) {
	        // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) {
	          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        }
	        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
	        if (isUndef(idxInOld)) {
	          // New element
	          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
	            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
	          }
	          if (sameVnode(elmToMove, newStartVnode)) {
	            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	            oldCh[idxInOld] = undefined;
	            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          } else {
	            // same key but different element. treat as new element
	            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          }
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }
	
	  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
	    if (oldVnode === vnode) {
	      return;
	    }
	
	    var elm = vnode.elm = oldVnode.elm;
	
	    if (isTrue(oldVnode.isAsyncPlaceholder)) {
	      if (isDef(vnode.asyncFactory.resolved)) {
	        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
	      } else {
	        vnode.isAsyncPlaceholder = true;
	      }
	      return;
	    }
	
	    // reuse element for static trees.
	    // note we only do this if the vnode is cloned -
	    // if the new node is not cloned it means the render functions have been
	    // reset by the hot-reload-api and we need to do a proper re-render.
	    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
	      vnode.componentInstance = oldVnode.componentInstance;
	      return;
	    }
	
	    var i;
	    var data = vnode.data;
	    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
	      i(oldVnode, vnode);
	    }
	
	    var oldCh = oldVnode.children;
	    var ch = vnode.children;
	    if (isDef(data) && isPatchable(vnode)) {
	      for (i = 0; i < cbs.update.length; ++i) {
	        cbs.update[i](oldVnode, vnode);
	      }
	      if (isDef(i = data.hook) && isDef(i = i.update)) {
	        i(oldVnode, vnode);
	      }
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) {
	          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
	        }
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) {
	          nodeOps.setTextContent(elm, '');
	        }
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        nodeOps.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      nodeOps.setTextContent(elm, vnode.text);
	    }
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
	        i(oldVnode, vnode);
	      }
	    }
	  }
	
	  function invokeInsertHook(vnode, queue, initial) {
	    // delay insert hooks for component root nodes, invoke them after the
	    // element is really inserted
	    if (isTrue(initial) && isDef(vnode.parent)) {
	      vnode.parent.data.pendingInsert = queue;
	    } else {
	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].data.hook.insert(queue[i]);
	      }
	    }
	  }
	
	  var bailed = false;
	  // list of modules that can skip create hook during hydration because they
	  // are already rendered on the client or has no need for initialization
	  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
	
	  // Note: this is a browser-only function so we can assume elms are DOM nodes.
	  function hydrate(elm, vnode, insertedVnodeQueue) {
	    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
	      vnode.elm = elm;
	      vnode.isAsyncPlaceholder = true;
	      return true;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (!assertNodeMatch(elm, vnode)) {
	        return false;
	      }
	    }
	    vnode.elm = elm;
	    var tag = vnode.tag;
	    var data = vnode.data;
	    var children = vnode.children;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) {
	        i(vnode, true /* hydrating */);
	      }
	      if (isDef(i = vnode.componentInstance)) {
	        // child component. it should have hydrated its own tree.
	        initComponent(vnode, insertedVnodeQueue);
	        return true;
	      }
	    }
	    if (isDef(tag)) {
	      if (isDef(children)) {
	        // empty element, allow client to pick up and populate children
	        if (!elm.hasChildNodes()) {
	          createChildren(vnode, children, insertedVnodeQueue);
	        } else {
	          var childrenMatch = true;
	          var childNode = elm.firstChild;
	          for (var i$1 = 0; i$1 < children.length; i$1++) {
	            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
	              childrenMatch = false;
	              break;
	            }
	            childNode = childNode.nextSibling;
	          }
	          // if childNode is not null, it means the actual childNodes list is
	          // longer than the virtual children list.
	          if (!childrenMatch || childNode) {
	            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
	              bailed = true;
	              console.warn('Parent: ', elm);
	              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
	            }
	            return false;
	          }
	        }
	      }
	      if (isDef(data)) {
	        for (var key in data) {
	          if (!isRenderedModule(key)) {
	            invokeCreateHooks(vnode, insertedVnodeQueue);
	            break;
	          }
	        }
	      }
	    } else if (elm.data !== vnode.text) {
	      elm.data = vnode.text;
	    }
	    return true;
	  }
	
	  function assertNodeMatch(node, vnode) {
	    if (isDef(vnode.tag)) {
	      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
	    } else {
	      return node.nodeType === (vnode.isComment ? 8 : 3);
	    }
	  }
	
	  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
	    if (isUndef(vnode)) {
	      if (isDef(oldVnode)) {
	        invokeDestroyHook(oldVnode);
	      }
	      return;
	    }
	
	    var isInitialPatch = false;
	    var insertedVnodeQueue = [];
	
	    if (isUndef(oldVnode)) {
	      // empty mount (likely as component), create new root element
	      isInitialPatch = true;
	      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
	    } else {
	      var isRealElement = isDef(oldVnode.nodeType);
	      if (!isRealElement && sameVnode(oldVnode, vnode)) {
	        // patch existing root node
	        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
	      } else {
	        if (isRealElement) {
	          // mounting to a real element
	          // check if this is server-rendered content and if we can perform
	          // a successful hydration.
	          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
	            oldVnode.removeAttribute(SSR_ATTR);
	            hydrating = true;
	          }
	          if (isTrue(hydrating)) {
	            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	              invokeInsertHook(vnode, insertedVnodeQueue, true);
	              return oldVnode;
	            } else if (process.env.NODE_ENV !== 'production') {
	              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
	            }
	          }
	          // either not server-rendered, or hydration failed.
	          // create an empty node and replace it
	          oldVnode = emptyNodeAt(oldVnode);
	        }
	        // replacing existing element
	        var oldElm = oldVnode.elm;
	        var parentElm$1 = nodeOps.parentNode(oldElm);
	        createElm(vnode, insertedVnodeQueue,
	        // extremely rare edge case: do not insert if old element is in a
	        // leaving transition. Only happens when combining transition +
	        // keep-alive + HOCs. (#4590)
	        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));
	
	        if (isDef(vnode.parent)) {
	          // component root element replaced.
	          // update parent placeholder node element, recursively
	          var ancestor = vnode.parent;
	          while (ancestor) {
	            ancestor.elm = vnode.elm;
	            ancestor = ancestor.parent;
	          }
	          if (isPatchable(vnode)) {
	            for (var i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode.parent);
	            }
	          }
	        }
	
	        if (isDef(parentElm$1)) {
	          removeVnodes(parentElm$1, [oldVnode], 0, 0);
	        } else if (isDef(oldVnode.tag)) {
	          invokeDestroyHook(oldVnode);
	        }
	      }
	    }
	
	    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	    return vnode.elm;
	  };
	}
	
	/*  */
	
	var directives = {
	  create: updateDirectives,
	  update: updateDirectives,
	  destroy: function unbindDirectives(vnode) {
	    updateDirectives(vnode, emptyNode);
	  }
	};
	
	function updateDirectives(oldVnode, vnode) {
	  if (oldVnode.data.directives || vnode.data.directives) {
	    _update(oldVnode, vnode);
	  }
	}
	
	function _update(oldVnode, vnode) {
	  var isCreate = oldVnode === emptyNode;
	  var isDestroy = vnode === emptyNode;
	  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
	  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
	
	  var dirsWithInsert = [];
	  var dirsWithPostpatch = [];
	
	  var key, oldDir, dir;
	  for (key in newDirs) {
	    oldDir = oldDirs[key];
	    dir = newDirs[key];
	    if (!oldDir) {
	      // new directive, bind
	      callHook$1(dir, 'bind', vnode, oldVnode);
	      if (dir.def && dir.def.inserted) {
	        dirsWithInsert.push(dir);
	      }
	    } else {
	      // existing directive, update
	      dir.oldValue = oldDir.value;
	      callHook$1(dir, 'update', vnode, oldVnode);
	      if (dir.def && dir.def.componentUpdated) {
	        dirsWithPostpatch.push(dir);
	      }
	    }
	  }
	
	  if (dirsWithInsert.length) {
	    var callInsert = function callInsert() {
	      for (var i = 0; i < dirsWithInsert.length; i++) {
	        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
	      }
	    };
	    if (isCreate) {
	      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
	    } else {
	      callInsert();
	    }
	  }
	
	  if (dirsWithPostpatch.length) {
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
	      for (var i = 0; i < dirsWithPostpatch.length; i++) {
	        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
	      }
	    });
	  }
	
	  if (!isCreate) {
	    for (key in oldDirs) {
	      if (!newDirs[key]) {
	        // no longer present, unbind
	        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
	      }
	    }
	  }
	}
	
	var emptyModifiers = Object.create(null);
	
	function normalizeDirectives$1(dirs, vm) {
	  var res = Object.create(null);
	  if (!dirs) {
	    return res;
	  }
	  var i, dir;
	  for (i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (!dir.modifiers) {
	      dir.modifiers = emptyModifiers;
	    }
	    res[getRawDirName(dir)] = dir;
	    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
	  }
	  return res;
	}
	
	function getRawDirName(dir) {
	  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
	}
	
	function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
	  var fn = dir.def && dir.def[hook];
	  if (fn) {
	    try {
	      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
	    } catch (e) {
	      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
	    }
	  }
	}
	
	var baseModules = [ref, directives];
	
	/*  */
	
	function updateAttrs(oldVnode, vnode) {
	  var opts = vnode.componentOptions;
	  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
	    return;
	  }
	  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
	    return;
	  }
	  var key, cur, old;
	  var elm = vnode.elm;
	  var oldAttrs = oldVnode.data.attrs || {};
	  var attrs = vnode.data.attrs || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(attrs.__ob__)) {
	    attrs = vnode.data.attrs = extend({}, attrs);
	  }
	
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      setAttr(elm, key, cur);
	    }
	  }
	  // #4391: in IE9, setting type can reset value for input[type=radio]
	  /* istanbul ignore if */
	  if (isIE9 && attrs.value !== oldAttrs.value) {
	    setAttr(elm, 'value', attrs.value);
	  }
	  for (key in oldAttrs) {
	    if (isUndef(attrs[key])) {
	      if (isXlink(key)) {
	        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	      } else if (!isEnumeratedAttr(key)) {
	        elm.removeAttribute(key);
	      }
	    }
	  }
	}
	
	function setAttr(el, key, value) {
	  if (isBooleanAttr(key)) {
	    // set attribute for blank value
	    // e.g. <option disabled>Select one</option>
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, key);
	    }
	  } else if (isEnumeratedAttr(key)) {
	    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
	  } else if (isXlink(key)) {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, value);
	    }
	  }
	}
	
	var attrs = {
	  create: updateAttrs,
	  update: updateAttrs
	};
	
	/*  */
	
	function updateClass(oldVnode, vnode) {
	  var el = vnode.elm;
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
	    return;
	  }
	
	  var cls = genClassForVnode(vnode);
	
	  // handle transition classes
	  var transitionClass = el._transitionClasses;
	  if (isDef(transitionClass)) {
	    cls = concat(cls, stringifyClass(transitionClass));
	  }
	
	  // set the class
	  if (cls !== el._prevClass) {
	    el.setAttribute('class', cls);
	    el._prevClass = cls;
	  }
	}
	
	var klass = {
	  create: updateClass,
	  update: updateClass
	};
	
	/*  */
	
	var validDivisionCharRE = /[\w).+\-_$\]]/;
	
	function parseFilters(exp) {
	  var inSingle = false;
	  var inDouble = false;
	  var inTemplateString = false;
	  var inRegex = false;
	  var curly = 0;
	  var square = 0;
	  var paren = 0;
	  var lastFilterIndex = 0;
	  var c, prev, i, expression, filters;
	
	  for (i = 0; i < exp.length; i++) {
	    prev = c;
	    c = exp.charCodeAt(i);
	    if (inSingle) {
	      if (c === 0x27 && prev !== 0x5C) {
	        inSingle = false;
	      }
	    } else if (inDouble) {
	      if (c === 0x22 && prev !== 0x5C) {
	        inDouble = false;
	      }
	    } else if (inTemplateString) {
	      if (c === 0x60 && prev !== 0x5C) {
	        inTemplateString = false;
	      }
	    } else if (inRegex) {
	      if (c === 0x2f && prev !== 0x5C) {
	        inRegex = false;
	      }
	    } else if (c === 0x7C && // pipe
	    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
	      if (expression === undefined) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        expression = exp.slice(0, i).trim();
	      } else {
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x60:
	          inTemplateString = true;break; // `
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	      if (c === 0x2f) {
	        // /
	        var j = i - 1;
	        var p = void 0;
	        // find first non-whitespace prev char
	        for (; j >= 0; j--) {
	          p = exp.charAt(j);
	          if (p !== ' ') {
	            break;
	          }
	        }
	        if (!p || !validDivisionCharRE.test(p)) {
	          inRegex = true;
	        }
	      }
	    }
	  }
	
	  if (expression === undefined) {
	    expression = exp.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  function pushFilter() {
	    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
	    lastFilterIndex = i + 1;
	  }
	
	  if (filters) {
	    for (i = 0; i < filters.length; i++) {
	      expression = wrapFilter(expression, filters[i]);
	    }
	  }
	
	  return expression;
	}
	
	function wrapFilter(exp, filter) {
	  var i = filter.indexOf('(');
	  if (i < 0) {
	    // _f: resolveFilter
	    return "_f(\"" + filter + "\")(" + exp + ")";
	  } else {
	    var name = filter.slice(0, i);
	    var args = filter.slice(i + 1);
	    return "_f(\"" + name + "\")(" + exp + "," + args;
	  }
	}
	
	/*  */
	
	function baseWarn(msg) {
	  console.error("[Vue compiler]: " + msg);
	}
	
	function pluckModuleFunction(modules, key) {
	  return modules ? modules.map(function (m) {
	    return m[key];
	  }).filter(function (_) {
	    return _;
	  }) : [];
	}
	
	function addProp(el, name, value) {
	  (el.props || (el.props = [])).push({ name: name, value: value });
	}
	
	function addAttr(el, name, value) {
	  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
	}
	
	function addDirective(el, name, rawName, value, arg, modifiers) {
	  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
	}
	
	function addHandler(el, name, value, modifiers, important, warn) {
	  // warn prevent and passive modifier
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {
	    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
	  }
	  // check capture modifier
	  if (modifiers && modifiers.capture) {
	    delete modifiers.capture;
	    name = '!' + name; // mark the event as captured
	  }
	  if (modifiers && modifiers.once) {
	    delete modifiers.once;
	    name = '~' + name; // mark the event as once
	  }
	  /* istanbul ignore if */
	  if (modifiers && modifiers.passive) {
	    delete modifiers.passive;
	    name = '&' + name; // mark the event as passive
	  }
	  var events;
	  if (modifiers && modifiers.native) {
	    delete modifiers.native;
	    events = el.nativeEvents || (el.nativeEvents = {});
	  } else {
	    events = el.events || (el.events = {});
	  }
	  var newHandler = { value: value, modifiers: modifiers };
	  var handlers = events[name];
	  /* istanbul ignore if */
	  if (Array.isArray(handlers)) {
	    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
	  } else if (handlers) {
	    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
	  } else {
	    events[name] = newHandler;
	  }
	}
	
	function getBindingAttr(el, name, getStatic) {
	  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
	  if (dynamicValue != null) {
	    return parseFilters(dynamicValue);
	  } else if (getStatic !== false) {
	    var staticValue = getAndRemoveAttr(el, name);
	    if (staticValue != null) {
	      return JSON.stringify(staticValue);
	    }
	  }
	}
	
	function getAndRemoveAttr(el, name) {
	  var val;
	  if ((val = el.attrsMap[name]) != null) {
	    var list = el.attrsList;
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (list[i].name === name) {
	        list.splice(i, 1);
	        break;
	      }
	    }
	  }
	  return val;
	}
	
	/*  */
	
	/**
	 * Cross-platform code generation for component v-model
	 */
	function genComponentModel(el, value, modifiers) {
	  var ref = modifiers || {};
	  var number = ref.number;
	  var trim = ref.trim;
	
	  var baseValueExpression = '$$v';
	  var valueExpression = baseValueExpression;
	  if (trim) {
	    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	  var assignment = genAssignmentCode(value, valueExpression);
	
	  el.model = {
	    value: "(" + value + ")",
	    expression: "\"" + value + "\"",
	    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
	  };
	}
	
	/**
	 * Cross-platform codegen helper for generating v-model value assignment code.
	 */
	function genAssignmentCode(value, assignment) {
	  var modelRs = parseModel(value);
	  if (modelRs.idx === null) {
	    return value + "=" + assignment;
	  } else {
	    return "$set(" + modelRs.exp + ", " + modelRs.idx + ", " + assignment + ")";
	  }
	}
	
	/**
	 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
	 *
	 * for loop possible cases:
	 *
	 * - test
	 * - test[idx]
	 * - test[test1[idx]]
	 * - test["a"][idx]
	 * - xxx.test[a[a].test1[idx]]
	 * - test.xxx.a["asa"][test1[idx]]
	 *
	 */
	
	var len;
	var str;
	var chr;
	var index$1;
	var expressionPos;
	var expressionEndPos;
	
	function parseModel(val) {
	  str = val;
	  len = str.length;
	  index$1 = expressionPos = expressionEndPos = 0;
	
	  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
	    return {
	      exp: val,
	      idx: null
	    };
	  }
	
	  while (!eof()) {
	    chr = next();
	    /* istanbul ignore if */
	    if (isStringStart(chr)) {
	      parseString(chr);
	    } else if (chr === 0x5B) {
	      parseBracket(chr);
	    }
	  }
	
	  return {
	    exp: val.substring(0, expressionPos),
	    idx: val.substring(expressionPos + 1, expressionEndPos)
	  };
	}
	
	function next() {
	  return str.charCodeAt(++index$1);
	}
	
	function eof() {
	  return index$1 >= len;
	}
	
	function isStringStart(chr) {
	  return chr === 0x22 || chr === 0x27;
	}
	
	function parseBracket(chr) {
	  var inBracket = 1;
	  expressionPos = index$1;
	  while (!eof()) {
	    chr = next();
	    if (isStringStart(chr)) {
	      parseString(chr);
	      continue;
	    }
	    if (chr === 0x5B) {
	      inBracket++;
	    }
	    if (chr === 0x5D) {
	      inBracket--;
	    }
	    if (inBracket === 0) {
	      expressionEndPos = index$1;
	      break;
	    }
	  }
	}
	
	function parseString(chr) {
	  var stringQuote = chr;
	  while (!eof()) {
	    chr = next();
	    if (chr === stringQuote) {
	      break;
	    }
	  }
	}
	
	/*  */
	
	var warn$1;
	
	// in some cases, the event used has to be determined at runtime
	// so we used some reserved tokens during compile.
	var RANGE_TOKEN = '__r';
	var CHECKBOX_RADIO_TOKEN = '__c';
	
	function model(el, dir, _warn) {
	  warn$1 = _warn;
	  var value = dir.value;
	  var modifiers = dir.modifiers;
	  var tag = el.tag;
	  var type = el.attrsMap.type;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
	    if (tag === 'input' && dynamicType) {
	      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
	    }
	    // inputs with type="file" are read only and setting the input's
	    // value will throw an error.
	    if (tag === 'input' && type === 'file') {
	      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
	    }
	  }
	
	  if (el.component) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (tag === 'select') {
	    genSelect(el, value, modifiers);
	  } else if (tag === 'input' && type === 'checkbox') {
	    genCheckboxModel(el, value, modifiers);
	  } else if (tag === 'input' && type === 'radio') {
	    genRadioModel(el, value, modifiers);
	  } else if (tag === 'input' || tag === 'textarea') {
	    genDefaultModel(el, value, modifiers);
	  } else if (!config.isReservedTag(tag)) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
	  }
	
	  // ensure runtime directive metadata
	  return true;
	}
	
	function genCheckboxModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
	  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
	  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
	  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
	}
	
	function genRadioModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
	  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
	  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
	}
	
	function genSelect(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
	
	  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
	  var code = "var $$selectedVal = " + selectedVal + ";";
	  code = code + " " + genAssignmentCode(value, assignment);
	  addHandler(el, 'change', code, null, true);
	}
	
	function genDefaultModel(el, value, modifiers) {
	  var type = el.attrsMap.type;
	  var ref = modifiers || {};
	  var lazy = ref.lazy;
	  var number = ref.number;
	  var trim = ref.trim;
	  var needCompositionGuard = !lazy && type !== 'range';
	  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
	
	  var valueExpression = '$event.target.value';
	  if (trim) {
	    valueExpression = "$event.target.value.trim()";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	
	  var code = genAssignmentCode(value, valueExpression);
	  if (needCompositionGuard) {
	    code = "if($event.target.composing)return;" + code;
	  }
	
	  addProp(el, 'value', "(" + value + ")");
	  addHandler(el, event, code, null, true);
	  if (trim || number) {
	    addHandler(el, 'blur', '$forceUpdate()');
	  }
	}
	
	/*  */
	
	// normalize v-model event tokens that can only be determined at runtime.
	// it's important to place the event as the first in the array because
	// the whole point is ensuring the v-model callback gets called before
	// user-attached handlers.
	function normalizeEvents(on) {
	  var event;
	  /* istanbul ignore if */
	  if (isDef(on[RANGE_TOKEN])) {
	    // IE input[type=range] only supports `change` event
	    event = isIE ? 'change' : 'input';
	    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
	    delete on[RANGE_TOKEN];
	  }
	  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
	    // Chrome fires microtasks in between click/change, leads to #4521
	    event = isChrome ? 'click' : 'change';
	    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
	    delete on[CHECKBOX_RADIO_TOKEN];
	  }
	}
	
	var target$1;
	
	function add$1(event, _handler, once$$1, capture, passive) {
	  if (once$$1) {
	    var oldHandler = _handler;
	    var _target = target$1; // save current target element in closure
	    _handler = function handler(ev) {
	      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
	      if (res !== null) {
	        remove$2(event, _handler, capture, _target);
	      }
	    };
	  }
	  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);
	}
	
	function remove$2(event, handler, capture, _target) {
	  (_target || target$1).removeEventListener(event, handler, capture);
	}
	
	function updateDOMListeners(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
	    return;
	  }
	  var on = vnode.data.on || {};
	  var oldOn = oldVnode.data.on || {};
	  target$1 = vnode.elm;
	  normalizeEvents(on);
	  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
	}
	
	var events = {
	  create: updateDOMListeners,
	  update: updateDOMListeners
	};
	
	/*  */
	
	function updateDOMProps(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
	    return;
	  }
	  var key, cur;
	  var elm = vnode.elm;
	  var oldProps = oldVnode.data.domProps || {};
	  var props = vnode.data.domProps || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(props.__ob__)) {
	    props = vnode.data.domProps = extend({}, props);
	  }
	
	  for (key in oldProps) {
	    if (isUndef(props[key])) {
	      elm[key] = '';
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    // ignore children if the node has textContent or innerHTML,
	    // as these will throw away existing DOM nodes and cause removal errors
	    // on subsequent patches (#3360)
	    if (key === 'textContent' || key === 'innerHTML') {
	      if (vnode.children) {
	        vnode.children.length = 0;
	      }
	      if (cur === oldProps[key]) {
	        continue;
	      }
	    }
	
	    if (key === 'value') {
	      // store value as _value as well since
	      // non-string values will be stringified
	      elm._value = cur;
	      // avoid resetting cursor position when value is the same
	      var strCur = isUndef(cur) ? '' : String(cur);
	      if (shouldUpdateValue(elm, vnode, strCur)) {
	        elm.value = strCur;
	      }
	    } else {
	      elm[key] = cur;
	    }
	  }
	}
	
	// check platforms/web/util/attrs.js acceptValue
	
	
	function shouldUpdateValue(elm, vnode, checkVal) {
	  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
	}
	
	function isDirty(elm, checkVal) {
	  // return true when textbox (.number and .trim) loses focus and its value is
	  // not equal to the updated value
	  var notInFocus = true;
	  // #6157
	  // work around IE bug when accessing document.activeElement in an iframe
	  try {
	    notInFocus = document.activeElement !== elm;
	  } catch (e) {}
	  return notInFocus && elm.value !== checkVal;
	}
	
	function isInputChanged(elm, newVal) {
	  var value = elm.value;
	  var modifiers = elm._vModifiers; // injected by v-model runtime
	  if (isDef(modifiers) && modifiers.number) {
	    return toNumber(value) !== toNumber(newVal);
	  }
	  if (isDef(modifiers) && modifiers.trim) {
	    return value.trim() !== newVal.trim();
	  }
	  return value !== newVal;
	}
	
	var domProps = {
	  create: updateDOMProps,
	  update: updateDOMProps
	};
	
	/*  */
	
	var parseStyleText = cached(function (cssText) {
	  var res = {};
	  var listDelimiter = /;(?![^(]*\))/g;
	  var propertyDelimiter = /:(.+)/;
	  cssText.split(listDelimiter).forEach(function (item) {
	    if (item) {
	      var tmp = item.split(propertyDelimiter);
	      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
	    }
	  });
	  return res;
	});
	
	// merge static and dynamic style data on the same vnode
	function normalizeStyleData(data) {
	  var style = normalizeStyleBinding(data.style);
	  // static style is pre-processed into an object during compilation
	  // and is always a fresh object, so it's safe to merge into it
	  return data.staticStyle ? extend(data.staticStyle, style) : style;
	}
	
	// normalize possible array / string values into Object
	function normalizeStyleBinding(bindingStyle) {
	  if (Array.isArray(bindingStyle)) {
	    return toObject(bindingStyle);
	  }
	  if (typeof bindingStyle === 'string') {
	    return parseStyleText(bindingStyle);
	  }
	  return bindingStyle;
	}
	
	/**
	 * parent component style should be after child's
	 * so that parent component's style could override it
	 */
	function getStyle(vnode, checkChild) {
	  var res = {};
	  var styleData;
	
	  if (checkChild) {
	    var childNode = vnode;
	    while (childNode.componentInstance) {
	      childNode = childNode.componentInstance._vnode;
	      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
	        extend(res, styleData);
	      }
	    }
	  }
	
	  if (styleData = normalizeStyleData(vnode.data)) {
	    extend(res, styleData);
	  }
	
	  var parentNode = vnode;
	  while (parentNode = parentNode.parent) {
	    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
	      extend(res, styleData);
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var cssVarRE = /^--/;
	var importantRE = /\s*!important$/;
	var setProp = function setProp(el, name, val) {
	  /* istanbul ignore if */
	  if (cssVarRE.test(name)) {
	    el.style.setProperty(name, val);
	  } else if (importantRE.test(val)) {
	    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
	  } else {
	    var normalizedName = normalize(name);
	    if (Array.isArray(val)) {
	      // Support values array created by autoprefixer, e.g.
	      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
	      // Set them one by one, and the browser will only set those it can recognize
	      for (var i = 0, len = val.length; i < len; i++) {
	        el.style[normalizedName] = val[i];
	      }
	    } else {
	      el.style[normalizedName] = val;
	    }
	  }
	};
	
	var vendorNames = ['Webkit', 'Moz', 'ms'];
	
	var emptyStyle;
	var normalize = cached(function (prop) {
	  emptyStyle = emptyStyle || document.createElement('div').style;
	  prop = camelize(prop);
	  if (prop !== 'filter' && prop in emptyStyle) {
	    return prop;
	  }
	  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
	  for (var i = 0; i < vendorNames.length; i++) {
	    var name = vendorNames[i] + capName;
	    if (name in emptyStyle) {
	      return name;
	    }
	  }
	});
	
	function updateStyle(oldVnode, vnode) {
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	
	  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
	    return;
	  }
	
	  var cur, name;
	  var el = vnode.elm;
	  var oldStaticStyle = oldData.staticStyle;
	  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
	
	  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
	  var oldStyle = oldStaticStyle || oldStyleBinding;
	
	  var style = normalizeStyleBinding(vnode.data.style) || {};
	
	  // store normalized style under a different key for next diff
	  // make sure to clone it if it's reactive, since the user likley wants
	  // to mutate it.
	  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
	
	  var newStyle = getStyle(vnode, true);
	
	  for (name in oldStyle) {
	    if (isUndef(newStyle[name])) {
	      setProp(el, name, '');
	    }
	  }
	  for (name in newStyle) {
	    cur = newStyle[name];
	    if (cur !== oldStyle[name]) {
	      // ie9 setting to null has no effect, must use empty string
	      setProp(el, name, cur == null ? '' : cur);
	    }
	  }
	}
	
	var style = {
	  create: updateStyle,
	  update: updateStyle
	};
	
	/*  */
	
	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.add(c);
	      });
	    } else {
	      el.classList.add(cls);
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.remove(c);
	      });
	    } else {
	      el.classList.remove(cls);
	    }
	    if (!el.classList.length) {
	      el.removeAttribute('class');
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    cur = cur.trim();
	    if (cur) {
	      el.setAttribute('class', cur);
	    } else {
	      el.removeAttribute('class');
	    }
	  }
	}
	
	/*  */
	
	function resolveTransition(def$$1) {
	  if (!def$$1) {
	    return;
	  }
	  /* istanbul ignore else */
	  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
	    var res = {};
	    if (def$$1.css !== false) {
	      extend(res, autoCssTransition(def$$1.name || 'v'));
	    }
	    extend(res, def$$1);
	    return res;
	  } else if (typeof def$$1 === 'string') {
	    return autoCssTransition(def$$1);
	  }
	}
	
	var autoCssTransition = cached(function (name) {
	  return {
	    enterClass: name + "-enter",
	    enterToClass: name + "-enter-to",
	    enterActiveClass: name + "-enter-active",
	    leaveClass: name + "-leave",
	    leaveToClass: name + "-leave-to",
	    leaveActiveClass: name + "-leave-active"
	  };
	});
	
	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';
	
	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	  /* istanbul ignore if */
	  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
	    transitionProp = 'WebkitTransition';
	    transitionEndEvent = 'webkitTransitionEnd';
	  }
	  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
	    animationProp = 'WebkitAnimation';
	    animationEndEvent = 'webkitAnimationEnd';
	  }
	}
	
	// binding to window is necessary to make hot reload work in IE in strict mode
	var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;
	
	function nextFrame(fn) {
	  raf(function () {
	    raf(fn);
	  });
	}
	
	function addTransitionClass(el, cls) {
	  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
	  if (transitionClasses.indexOf(cls) < 0) {
	    transitionClasses.push(cls);
	    addClass(el, cls);
	  }
	}
	
	function removeTransitionClass(el, cls) {
	  if (el._transitionClasses) {
	    remove(el._transitionClasses, cls);
	  }
	  removeClass(el, cls);
	}
	
	function whenTransitionEnds(el, expectedType, cb) {
	  var ref = getTransitionInfo(el, expectedType);
	  var type = ref.type;
	  var timeout = ref.timeout;
	  var propCount = ref.propCount;
	  if (!type) {
	    return cb();
	  }
	  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	  var ended = 0;
	  var end = function end() {
	    el.removeEventListener(event, onEnd);
	    cb();
	  };
	  var onEnd = function onEnd(e) {
	    if (e.target === el) {
	      if (++ended >= propCount) {
	        end();
	      }
	    }
	  };
	  setTimeout(function () {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(event, onEnd);
	}
	
	var transformRE = /\b(transform|all)(,|$)/;
	
	function getTransitionInfo(el, expectedType) {
	  var styles = window.getComputedStyle(el);
	  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
	  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
	  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	  var animationDelays = styles[animationProp + 'Delay'].split(', ');
	  var animationDurations = styles[animationProp + 'Duration'].split(', ');
	  var animationTimeout = getTimeout(animationDelays, animationDurations);
	
	  var type;
	  var timeout = 0;
	  var propCount = 0;
	  /* istanbul ignore if */
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
	    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
	  }
	  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
	  return {
	    type: type,
	    timeout: timeout,
	    propCount: propCount,
	    hasTransform: hasTransform
	  };
	}
	
	function getTimeout(delays, durations) {
	  /* istanbul ignore next */
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }
	
	  return Math.max.apply(null, durations.map(function (d, i) {
	    return toMs(d) + toMs(delays[i]);
	  }));
	}
	
	function toMs(s) {
	  return Number(s.slice(0, -1)) * 1000;
	}
	
	/*  */
	
	function enter(vnode, toggleDisplay) {
	  var el = vnode.elm;
	
	  // call leave callback now
	  if (isDef(el._leaveCb)) {
	    el._leaveCb.cancelled = true;
	    el._leaveCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return;
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._enterCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var enterClass = data.enterClass;
	  var enterToClass = data.enterToClass;
	  var enterActiveClass = data.enterActiveClass;
	  var appearClass = data.appearClass;
	  var appearToClass = data.appearToClass;
	  var appearActiveClass = data.appearActiveClass;
	  var beforeEnter = data.beforeEnter;
	  var enter = data.enter;
	  var afterEnter = data.afterEnter;
	  var enterCancelled = data.enterCancelled;
	  var beforeAppear = data.beforeAppear;
	  var appear = data.appear;
	  var afterAppear = data.afterAppear;
	  var appearCancelled = data.appearCancelled;
	  var duration = data.duration;
	
	  // activeInstance will always be the <transition> component managing this
	  // transition. One edge case to check is when the <transition> is placed
	  // as the root node of a child component. In that case we need to check
	  // <transition>'s parent for appear check.
	  var context = activeInstance;
	  var transitionNode = activeInstance.$vnode;
	  while (transitionNode && transitionNode.parent) {
	    transitionNode = transitionNode.parent;
	    context = transitionNode.context;
	  }
	
	  var isAppear = !context._isMounted || !vnode.isRootInsert;
	
	  if (isAppear && !appear && appear !== '') {
	    return;
	  }
	
	  var startClass = isAppear && appearClass ? appearClass : enterClass;
	  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
	  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
	
	  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
	  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
	  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
	  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
	
	  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
	
	  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
	    checkDuration(explicitEnterDuration, 'enter', vnode);
	  }
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(enterHook);
	
	  var cb = el._enterCb = once(function () {
	    if (expectsCSS) {
	      removeTransitionClass(el, toClass);
	      removeTransitionClass(el, activeClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, startClass);
	      }
	      enterCancelledHook && enterCancelledHook(el);
	    } else {
	      afterEnterHook && afterEnterHook(el);
	    }
	    el._enterCb = null;
	  });
	
	  if (!vnode.data.show) {
	    // remove pending leave element on enter by injecting an insert hook
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
	      var parent = el.parentNode;
	      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
	        pendingNode.elm._leaveCb();
	      }
	      enterHook && enterHook(el, cb);
	    });
	  }
	
	  // start enter transition
	  beforeEnterHook && beforeEnterHook(el);
	  if (expectsCSS) {
	    addTransitionClass(el, startClass);
	    addTransitionClass(el, activeClass);
	    nextFrame(function () {
	      addTransitionClass(el, toClass);
	      removeTransitionClass(el, startClass);
	      if (!cb.cancelled && !userWantsControl) {
	        if (isValidDuration(explicitEnterDuration)) {
	          setTimeout(cb, explicitEnterDuration);
	        } else {
	          whenTransitionEnds(el, type, cb);
	        }
	      }
	    });
	  }
	
	  if (vnode.data.show) {
	    toggleDisplay && toggleDisplay();
	    enterHook && enterHook(el, cb);
	  }
	
	  if (!expectsCSS && !userWantsControl) {
	    cb();
	  }
	}
	
	function leave(vnode, rm) {
	  var el = vnode.elm;
	
	  // call enter callback now
	  if (isDef(el._enterCb)) {
	    el._enterCb.cancelled = true;
	    el._enterCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return rm();
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._leaveCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var leaveClass = data.leaveClass;
	  var leaveToClass = data.leaveToClass;
	  var leaveActiveClass = data.leaveActiveClass;
	  var beforeLeave = data.beforeLeave;
	  var leave = data.leave;
	  var afterLeave = data.afterLeave;
	  var leaveCancelled = data.leaveCancelled;
	  var delayLeave = data.delayLeave;
	  var duration = data.duration;
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(leave);
	
	  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
	
	  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
	    checkDuration(explicitLeaveDuration, 'leave', vnode);
	  }
	
	  var cb = el._leaveCb = once(function () {
	    if (el.parentNode && el.parentNode._pending) {
	      el.parentNode._pending[vnode.key] = null;
	    }
	    if (expectsCSS) {
	      removeTransitionClass(el, leaveToClass);
	      removeTransitionClass(el, leaveActiveClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, leaveClass);
	      }
	      leaveCancelled && leaveCancelled(el);
	    } else {
	      rm();
	      afterLeave && afterLeave(el);
	    }
	    el._leaveCb = null;
	  });
	
	  if (delayLeave) {
	    delayLeave(performLeave);
	  } else {
	    performLeave();
	  }
	
	  function performLeave() {
	    // the delayed leave may have already been cancelled
	    if (cb.cancelled) {
	      return;
	    }
	    // record leaving element
	    if (!vnode.data.show) {
	      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
	    }
	    beforeLeave && beforeLeave(el);
	    if (expectsCSS) {
	      addTransitionClass(el, leaveClass);
	      addTransitionClass(el, leaveActiveClass);
	      nextFrame(function () {
	        addTransitionClass(el, leaveToClass);
	        removeTransitionClass(el, leaveClass);
	        if (!cb.cancelled && !userWantsControl) {
	          if (isValidDuration(explicitLeaveDuration)) {
	            setTimeout(cb, explicitLeaveDuration);
	          } else {
	            whenTransitionEnds(el, type, cb);
	          }
	        }
	      });
	    }
	    leave && leave(el, cb);
	    if (!expectsCSS && !userWantsControl) {
	      cb();
	    }
	  }
	}
	
	// only used in dev mode
	function checkDuration(val, name, vnode) {
	  if (typeof val !== 'number') {
	    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
	  } else if (isNaN(val)) {
	    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
	  }
	}
	
	function isValidDuration(val) {
	  return typeof val === 'number' && !isNaN(val);
	}
	
	/**
	 * Normalize a transition hook's argument length. The hook may be:
	 * - a merged hook (invoker) with the original in .fns
	 * - a wrapped component method (check ._length)
	 * - a plain function (.length)
	 */
	function getHookArgumentsLength(fn) {
	  if (isUndef(fn)) {
	    return false;
	  }
	  var invokerFns = fn.fns;
	  if (isDef(invokerFns)) {
	    // invoker
	    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
	  } else {
	    return (fn._length || fn.length) > 1;
	  }
	}
	
	function _enter(_, vnode) {
	  if (vnode.data.show !== true) {
	    enter(vnode);
	  }
	}
	
	var transition = inBrowser ? {
	  create: _enter,
	  activate: _enter,
	  remove: function remove$$1(vnode, rm) {
	    /* istanbul ignore else */
	    if (vnode.data.show !== true) {
	      leave(vnode, rm);
	    } else {
	      rm();
	    }
	  }
	} : {};
	
	var platformModules = [attrs, klass, events, domProps, style, transition];
	
	/*  */
	
	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);
	
	var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
	
	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */
	
	var isTextInputType = makeMap('text,number,password,search,email,tel,url');
	
	/* istanbul ignore if */
	if (isIE9) {
	  // http://www.matts411.com/post/internet-explorer-9-oninput/
	  document.addEventListener('selectionchange', function () {
	    var el = document.activeElement;
	    if (el && el.vmodel) {
	      trigger(el, 'input');
	    }
	  });
	}
	
	var model$1 = {
	  inserted: function inserted(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      var cb = function cb() {
	        setSelected(el, binding, vnode.context);
	      };
	      cb();
	      /* istanbul ignore if */
	      if (isIE || isEdge) {
	        setTimeout(cb, 0);
	      }
	      el._vOptions = [].map.call(el.options, getValue);
	    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
	      el._vModifiers = binding.modifiers;
	      if (!binding.modifiers.lazy) {
	        // Safari < 10.2 & UIWebView doesn't fire compositionend when
	        // switching focus before confirming composition choice
	        // this also fixes the issue where some browsers e.g. iOS Chrome
	        // fires "change" instead of "input" on autocomplete.
	        el.addEventListener('change', onCompositionEnd);
	        if (!isAndroid) {
	          el.addEventListener('compositionstart', onCompositionStart);
	          el.addEventListener('compositionend', onCompositionEnd);
	        }
	        /* istanbul ignore if */
	        if (isIE9) {
	          el.vmodel = true;
	        }
	      }
	    }
	  },
	  componentUpdated: function componentUpdated(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      setSelected(el, binding, vnode.context);
	      // in case the options rendered by v-for have changed,
	      // it's possible that the value is out-of-sync with the rendered options.
	      // detect such cases and filter out values that no longer has a matching
	      // option in the DOM.
	      var prevOptions = el._vOptions;
	      var curOptions = el._vOptions = [].map.call(el.options, getValue);
	      if (curOptions.some(function (o, i) {
	        return !looseEqual(o, prevOptions[i]);
	      })) {
	        trigger(el, 'change');
	      }
	    }
	  }
	};
	
	function setSelected(el, binding, vm) {
	  var value = binding.value;
	  var isMultiple = el.multiple;
	  if (isMultiple && !Array.isArray(value)) {
	    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
	    return;
	  }
	  var selected, option;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    option = el.options[i];
	    if (isMultiple) {
	      selected = looseIndexOf(value, getValue(option)) > -1;
	      if (option.selected !== selected) {
	        option.selected = selected;
	      }
	    } else {
	      if (looseEqual(getValue(option), value)) {
	        if (el.selectedIndex !== i) {
	          el.selectedIndex = i;
	        }
	        return;
	      }
	    }
	  }
	  if (!isMultiple) {
	    el.selectedIndex = -1;
	  }
	}
	
	function getValue(option) {
	  return '_value' in option ? option._value : option.value;
	}
	
	function onCompositionStart(e) {
	  e.target.composing = true;
	}
	
	function onCompositionEnd(e) {
	  // prevent triggering an input event for no reason
	  if (!e.target.composing) {
	    return;
	  }
	  e.target.composing = false;
	  trigger(e.target, 'input');
	}
	
	function trigger(el, type) {
	  var e = document.createEvent('HTMLEvents');
	  e.initEvent(type, true, true);
	  el.dispatchEvent(e);
	}
	
	/*  */
	
	// recursively search for possible transition defined inside the component root
	function locateNode(vnode) {
	  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
	}
	
	var show = {
	  bind: function bind(el, ref, vnode) {
	    var value = ref.value;
	
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
	    if (value && transition$$1) {
	      vnode.data.show = true;
	      enter(vnode, function () {
	        el.style.display = originalDisplay;
	      });
	    } else {
	      el.style.display = value ? originalDisplay : 'none';
	    }
	  },
	
	  update: function update(el, ref, vnode) {
	    var value = ref.value;
	    var oldValue = ref.oldValue;
	
	    /* istanbul ignore if */
	    if (value === oldValue) {
	      return;
	    }
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    if (transition$$1) {
	      vnode.data.show = true;
	      if (value) {
	        enter(vnode, function () {
	          el.style.display = el.__vOriginalDisplay;
	        });
	      } else {
	        leave(vnode, function () {
	          el.style.display = 'none';
	        });
	      }
	    } else {
	      el.style.display = value ? el.__vOriginalDisplay : 'none';
	    }
	  },
	
	  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
	    if (!isDestroy) {
	      el.style.display = el.__vOriginalDisplay;
	    }
	  }
	};
	
	var platformDirectives = {
	  model: model$1,
	  show: show
	};
	
	/*  */
	
	// Provides transition support for a single element/component.
	// supports transition mode (out-in / in-out)
	
	var transitionProps = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  duration: [Number, String, Object]
	};
	
	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild(vnode) {
	  var compOptions = vnode && vnode.componentOptions;
	  if (compOptions && compOptions.Ctor.options.abstract) {
	    return getRealChild(getFirstComponentChild(compOptions.children));
	  } else {
	    return vnode;
	  }
	}
	
	function extractTransitionData(comp) {
	  var data = {};
	  var options = comp.$options;
	  // props
	  for (var key in options.propsData) {
	    data[key] = comp[key];
	  }
	  // events.
	  // extract listeners and pass them directly to the transition methods
	  var listeners = options._parentListeners;
	  for (var key$1 in listeners) {
	    data[camelize(key$1)] = listeners[key$1];
	  }
	  return data;
	}
	
	function placeholder(h, rawChild) {
	  if (/\d-keep-alive$/.test(rawChild.tag)) {
	    return h('keep-alive', {
	      props: rawChild.componentOptions.propsData
	    });
	  }
	}
	
	function hasParentTransition(vnode) {
	  while (vnode = vnode.parent) {
	    if (vnode.data.transition) {
	      return true;
	    }
	  }
	}
	
	function isSameChild(child, oldChild) {
	  return oldChild.key === child.key && oldChild.tag === child.tag;
	}
	
	function isAsyncPlaceholder(node) {
	  return node.isComment && node.asyncFactory;
	}
	
	var Transition = {
	  name: 'transition',
	  props: transitionProps,
	  abstract: true,
	
	  render: function render(h) {
	    var this$1 = this;
	
	    var children = this.$options._renderChildren;
	    if (!children) {
	      return;
	    }
	
	    // filter out text nodes (possible whitespaces)
	    children = children.filter(function (c) {
	      return c.tag || isAsyncPlaceholder(c);
	    });
	    /* istanbul ignore if */
	    if (!children.length) {
	      return;
	    }
	
	    // warn multiple elements
	    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
	      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
	    }
	
	    var mode = this.mode;
	
	    // warn invalid mode
	    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
	      warn('invalid <transition> mode: ' + mode, this.$parent);
	    }
	
	    var rawChild = children[0];
	
	    // if this is a component root node and the component's
	    // parent container node also has transition, skip.
	    if (hasParentTransition(this.$vnode)) {
	      return rawChild;
	    }
	
	    // apply transition data to child
	    // use getRealChild() to ignore abstract components e.g. keep-alive
	    var child = getRealChild(rawChild);
	    /* istanbul ignore if */
	    if (!child) {
	      return rawChild;
	    }
	
	    if (this._leaving) {
	      return placeholder(h, rawChild);
	    }
	
	    // ensure a key that is unique to the vnode type and to this transition
	    // component instance. This key will be used to remove pending leaving nodes
	    // during entering.
	    var id = "__transition-" + this._uid + "-";
	    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
	
	    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
	    var oldRawChild = this._vnode;
	    var oldChild = getRealChild(oldRawChild);
	
	    // mark v-show
	    // so that the transition module can hand over the control to the directive
	    if (child.data.directives && child.data.directives.some(function (d) {
	      return d.name === 'show';
	    })) {
	      child.data.show = true;
	    }
	
	    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
	      // replace old child transition data with fresh one
	      // important for dynamic transitions!
	      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
	      // handle transition mode
	      if (mode === 'out-in') {
	        // return placeholder node and queue update when leave finishes
	        this._leaving = true;
	        mergeVNodeHook(oldData, 'afterLeave', function () {
	          this$1._leaving = false;
	          this$1.$forceUpdate();
	        });
	        return placeholder(h, rawChild);
	      } else if (mode === 'in-out') {
	        if (isAsyncPlaceholder(child)) {
	          return oldRawChild;
	        }
	        var delayedLeave;
	        var performLeave = function performLeave() {
	          delayedLeave();
	        };
	        mergeVNodeHook(data, 'afterEnter', performLeave);
	        mergeVNodeHook(data, 'enterCancelled', performLeave);
	        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	          delayedLeave = leave;
	        });
	      }
	    }
	
	    return rawChild;
	  }
	};
	
	/*  */
	
	// Provides transition support for list items.
	// supports move transitions using the FLIP technique.
	
	// Because the vdom's children update algorithm is "unstable" - i.e.
	// it doesn't guarantee the relative positioning of removed elements,
	// we force transition-group to update its children into two passes:
	// in the first pass, we remove all nodes that need to be removed,
	// triggering their leaving transition; in the second pass, we insert/move
	// into the final desired state. This way in the second pass removed
	// nodes will remain where they should be.
	
	var props = extend({
	  tag: String,
	  moveClass: String
	}, transitionProps);
	
	delete props.mode;
	
	var TransitionGroup = {
	  props: props,
	
	  render: function render(h) {
	    var tag = this.tag || this.$vnode.data.tag || 'span';
	    var map = Object.create(null);
	    var prevChildren = this.prevChildren = this.children;
	    var rawChildren = this.$slots.default || [];
	    var children = this.children = [];
	    var transitionData = extractTransitionData(this);
	
	    for (var i = 0; i < rawChildren.length; i++) {
	      var c = rawChildren[i];
	      if (c.tag) {
	        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	          children.push(c);
	          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
	        } else if (process.env.NODE_ENV !== 'production') {
	          var opts = c.componentOptions;
	          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
	          warn("<transition-group> children must be keyed: <" + name + ">");
	        }
	      }
	    }
	
	    if (prevChildren) {
	      var kept = [];
	      var removed = [];
	      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
	        var c$1 = prevChildren[i$1];
	        c$1.data.transition = transitionData;
	        c$1.data.pos = c$1.elm.getBoundingClientRect();
	        if (map[c$1.key]) {
	          kept.push(c$1);
	        } else {
	          removed.push(c$1);
	        }
	      }
	      this.kept = h(tag, null, kept);
	      this.removed = removed;
	    }
	
	    return h(tag, null, children);
	  },
	
	  beforeUpdate: function beforeUpdate() {
	    // force removing pass
	    this.__patch__(this._vnode, this.kept, false, // hydrating
	    true // removeOnly (!important, avoids unnecessary moves)
	    );
	    this._vnode = this.kept;
	  },
	
	  updated: function updated() {
	    var children = this.prevChildren;
	    var moveClass = this.moveClass || (this.name || 'v') + '-move';
	    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	      return;
	    }
	
	    // we divide the work into three loops to avoid mixing DOM reads and writes
	    // in each iteration - which helps prevent layout thrashing.
	    children.forEach(callPendingCbs);
	    children.forEach(recordPosition);
	    children.forEach(applyTranslation);
	
	    // force reflow to put everything in position
	    var body = document.body;
	    var f = body.offsetHeight; // eslint-disable-line
	
	    children.forEach(function (c) {
	      if (c.data.moved) {
	        var el = c.elm;
	        var s = el.style;
	        addTransitionClass(el, moveClass);
	        s.transform = s.WebkitTransform = s.transitionDuration = '';
	        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
	          if (!e || /transform$/.test(e.propertyName)) {
	            el.removeEventListener(transitionEndEvent, cb);
	            el._moveCb = null;
	            removeTransitionClass(el, moveClass);
	          }
	        });
	      }
	    });
	  },
	
	  methods: {
	    hasMove: function hasMove(el, moveClass) {
	      /* istanbul ignore if */
	      if (!hasTransition) {
	        return false;
	      }
	      /* istanbul ignore if */
	      if (this._hasMove) {
	        return this._hasMove;
	      }
	      // Detect whether an element with the move class applied has
	      // CSS transitions. Since the element may be inside an entering
	      // transition at this very moment, we make a clone of it and remove
	      // all other transition classes applied to ensure only the move class
	      // is applied.
	      var clone = el.cloneNode();
	      if (el._transitionClasses) {
	        el._transitionClasses.forEach(function (cls) {
	          removeClass(clone, cls);
	        });
	      }
	      addClass(clone, moveClass);
	      clone.style.display = 'none';
	      this.$el.appendChild(clone);
	      var info = getTransitionInfo(clone);
	      this.$el.removeChild(clone);
	      return this._hasMove = info.hasTransform;
	    }
	  }
	};
	
	function callPendingCbs(c) {
	  /* istanbul ignore if */
	  if (c.elm._moveCb) {
	    c.elm._moveCb();
	  }
	  /* istanbul ignore if */
	  if (c.elm._enterCb) {
	    c.elm._enterCb();
	  }
	}
	
	function recordPosition(c) {
	  c.data.newPos = c.elm.getBoundingClientRect();
	}
	
	function applyTranslation(c) {
	  var oldPos = c.data.pos;
	  var newPos = c.data.newPos;
	  var dx = oldPos.left - newPos.left;
	  var dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    c.data.moved = true;
	    var s = c.elm.style;
	    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
	    s.transitionDuration = '0s';
	  }
	}
	
	var platformComponents = {
	  Transition: Transition,
	  TransitionGroup: TransitionGroup
	};
	
	/*  */
	
	// install platform specific utils
	Vue$3.config.mustUseProp = mustUseProp;
	Vue$3.config.isReservedTag = isReservedTag;
	Vue$3.config.isReservedAttr = isReservedAttr;
	Vue$3.config.getTagNamespace = getTagNamespace;
	Vue$3.config.isUnknownElement = isUnknownElement;
	
	// install platform runtime directives & components
	extend(Vue$3.options.directives, platformDirectives);
	extend(Vue$3.options.components, platformComponents);
	
	// install platform patch function
	Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
	
	// public mount method
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && inBrowser ? query(el) : undefined;
	  return mountComponent(this, el, hydrating);
	};
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue$3);
	    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
	      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
	    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
	  }
	}, 0);
	
	/*  */
	
	// check whether current browser encodes a char inside attribute values
	function shouldDecode(content, encoded) {
	  var div = document.createElement('div');
	  div.innerHTML = "<div a=\"" + content + "\"/>";
	  return div.innerHTML.indexOf(encoded) > 0;
	}
	
	// #3663
	// IE encodes newlines inside attribute values while other browsers don't
	var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;
	
	/*  */
	
	var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	
	var buildRegex = cached(function (delimiters) {
	  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
	  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
	  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
	});
	
	function parseText(text, delimiters) {
	  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
	  if (!tagRE.test(text)) {
	    return;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index;
	  while (match = tagRE.exec(text)) {
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
	    }
	    // tag token
	    var exp = parseFilters(match[1].trim());
	    tokens.push("_s(" + exp + ")");
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push(JSON.stringify(text.slice(lastIndex)));
	  }
	  return tokens.join('+');
	}
	
	/*  */
	
	function transformNode(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticClass = getAndRemoveAttr(el, 'class');
	  if (process.env.NODE_ENV !== 'production' && staticClass) {
	    var expression = parseText(staticClass, options.delimiters);
	    if (expression) {
	      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
	    }
	  }
	  if (staticClass) {
	    el.staticClass = JSON.stringify(staticClass);
	  }
	  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
	  if (classBinding) {
	    el.classBinding = classBinding;
	  }
	}
	
	function genData(el) {
	  var data = '';
	  if (el.staticClass) {
	    data += "staticClass:" + el.staticClass + ",";
	  }
	  if (el.classBinding) {
	    data += "class:" + el.classBinding + ",";
	  }
	  return data;
	}
	
	var klass$1 = {
	  staticKeys: ['staticClass'],
	  transformNode: transformNode,
	  genData: genData
	};
	
	/*  */
	
	function transformNode$1(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticStyle = getAndRemoveAttr(el, 'style');
	  if (staticStyle) {
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      var expression = parseText(staticStyle, options.delimiters);
	      if (expression) {
	        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
	      }
	    }
	    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
	  }
	
	  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
	  if (styleBinding) {
	    el.styleBinding = styleBinding;
	  }
	}
	
	function genData$1(el) {
	  var data = '';
	  if (el.staticStyle) {
	    data += "staticStyle:" + el.staticStyle + ",";
	  }
	  if (el.styleBinding) {
	    data += "style:(" + el.styleBinding + "),";
	  }
	  return data;
	}
	
	var style$1 = {
	  staticKeys: ['staticStyle'],
	  transformNode: transformNode$1,
	  genData: genData$1
	};
	
	var modules$1 = [klass$1, style$1];
	
	/*  */
	
	function text(el, dir) {
	  if (dir.value) {
	    addProp(el, 'textContent', "_s(" + dir.value + ")");
	  }
	}
	
	/*  */
	
	function html(el, dir) {
	  if (dir.value) {
	    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
	  }
	}
	
	var directives$1 = {
	  model: model,
	  text: text,
	  html: html
	};
	
	/*  */
	
	var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');
	
	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
	
	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
	
	/*  */
	
	var baseOptions = {
	  expectHTML: true,
	  modules: modules$1,
	  directives: directives$1,
	  isPreTag: isPreTag,
	  isUnaryTag: isUnaryTag,
	  mustUseProp: mustUseProp,
	  canBeLeftOpenTag: canBeLeftOpenTag,
	  isReservedTag: isReservedTag,
	  getTagNamespace: getTagNamespace,
	  staticKeys: genStaticKeys(modules$1)
	};
	
	/*  */
	
	var decoder;
	
	var he = {
	  decode: function decode(html) {
	    decoder = decoder || document.createElement('div');
	    decoder.innerHTML = html;
	    return decoder.textContent;
	  }
	};
	
	/**
	 * Not type-checking this file because it's mostly vendor code.
	 */
	
	/*!
	 * HTML Parser By John Resig (ejohn.org)
	 * Modified by Juriy "kangax" Zaytsev
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 */
	
	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/;
	var singleAttrAssign = /(?:=)/;
	var singleAttrValues = [
	// attr value double quotes
	/"([^"]*)"+/.source,
	// attr value, single quotes
	/'([^']*)'+/.source,
	// attr value, no quotes
	/([^\s"'=<>`]+)/.source];
	var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');
	
	// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	// but for Vue templates we can enforce a simple charset
	var ncname = '[a-zA-Z_][\\w\\-\\.]*';
	var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
	var startTagOpen = new RegExp('^<' + qnameCapture);
	var startTagClose = /^\s*(\/?)>/;
	var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
	var doctype = /^<!DOCTYPE [^>]+>/i;
	var comment = /^<!--/;
	var conditionalComment = /^<!\[/;
	
	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function (m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});
	
	// Special Elements (can contain anything)
	var isPlainTextElement = makeMap('script,style,textarea', true);
	var reCache = {};
	
	var decodingMap = {
	  '&lt;': '<',
	  '&gt;': '>',
	  '&quot;': '"',
	  '&amp;': '&',
	  '&#10;': '\n'
	};
	var encodedAttr = /&(?:lt|gt|quot|amp);/g;
	var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;
	
	// #5992
	var isIgnoreNewlineTag = makeMap('pre,textarea', true);
	var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
	  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
	};
	
	function decodeAttr(value, shouldDecodeNewlines) {
	  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
	  return value.replace(re, function (match) {
	    return decodingMap[match];
	  });
	}
	
	function parseHTML(html, options) {
	  var stack = [];
	  var expectHTML = options.expectHTML;
	  var isUnaryTag$$1 = options.isUnaryTag || no;
	  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
	  var index = 0;
	  var last, lastTag;
	  while (html) {
	    last = html;
	    // Make sure we're not in a plaintext content element like script/style
	    if (!lastTag || !isPlainTextElement(lastTag)) {
	      var textEnd = html.indexOf('<');
	      if (textEnd === 0) {
	        // Comment:
	        if (comment.test(html)) {
	          var commentEnd = html.indexOf('-->');
	
	          if (commentEnd >= 0) {
	            if (options.shouldKeepComment) {
	              options.comment(html.substring(4, commentEnd));
	            }
	            advance(commentEnd + 3);
	            continue;
	          }
	        }
	
	        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	        if (conditionalComment.test(html)) {
	          var conditionalEnd = html.indexOf(']>');
	
	          if (conditionalEnd >= 0) {
	            advance(conditionalEnd + 2);
	            continue;
	          }
	        }
	
	        // Doctype:
	        var doctypeMatch = html.match(doctype);
	        if (doctypeMatch) {
	          advance(doctypeMatch[0].length);
	          continue;
	        }
	
	        // End tag:
	        var endTagMatch = html.match(endTag);
	        if (endTagMatch) {
	          var curIndex = index;
	          advance(endTagMatch[0].length);
	          parseEndTag(endTagMatch[1], curIndex, index);
	          continue;
	        }
	
	        // Start tag:
	        var startTagMatch = parseStartTag();
	        if (startTagMatch) {
	          handleStartTag(startTagMatch);
	          if (shouldIgnoreFirstNewline(lastTag, html)) {
	            advance(1);
	          }
	          continue;
	        }
	      }
	
	      var text = void 0,
	          rest = void 0,
	          next = void 0;
	      if (textEnd >= 0) {
	        rest = html.slice(textEnd);
	        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
	          // < in plain text, be forgiving and treat it as text
	          next = rest.indexOf('<', 1);
	          if (next < 0) {
	            break;
	          }
	          textEnd += next;
	          rest = html.slice(textEnd);
	        }
	        text = html.substring(0, textEnd);
	        advance(textEnd);
	      }
	
	      if (textEnd < 0) {
	        text = html;
	        html = '';
	      }
	
	      if (options.chars && text) {
	        options.chars(text);
	      }
	    } else {
	      var endTagLength = 0;
	      var stackedTag = lastTag.toLowerCase();
	      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
	      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
	        endTagLength = endTag.length;
	        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
	          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	        }
	        if (shouldIgnoreFirstNewline(stackedTag, text)) {
	          text = text.slice(1);
	        }
	        if (options.chars) {
	          options.chars(text);
	        }
	        return '';
	      });
	      index += html.length - rest$1.length;
	      html = rest$1;
	      parseEndTag(stackedTag, index - endTagLength, index);
	    }
	
	    if (html === last) {
	      options.chars && options.chars(html);
	      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
	        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
	      }
	      break;
	    }
	  }
	
	  // Clean up any remaining tags
	  parseEndTag();
	
	  function advance(n) {
	    index += n;
	    html = html.substring(n);
	  }
	
	  function parseStartTag() {
	    var start = html.match(startTagOpen);
	    if (start) {
	      var match = {
	        tagName: start[1],
	        attrs: [],
	        start: index
	      };
	      advance(start[0].length);
	      var end, attr;
	      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
	        advance(attr[0].length);
	        match.attrs.push(attr);
	      }
	      if (end) {
	        match.unarySlash = end[1];
	        advance(end[0].length);
	        match.end = index;
	        return match;
	      }
	    }
	  }
	
	  function handleStartTag(match) {
	    var tagName = match.tagName;
	    var unarySlash = match.unarySlash;
	
	    if (expectHTML) {
	      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
	        parseEndTag(lastTag);
	      }
	      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
	        parseEndTag(tagName);
	      }
	    }
	
	    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
	
	    var l = match.attrs.length;
	    var attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      var args = match.attrs[i];
	      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	        if (args[3] === '') {
	          delete args[3];
	        }
	        if (args[4] === '') {
	          delete args[4];
	        }
	        if (args[5] === '') {
	          delete args[5];
	        }
	      }
	      var value = args[3] || args[4] || args[5] || '';
	      attrs[i] = {
	        name: args[1],
	        value: decodeAttr(value, options.shouldDecodeNewlines)
	      };
	    }
	
	    if (!unary) {
	      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
	      lastTag = tagName;
	    }
	
	    if (options.start) {
	      options.start(tagName, attrs, unary, match.start, match.end);
	    }
	  }
	
	  function parseEndTag(tagName, start, end) {
	    var pos, lowerCasedTagName;
	    if (start == null) {
	      start = index;
	    }
	    if (end == null) {
	      end = index;
	    }
	
	    if (tagName) {
	      lowerCasedTagName = tagName.toLowerCase();
	    }
	
	    // Find the closest opened tag of the same type
	    if (tagName) {
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
	          break;
	        }
	      }
	    } else {
	      // If no tag name is provided, clean shop
	      pos = 0;
	    }
	
	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (var i = stack.length - 1; i >= pos; i--) {
	        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
	          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
	        }
	        if (options.end) {
	          options.end(stack[i].tag, start, end);
	        }
	      }
	
	      // Remove the open elements from the stack
	      stack.length = pos;
	      lastTag = pos && stack[pos - 1].tag;
	    } else if (lowerCasedTagName === 'br') {
	      if (options.start) {
	        options.start(tagName, [], true, start, end);
	      }
	    } else if (lowerCasedTagName === 'p') {
	      if (options.start) {
	        options.start(tagName, [], false, start, end);
	      }
	      if (options.end) {
	        options.end(tagName, start, end);
	      }
	    }
	  }
	}
	
	/*  */
	
	var onRE = /^@|^v-on:/;
	var dirRE = /^v-|^@|^:/;
	var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
	var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
	
	var argRE = /:(.*)$/;
	var bindRE = /^:|^v-bind:/;
	var modifierRE = /\.[^.]+/g;
	
	var decodeHTMLCached = cached(he.decode);
	
	// configurable state
	var warn$2;
	var delimiters;
	var transforms;
	var preTransforms;
	var postTransforms;
	var platformIsPreTag;
	var platformMustUseProp;
	var platformGetTagNamespace;
	
	/**
	 * Convert HTML string to AST.
	 */
	function parse(template, options) {
	  warn$2 = options.warn || baseWarn;
	
	  platformIsPreTag = options.isPreTag || no;
	  platformMustUseProp = options.mustUseProp || no;
	  platformGetTagNamespace = options.getTagNamespace || no;
	
	  transforms = pluckModuleFunction(options.modules, 'transformNode');
	  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
	  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
	
	  delimiters = options.delimiters;
	
	  var stack = [];
	  var preserveWhitespace = options.preserveWhitespace !== false;
	  var root;
	  var currentParent;
	  var inVPre = false;
	  var inPre = false;
	  var warned = false;
	
	  function warnOnce(msg) {
	    if (!warned) {
	      warned = true;
	      warn$2(msg);
	    }
	  }
	
	  function endPre(element) {
	    // check pre state
	    if (element.pre) {
	      inVPre = false;
	    }
	    if (platformIsPreTag(element.tag)) {
	      inPre = false;
	    }
	  }
	
	  parseHTML(template, {
	    warn: warn$2,
	    expectHTML: options.expectHTML,
	    isUnaryTag: options.isUnaryTag,
	    canBeLeftOpenTag: options.canBeLeftOpenTag,
	    shouldDecodeNewlines: options.shouldDecodeNewlines,
	    shouldKeepComment: options.comments,
	    start: function start(tag, attrs, unary) {
	      // check namespace.
	      // inherit parent ns if there is one
	      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);
	
	      // handle IE svg bug
	      /* istanbul ignore if */
	      if (isIE && ns === 'svg') {
	        attrs = guardIESVGBug(attrs);
	      }
	
	      var element = {
	        type: 1,
	        tag: tag,
	        attrsList: attrs,
	        attrsMap: makeAttrsMap(attrs),
	        parent: currentParent,
	        children: []
	      };
	      if (ns) {
	        element.ns = ns;
	      }
	
	      if (isForbiddenTag(element) && !isServerRendering()) {
	        element.forbidden = true;
	        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
	      }
	
	      // apply pre-transforms
	      for (var i = 0; i < preTransforms.length; i++) {
	        preTransforms[i](element, options);
	      }
	
	      if (!inVPre) {
	        processPre(element);
	        if (element.pre) {
	          inVPre = true;
	        }
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = true;
	      }
	      if (inVPre) {
	        processRawAttrs(element);
	      } else {
	        processFor(element);
	        processIf(element);
	        processOnce(element);
	        processKey(element);
	
	        // determine whether this is a plain element after
	        // removing structural attributes
	        element.plain = !element.key && !attrs.length;
	
	        processRef(element);
	        processSlot(element);
	        processComponent(element);
	        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
	          transforms[i$1](element, options);
	        }
	        processAttrs(element);
	      }
	
	      function checkRootConstraints(el) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (el.tag === 'slot' || el.tag === 'template') {
	            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
	          }
	          if (el.attrsMap.hasOwnProperty('v-for')) {
	            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
	          }
	        }
	      }
	
	      // tree management
	      if (!root) {
	        root = element;
	        checkRootConstraints(root);
	      } else if (!stack.length) {
	        // allow root elements with v-if, v-else-if and v-else
	        if (root.if && (element.elseif || element.else)) {
	          checkRootConstraints(element);
	          addIfCondition(root, {
	            exp: element.elseif,
	            block: element
	          });
	        } else if (process.env.NODE_ENV !== 'production') {
	          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
	        }
	      }
	      if (currentParent && !element.forbidden) {
	        if (element.elseif || element.else) {
	          processIfConditions(element, currentParent);
	        } else if (element.slotScope) {
	          // scoped slot
	          currentParent.plain = false;
	          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	        } else {
	          currentParent.children.push(element);
	          element.parent = currentParent;
	        }
	      }
	      if (!unary) {
	        currentParent = element;
	        stack.push(element);
	      } else {
	        endPre(element);
	      }
	      // apply post-transforms
	      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
	        postTransforms[i$2](element, options);
	      }
	    },
	
	    end: function end() {
	      // remove trailing whitespace
	      var element = stack[stack.length - 1];
	      var lastNode = element.children[element.children.length - 1];
	      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
	        element.children.pop();
	      }
	      // pop stack
	      stack.length -= 1;
	      currentParent = stack[stack.length - 1];
	      endPre(element);
	    },
	
	    chars: function chars(text) {
	      if (!currentParent) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (text === template) {
	            warnOnce('Component template requires a root element, rather than just text.');
	          } else if (text = text.trim()) {
	            warnOnce("text \"" + text + "\" outside root element will be ignored.");
	          }
	        }
	        return;
	      }
	      // IE textarea placeholder bug
	      /* istanbul ignore if */
	      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
	        return;
	      }
	      var children = currentParent.children;
	      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
	      // only preserve whitespace if its not right after a starting tag
	      : preserveWhitespace && children.length ? ' ' : '';
	      if (text) {
	        var expression;
	        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
	          children.push({
	            type: 2,
	            expression: expression,
	            text: text
	          });
	        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
	          children.push({
	            type: 3,
	            text: text
	          });
	        }
	      }
	    },
	    comment: function comment(text) {
	      currentParent.children.push({
	        type: 3,
	        text: text,
	        isComment: true
	      });
	    }
	  });
	  return root;
	}
	
	function processPre(el) {
	  if (getAndRemoveAttr(el, 'v-pre') != null) {
	    el.pre = true;
	  }
	}
	
	function processRawAttrs(el) {
	  var l = el.attrsList.length;
	  if (l) {
	    var attrs = el.attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      attrs[i] = {
	        name: el.attrsList[i].name,
	        value: JSON.stringify(el.attrsList[i].value)
	      };
	    }
	  } else if (!el.pre) {
	    // non root node in pre blocks with no attributes
	    el.plain = true;
	  }
	}
	
	function processKey(el) {
	  var exp = getBindingAttr(el, 'key');
	  if (exp) {
	    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
	      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
	    }
	    el.key = exp;
	  }
	}
	
	function processRef(el) {
	  var ref = getBindingAttr(el, 'ref');
	  if (ref) {
	    el.ref = ref;
	    el.refInFor = checkInFor(el);
	  }
	}
	
	function processFor(el) {
	  var exp;
	  if (exp = getAndRemoveAttr(el, 'v-for')) {
	    var inMatch = exp.match(forAliasRE);
	    if (!inMatch) {
	      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
	      return;
	    }
	    el.for = inMatch[2].trim();
	    var alias = inMatch[1].trim();
	    var iteratorMatch = alias.match(forIteratorRE);
	    if (iteratorMatch) {
	      el.alias = iteratorMatch[1].trim();
	      el.iterator1 = iteratorMatch[2].trim();
	      if (iteratorMatch[3]) {
	        el.iterator2 = iteratorMatch[3].trim();
	      }
	    } else {
	      el.alias = alias;
	    }
	  }
	}
	
	function processIf(el) {
	  var exp = getAndRemoveAttr(el, 'v-if');
	  if (exp) {
	    el.if = exp;
	    addIfCondition(el, {
	      exp: exp,
	      block: el
	    });
	  } else {
	    if (getAndRemoveAttr(el, 'v-else') != null) {
	      el.else = true;
	    }
	    var elseif = getAndRemoveAttr(el, 'v-else-if');
	    if (elseif) {
	      el.elseif = elseif;
	    }
	  }
	}
	
	function processIfConditions(el, parent) {
	  var prev = findPrevElement(parent.children);
	  if (prev && prev.if) {
	    addIfCondition(prev, {
	      exp: el.elseif,
	      block: el
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
	  }
	}
	
	function findPrevElement(children) {
	  var i = children.length;
	  while (i--) {
	    if (children[i].type === 1) {
	      return children[i];
	    } else {
	      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
	        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
	      }
	      children.pop();
	    }
	  }
	}
	
	function addIfCondition(el, condition) {
	  if (!el.ifConditions) {
	    el.ifConditions = [];
	  }
	  el.ifConditions.push(condition);
	}
	
	function processOnce(el) {
	  var once$$1 = getAndRemoveAttr(el, 'v-once');
	  if (once$$1 != null) {
	    el.once = true;
	  }
	}
	
	function processSlot(el) {
	  if (el.tag === 'slot') {
	    el.slotName = getBindingAttr(el, 'name');
	    if (process.env.NODE_ENV !== 'production' && el.key) {
	      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
	    }
	  } else {
	    var slotTarget = getBindingAttr(el, 'slot');
	    if (slotTarget) {
	      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
	    }
	    if (el.tag === 'template') {
	      el.slotScope = getAndRemoveAttr(el, 'scope');
	    }
	  }
	}
	
	function processComponent(el) {
	  var binding;
	  if (binding = getBindingAttr(el, 'is')) {
	    el.component = binding;
	  }
	  if (getAndRemoveAttr(el, 'inline-template') != null) {
	    el.inlineTemplate = true;
	  }
	}
	
	function processAttrs(el) {
	  var list = el.attrsList;
	  var i, l, name, rawName, value, modifiers, isProp;
	  for (i = 0, l = list.length; i < l; i++) {
	    name = rawName = list[i].name;
	    value = list[i].value;
	    if (dirRE.test(name)) {
	      // mark element as dynamic
	      el.hasBindings = true;
	      // modifiers
	      modifiers = parseModifiers(name);
	      if (modifiers) {
	        name = name.replace(modifierRE, '');
	      }
	      if (bindRE.test(name)) {
	        // v-bind
	        name = name.replace(bindRE, '');
	        value = parseFilters(value);
	        isProp = false;
	        if (modifiers) {
	          if (modifiers.prop) {
	            isProp = true;
	            name = camelize(name);
	            if (name === 'innerHtml') {
	              name = 'innerHTML';
	            }
	          }
	          if (modifiers.camel) {
	            name = camelize(name);
	          }
	          if (modifiers.sync) {
	            addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
	          }
	        }
	        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
	          addProp(el, name, value);
	        } else {
	          addAttr(el, name, value);
	        }
	      } else if (onRE.test(name)) {
	        // v-on
	        name = name.replace(onRE, '');
	        addHandler(el, name, value, modifiers, false, warn$2);
	      } else {
	        // normal directives
	        name = name.replace(dirRE, '');
	        // parse arg
	        var argMatch = name.match(argRE);
	        var arg = argMatch && argMatch[1];
	        if (arg) {
	          name = name.slice(0, -(arg.length + 1));
	        }
	        addDirective(el, name, rawName, value, arg, modifiers);
	        if (process.env.NODE_ENV !== 'production' && name === 'model') {
	          checkForAliasModel(el, value);
	        }
	      }
	    } else {
	      // literal attribute
	      if (process.env.NODE_ENV !== 'production') {
	        var expression = parseText(value, delimiters);
	        if (expression) {
	          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
	        }
	      }
	      addAttr(el, name, JSON.stringify(value));
	    }
	  }
	}
	
	function checkInFor(el) {
	  var parent = el;
	  while (parent) {
	    if (parent.for !== undefined) {
	      return true;
	    }
	    parent = parent.parent;
	  }
	  return false;
	}
	
	function parseModifiers(name) {
	  var match = name.match(modifierRE);
	  if (match) {
	    var ret = {};
	    match.forEach(function (m) {
	      ret[m.slice(1)] = true;
	    });
	    return ret;
	  }
	}
	
	function makeAttrsMap(attrs) {
	  var map = {};
	  for (var i = 0, l = attrs.length; i < l; i++) {
	    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
	      warn$2('duplicate attribute: ' + attrs[i].name);
	    }
	    map[attrs[i].name] = attrs[i].value;
	  }
	  return map;
	}
	
	// for script (e.g. type="x/template") or style, do not decode content
	function isTextTag(el) {
	  return el.tag === 'script' || el.tag === 'style';
	}
	
	function isForbiddenTag(el) {
	  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
	}
	
	var ieNSBug = /^xmlns:NS\d+/;
	var ieNSPrefix = /^NS\d+:/;
	
	/* istanbul ignore next */
	function guardIESVGBug(attrs) {
	  var res = [];
	  for (var i = 0; i < attrs.length; i++) {
	    var attr = attrs[i];
	    if (!ieNSBug.test(attr.name)) {
	      attr.name = attr.name.replace(ieNSPrefix, '');
	      res.push(attr);
	    }
	  }
	  return res;
	}
	
	function checkForAliasModel(el, value) {
	  var _el = el;
	  while (_el) {
	    if (_el.for && _el.alias === value) {
	      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
	    }
	    _el = _el.parent;
	  }
	}
	
	/*  */
	
	var isStaticKey;
	var isPlatformReservedTag;
	
	var genStaticKeysCached = cached(genStaticKeys$1);
	
	/**
	 * Goal of the optimizer: walk the generated template AST tree
	 * and detect sub-trees that are purely static, i.e. parts of
	 * the DOM that never needs to change.
	 *
	 * Once we detect these sub-trees, we can:
	 *
	 * 1. Hoist them into constants, so that we no longer need to
	 *    create fresh nodes for them on each re-render;
	 * 2. Completely skip them in the patching process.
	 */
	function optimize(root, options) {
	  if (!root) {
	    return;
	  }
	  isStaticKey = genStaticKeysCached(options.staticKeys || '');
	  isPlatformReservedTag = options.isReservedTag || no;
	  // first pass: mark all non-static nodes.
	  markStatic$1(root);
	  // second pass: mark static roots.
	  markStaticRoots(root, false);
	}
	
	function genStaticKeys$1(keys) {
	  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
	}
	
	function markStatic$1(node) {
	  node.static = isStatic(node);
	  if (node.type === 1) {
	    // do not make component slot content static. this avoids
	    // 1. components not able to mutate slot nodes
	    // 2. static slot content fails for hot-reloading
	    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
	      return;
	    }
	    for (var i = 0, l = node.children.length; i < l; i++) {
	      var child = node.children[i];
	      markStatic$1(child);
	      if (!child.static) {
	        node.static = false;
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        var block = node.ifConditions[i$1].block;
	        markStatic$1(block);
	        if (!block.static) {
	          node.static = false;
	        }
	      }
	    }
	  }
	}
	
	function markStaticRoots(node, isInFor) {
	  if (node.type === 1) {
	    if (node.static || node.once) {
	      node.staticInFor = isInFor;
	    }
	    // For a node to qualify as a static root, it should have children that
	    // are not just static text. Otherwise the cost of hoisting out will
	    // outweigh the benefits and it's better off to just always render it fresh.
	    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
	      node.staticRoot = true;
	      return;
	    } else {
	      node.staticRoot = false;
	    }
	    if (node.children) {
	      for (var i = 0, l = node.children.length; i < l; i++) {
	        markStaticRoots(node.children[i], isInFor || !!node.for);
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        markStaticRoots(node.ifConditions[i$1].block, isInFor);
	      }
	    }
	  }
	}
	
	function isStatic(node) {
	  if (node.type === 2) {
	    // expression
	    return false;
	  }
	  if (node.type === 3) {
	    // text
	    return true;
	  }
	  return !!(node.pre || !node.hasBindings && // no dynamic bindings
	  !node.if && !node.for && // not v-if or v-for or v-else
	  !isBuiltInTag(node.tag) && // not a built-in
	  isPlatformReservedTag(node.tag) && // not a component
	  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
	}
	
	function isDirectChildOfTemplateFor(node) {
	  while (node.parent) {
	    node = node.parent;
	    if (node.tag !== 'template') {
	      return false;
	    }
	    if (node.for) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
	var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  'delete': [8, 46]
	};
	
	// #4868: modifiers that prevent the execution of the listener
	// need to explicitly return null so that we can determine whether to remove
	// the listener for .once
	var genGuard = function genGuard(condition) {
	  return "if(" + condition + ")return null;";
	};
	
	var modifierCode = {
	  stop: '$event.stopPropagation();',
	  prevent: '$event.preventDefault();',
	  self: genGuard("$event.target !== $event.currentTarget"),
	  ctrl: genGuard("!$event.ctrlKey"),
	  shift: genGuard("!$event.shiftKey"),
	  alt: genGuard("!$event.altKey"),
	  meta: genGuard("!$event.metaKey"),
	  left: genGuard("'button' in $event && $event.button !== 0"),
	  middle: genGuard("'button' in $event && $event.button !== 1"),
	  right: genGuard("'button' in $event && $event.button !== 2")
	};
	
	function genHandlers(events, isNative, warn) {
	  var res = isNative ? 'nativeOn:{' : 'on:{';
	  for (var name in events) {
	    var handler = events[name];
	    // #5330: warn click.right, since right clicks do not actually fire click events.
	    if (process.env.NODE_ENV !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {
	      warn("Use \"contextmenu\" instead of \"click.right\" since right clicks " + "do not actually fire \"click\" events.");
	    }
	    res += "\"" + name + "\":" + genHandler(name, handler) + ",";
	  }
	  return res.slice(0, -1) + '}';
	}
	
	function genHandler(name, handler) {
	  if (!handler) {
	    return 'function(){}';
	  }
	
	  if (Array.isArray(handler)) {
	    return "[" + handler.map(function (handler) {
	      return genHandler(name, handler);
	    }).join(',') + "]";
	  }
	
	  var isMethodPath = simplePathRE.test(handler.value);
	  var isFunctionExpression = fnExpRE.test(handler.value);
	
	  if (!handler.modifiers) {
	    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
	  } else {
	    var code = '';
	    var genModifierCode = '';
	    var keys = [];
	    for (var key in handler.modifiers) {
	      if (modifierCode[key]) {
	        genModifierCode += modifierCode[key];
	        // left/right
	        if (keyCodes[key]) {
	          keys.push(key);
	        }
	      } else {
	        keys.push(key);
	      }
	    }
	    if (keys.length) {
	      code += genKeyFilter(keys);
	    }
	    // Make sure modifiers like prevent and stop get executed after key filtering
	    if (genModifierCode) {
	      code += genModifierCode;
	    }
	    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
	    return "function($event){" + code + handlerCode + "}";
	  }
	}
	
	function genKeyFilter(keys) {
	  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
	}
	
	function genFilterCode(key) {
	  var keyVal = parseInt(key, 10);
	  if (keyVal) {
	    return "$event.keyCode!==" + keyVal;
	  }
	  var alias = keyCodes[key];
	  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
	}
	
	/*  */
	
	function on(el, dir) {
	  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {
	    warn("v-on without argument does not support modifiers.");
	  }
	  el.wrapListeners = function (code) {
	    return "_g(" + code + "," + dir.value + ")";
	  };
	}
	
	/*  */
	
	function bind$1(el, dir) {
	  el.wrapData = function (code) {
	    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
	  };
	}
	
	/*  */
	
	var baseDirectives = {
	  on: on,
	  bind: bind$1,
	  cloak: noop
	};
	
	/*  */
	
	var CodegenState = function CodegenState(options) {
	  this.options = options;
	  this.warn = options.warn || baseWarn;
	  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
	  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
	  this.directives = extend(extend({}, baseDirectives), options.directives);
	  var isReservedTag = options.isReservedTag || no;
	  this.maybeComponent = function (el) {
	    return !isReservedTag(el.tag);
	  };
	  this.onceId = 0;
	  this.staticRenderFns = [];
	};
	
	function generate(ast, options) {
	  var state = new CodegenState(options);
	  var code = ast ? genElement(ast, state) : '_c("div")';
	  return {
	    render: "with(this){return " + code + "}",
	    staticRenderFns: state.staticRenderFns
	  };
	}
	
	function genElement(el, state) {
	  if (el.staticRoot && !el.staticProcessed) {
	    return genStatic(el, state);
	  } else if (el.once && !el.onceProcessed) {
	    return genOnce(el, state);
	  } else if (el.for && !el.forProcessed) {
	    return genFor(el, state);
	  } else if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.tag === 'template' && !el.slotTarget) {
	    return genChildren(el, state) || 'void 0';
	  } else if (el.tag === 'slot') {
	    return genSlot(el, state);
	  } else {
	    // component or element
	    var code;
	    if (el.component) {
	      code = genComponent(el.component, el, state);
	    } else {
	      var data = el.plain ? undefined : genData$2(el, state);
	
	      var children = el.inlineTemplate ? null : genChildren(el, state, true);
	      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
	    }
	    // module transforms
	    for (var i = 0; i < state.transforms.length; i++) {
	      code = state.transforms[i](el, code);
	    }
	    return code;
	  }
	}
	
	// hoist static sub-trees out
	function genStatic(el, state) {
	  el.staticProcessed = true;
	  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
	  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
	}
	
	// v-once
	function genOnce(el, state) {
	  el.onceProcessed = true;
	  if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.staticInFor) {
	    var key = '';
	    var parent = el.parent;
	    while (parent) {
	      if (parent.for) {
	        key = parent.key;
	        break;
	      }
	      parent = parent.parent;
	    }
	    if (!key) {
	      process.env.NODE_ENV !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
	      return genElement(el, state);
	    }
	    return "_o(" + genElement(el, state) + "," + state.onceId++ + (key ? "," + key : "") + ")";
	  } else {
	    return genStatic(el, state);
	  }
	}
	
	function genIf(el, state, altGen, altEmpty) {
	  el.ifProcessed = true; // avoid recursion
	  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
	}
	
	function genIfConditions(conditions, state, altGen, altEmpty) {
	  if (!conditions.length) {
	    return altEmpty || '_e()';
	  }
	
	  var condition = conditions.shift();
	  if (condition.exp) {
	    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
	  } else {
	    return "" + genTernaryExp(condition.block);
	  }
	
	  // v-if with v-once should generate code like (a)?_m(0):_m(1)
	  function genTernaryExp(el) {
	    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
	  }
	}
	
	function genFor(el, state, altGen, altHelper) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	
	  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
	    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
	    );
	  }
	
	  el.forProcessed = true; // avoid recursion
	  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
	}
	
	function genData$2(el, state) {
	  var data = '{';
	
	  // directives first.
	  // directives may mutate the el's other properties before they are generated.
	  var dirs = genDirectives(el, state);
	  if (dirs) {
	    data += dirs + ',';
	  }
	
	  // key
	  if (el.key) {
	    data += "key:" + el.key + ",";
	  }
	  // ref
	  if (el.ref) {
	    data += "ref:" + el.ref + ",";
	  }
	  if (el.refInFor) {
	    data += "refInFor:true,";
	  }
	  // pre
	  if (el.pre) {
	    data += "pre:true,";
	  }
	  // record original tag name for components using "is" attribute
	  if (el.component) {
	    data += "tag:\"" + el.tag + "\",";
	  }
	  // module data generation functions
	  for (var i = 0; i < state.dataGenFns.length; i++) {
	    data += state.dataGenFns[i](el);
	  }
	  // attributes
	  if (el.attrs) {
	    data += "attrs:{" + genProps(el.attrs) + "},";
	  }
	  // DOM props
	  if (el.props) {
	    data += "domProps:{" + genProps(el.props) + "},";
	  }
	  // event handlers
	  if (el.events) {
	    data += genHandlers(el.events, false, state.warn) + ",";
	  }
	  if (el.nativeEvents) {
	    data += genHandlers(el.nativeEvents, true, state.warn) + ",";
	  }
	  // slot target
	  if (el.slotTarget) {
	    data += "slot:" + el.slotTarget + ",";
	  }
	  // scoped slots
	  if (el.scopedSlots) {
	    data += genScopedSlots(el.scopedSlots, state) + ",";
	  }
	  // component v-model
	  if (el.model) {
	    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
	  }
	  // inline-template
	  if (el.inlineTemplate) {
	    var inlineTemplate = genInlineTemplate(el, state);
	    if (inlineTemplate) {
	      data += inlineTemplate + ",";
	    }
	  }
	  data = data.replace(/,$/, '') + '}';
	  // v-bind data wrap
	  if (el.wrapData) {
	    data = el.wrapData(data);
	  }
	  // v-on data wrap
	  if (el.wrapListeners) {
	    data = el.wrapListeners(data);
	  }
	  return data;
	}
	
	function genDirectives(el, state) {
	  var dirs = el.directives;
	  if (!dirs) {
	    return;
	  }
	  var res = 'directives:[';
	  var hasRuntime = false;
	  var i, l, dir, needRuntime;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    dir = dirs[i];
	    needRuntime = true;
	    var gen = state.directives[dir.name];
	    if (gen) {
	      // compile-time directive that manipulates AST.
	      // returns true if it also needs a runtime counterpart.
	      needRuntime = !!gen(el, dir, state.warn);
	    }
	    if (needRuntime) {
	      hasRuntime = true;
	      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
	    }
	  }
	  if (hasRuntime) {
	    return res.slice(0, -1) + ']';
	  }
	}
	
	function genInlineTemplate(el, state) {
	  var ast = el.children[0];
	  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
	    state.warn('Inline-template components must have exactly one child element.');
	  }
	  if (ast.type === 1) {
	    var inlineRenderFns = generate(ast, state.options);
	    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
	      return "function(){" + code + "}";
	    }).join(',') + "]}";
	  }
	}
	
	function genScopedSlots(slots, state) {
	  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
	    return genScopedSlot(key, slots[key], state);
	  }).join(',') + "])";
	}
	
	function genScopedSlot(key, el, state) {
	  if (el.for && !el.forProcessed) {
	    return genForScopedSlot(key, el, state);
	  }
	  return "{key:" + key + ",fn:function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + "}}";
	}
	
	function genForScopedSlot(key, el, state) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	  el.forProcessed = true; // avoid recursion
	  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
	}
	
	function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
	  var children = el.children;
	  if (children.length) {
	    var el$1 = children[0];
	    // optimize single v-for
	    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
	      return (altGenElement || genElement)(el$1, state);
	    }
	    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
	    var gen = altGenNode || genNode;
	    return "[" + children.map(function (c) {
	      return gen(c, state);
	    }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
	  }
	}
	
	// determine the normalization needed for the children array.
	// 0: no normalization needed
	// 1: simple normalization needed (possible 1-level deep nested array)
	// 2: full normalization needed
	function getNormalizationType(children, maybeComponent) {
	  var res = 0;
	  for (var i = 0; i < children.length; i++) {
	    var el = children[i];
	    if (el.type !== 1) {
	      continue;
	    }
	    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return needsNormalization(c.block);
	    })) {
	      res = 2;
	      break;
	    }
	    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return maybeComponent(c.block);
	    })) {
	      res = 1;
	    }
	  }
	  return res;
	}
	
	function needsNormalization(el) {
	  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
	}
	
	function genNode(node, state) {
	  if (node.type === 1) {
	    return genElement(node, state);
	  }if (node.type === 3 && node.isComment) {
	    return genComment(node);
	  } else {
	    return genText(node);
	  }
	}
	
	function genText(text) {
	  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
	  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
	}
	
	function genComment(comment) {
	  return "_e(" + JSON.stringify(comment.text) + ")";
	}
	
	function genSlot(el, state) {
	  var slotName = el.slotName || '"default"';
	  var children = genChildren(el, state);
	  var res = "_t(" + slotName + (children ? "," + children : '');
	  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
	    return camelize(a.name) + ":" + a.value;
	  }).join(',') + "}";
	  var bind$$1 = el.attrsMap['v-bind'];
	  if ((attrs || bind$$1) && !children) {
	    res += ",null";
	  }
	  if (attrs) {
	    res += "," + attrs;
	  }
	  if (bind$$1) {
	    res += (attrs ? '' : ',null') + "," + bind$$1;
	  }
	  return res + ')';
	}
	
	// componentName is el.component, take it as argument to shun flow's pessimistic refinement
	function genComponent(componentName, el, state) {
	  var children = el.inlineTemplate ? null : genChildren(el, state, true);
	  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
	}
	
	function genProps(props) {
	  var res = '';
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
	  }
	  return res.slice(0, -1);
	}
	
	// #3895, #4268
	function transformSpecialNewlines(text) {
	  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
	}
	
	/*  */
	
	// these keywords should not appear inside expressions, but operators like
	// typeof, instanceof and in are allowed
	var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');
	
	// these unary operators should not be used as property/method names
	var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');
	
	// check valid identifier for v-for
	var identRE = /[A-Za-z_$][\w$]*/;
	
	// strip strings in expressions
	var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
	
	// detect problematic expressions in a template
	function detectErrors(ast) {
	  var errors = [];
	  if (ast) {
	    checkNode(ast, errors);
	  }
	  return errors;
	}
	
	function checkNode(node, errors) {
	  if (node.type === 1) {
	    for (var name in node.attrsMap) {
	      if (dirRE.test(name)) {
	        var value = node.attrsMap[name];
	        if (value) {
	          if (name === 'v-for') {
	            checkFor(node, "v-for=\"" + value + "\"", errors);
	          } else if (onRE.test(name)) {
	            checkEvent(value, name + "=\"" + value + "\"", errors);
	          } else {
	            checkExpression(value, name + "=\"" + value + "\"", errors);
	          }
	        }
	      }
	    }
	    if (node.children) {
	      for (var i = 0; i < node.children.length; i++) {
	        checkNode(node.children[i], errors);
	      }
	    }
	  } else if (node.type === 2) {
	    checkExpression(node.expression, node.text, errors);
	  }
	}
	
	function checkEvent(exp, text, errors) {
	  var stipped = exp.replace(stripStringRE, '');
	  var keywordMatch = stipped.match(unaryOperatorsRE);
	  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
	    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	  }
	  checkExpression(exp, text, errors);
	}
	
	function checkFor(node, text, errors) {
	  checkExpression(node.for || '', text, errors);
	  checkIdentifier(node.alias, 'v-for alias', text, errors);
	  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
	  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
	}
	
	function checkIdentifier(ident, type, text, errors) {
	  if (typeof ident === 'string' && !identRE.test(ident)) {
	    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
	  }
	}
	
	function checkExpression(exp, text, errors) {
	  try {
	    new Function("return " + exp);
	  } catch (e) {
	    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
	    if (keywordMatch) {
	      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	    } else {
	      errors.push("invalid expression: " + text.trim());
	    }
	  }
	}
	
	/*  */
	
	function createFunction(code, errors) {
	  try {
	    return new Function(code);
	  } catch (err) {
	    errors.push({ err: err, code: code });
	    return noop;
	  }
	}
	
	function createCompileToFunctionFn(compile) {
	  var cache = Object.create(null);
	
	  return function compileToFunctions(template, options, vm) {
	    options = options || {};
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      // detect possible CSP restriction
	      try {
	        new Function('return 1');
	      } catch (e) {
	        if (e.toString().match(/unsafe-eval|CSP/)) {
	          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
	        }
	      }
	    }
	
	    // check cache
	    var key = options.delimiters ? String(options.delimiters) + template : template;
	    if (cache[key]) {
	      return cache[key];
	    }
	
	    // compile
	    var compiled = compile(template, options);
	
	    // check compilation errors/tips
	    if (process.env.NODE_ENV !== 'production') {
	      if (compiled.errors && compiled.errors.length) {
	        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
	          return "- " + e;
	        }).join('\n') + '\n', vm);
	      }
	      if (compiled.tips && compiled.tips.length) {
	        compiled.tips.forEach(function (msg) {
	          return tip(msg, vm);
	        });
	      }
	    }
	
	    // turn code into functions
	    var res = {};
	    var fnGenErrors = [];
	    res.render = createFunction(compiled.render, fnGenErrors);
	    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
	      return createFunction(code, fnGenErrors);
	    });
	
	    // check function generation errors.
	    // this should only happen if there is a bug in the compiler itself.
	    // mostly for codegen development use
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
	        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
	          var err = ref.err;
	          var code = ref.code;
	
	          return err.toString() + " in\n\n" + code + "\n";
	        }).join('\n'), vm);
	      }
	    }
	
	    return cache[key] = res;
	  };
	}
	
	/*  */
	
	function createCompilerCreator(baseCompile) {
	  return function createCompiler(baseOptions) {
	    function compile(template, options) {
	      var finalOptions = Object.create(baseOptions);
	      var errors = [];
	      var tips = [];
	      finalOptions.warn = function (msg, tip) {
	        (tip ? tips : errors).push(msg);
	      };
	
	      if (options) {
	        // merge custom modules
	        if (options.modules) {
	          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
	        }
	        // merge custom directives
	        if (options.directives) {
	          finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
	        }
	        // copy other options
	        for (var key in options) {
	          if (key !== 'modules' && key !== 'directives') {
	            finalOptions[key] = options[key];
	          }
	        }
	      }
	
	      var compiled = baseCompile(template, finalOptions);
	      if (process.env.NODE_ENV !== 'production') {
	        errors.push.apply(errors, detectErrors(compiled.ast));
	      }
	      compiled.errors = errors;
	      compiled.tips = tips;
	      return compiled;
	    }
	
	    return {
	      compile: compile,
	      compileToFunctions: createCompileToFunctionFn(compile)
	    };
	  };
	}
	
	/*  */
	
	// `createCompilerCreator` allows creating compilers that use alternative
	// parser/optimizer/codegen, e.g the SSR optimizing compiler.
	// Here we just export a default compiler using the default parts.
	var createCompiler = createCompilerCreator(function baseCompile(template, options) {
	  var ast = parse(template.trim(), options);
	  optimize(ast, options);
	  var code = generate(ast, options);
	  return {
	    ast: ast,
	    render: code.render,
	    staticRenderFns: code.staticRenderFns
	  };
	});
	
	/*  */
	
	var ref$1 = createCompiler(baseOptions);
	var compileToFunctions = ref$1.compileToFunctions;
	
	/*  */
	
	var idToTemplate = cached(function (id) {
	  var el = query(id);
	  return el && el.innerHTML;
	});
	
	var mount = Vue$3.prototype.$mount;
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && query(el);
	
	  /* istanbul ignore if */
	  if (el === document.body || el === document.documentElement) {
	    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
	    return this;
	  }
	
	  var options = this.$options;
	  // resolve template/el and convert to render function
	  if (!options.render) {
	    var template = options.template;
	    if (template) {
	      if (typeof template === 'string') {
	        if (template.charAt(0) === '#') {
	          template = idToTemplate(template);
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !template) {
	            warn("Template element not found or is empty: " + options.template, this);
	          }
	        }
	      } else if (template.nodeType) {
	        template = template.innerHTML;
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          warn('invalid template option:' + template, this);
	        }
	        return this;
	      }
	    } else if (el) {
	      template = getOuterHTML(el);
	    }
	    if (template) {
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile');
	      }
	
	      var ref = compileToFunctions(template, {
	        shouldDecodeNewlines: shouldDecodeNewlines,
	        delimiters: options.delimiters,
	        comments: options.comments
	      }, this);
	      var render = ref.render;
	      var staticRenderFns = ref.staticRenderFns;
	      options.render = render;
	      options.staticRenderFns = staticRenderFns;
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile end');
	        measure(this._name + " compile", 'compile', 'compile end');
	      }
	    }
	  }
	  return mount.call(this, el, hydrating);
	};
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 */
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	Vue$3.compile = compileToFunctions;
	
	exports.default = Vue$3;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) {
	    return [];
	};
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, module) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
	 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	
	(function (definition) {
	    "use strict";
	
	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.
	
	    // Montage Require
	
	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);
	
	        // CommonJS
	    } else if (( false ? "undefined" : _typeof(exports)) === "object" && ( false ? "undefined" : _typeof(module)) === "object") {
	        module.exports = definition();
	
	        // RequireJS
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	        // SES (Secure EcmaScript)
	    } else if (typeof ses !== "undefined") {
	        if (!ses.ok()) {
	            return;
	        } else {
	            ses.makeQ = definition;
	        }
	
	        // <script>
	    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
	        // Prefer window over self for add-on scripts. Use self for
	        // non-windowed contexts.
	        var global = typeof window !== "undefined" ? window : self;
	
	        // Get the `window` object, save the previous Q global
	        // and initialize Q as a global.
	        var previousQ = global.Q;
	        global.Q = definition();
	
	        // Add a noConflict function so Q can be removed from the
	        // global namespace.
	        global.Q.noConflict = function () {
	            global.Q = previousQ;
	            return this;
	        };
	    } else {
	        throw new Error("This environment was not anticipated by Q. Please file a bug.");
	    }
	})(function () {
	    "use strict";
	
	    var hasStacks = false;
	    try {
	        throw new Error();
	    } catch (e) {
	        hasStacks = !!e.stack;
	    }
	
	    // All code after this point will be filtered from stack traces reported
	    // by Q.
	    var qStartingLine = captureLine();
	    var qFileName;
	
	    // shims
	
	    // used for fallback in "allResolved"
	    var noop = function noop() {};
	
	    // Use the fastest possible means to execute a task in a future turn
	    // of the event loop.
	    var nextTick = function () {
	        // linked list of tasks (single, with head node)
	        var head = { task: void 0, next: null };
	        var tail = head;
	        var flushing = false;
	        var requestTick = void 0;
	        var isNodeJS = false;
	        // queue for late tasks, used by unhandled rejection tracking
	        var laterQueue = [];
	
	        function flush() {
	            /* jshint loopfunc: true */
	            var task, domain;
	
	            while (head.next) {
	                head = head.next;
	                task = head.task;
	                head.task = void 0;
	                domain = head.domain;
	
	                if (domain) {
	                    head.domain = void 0;
	                    domain.enter();
	                }
	                runSingle(task, domain);
	            }
	            while (laterQueue.length) {
	                task = laterQueue.pop();
	                runSingle(task);
	            }
	            flushing = false;
	        }
	        // runs a single function in the async queue
	        function runSingle(task, domain) {
	            try {
	                task();
	            } catch (e) {
	                if (isNodeJS) {
	                    // In node, uncaught exceptions are considered fatal errors.
	                    // Re-throw them synchronously to interrupt flushing!
	
	                    // Ensure continuation if the uncaught exception is suppressed
	                    // listening "uncaughtException" events (as domains does).
	                    // Continue in next event to avoid tick recursion.
	                    if (domain) {
	                        domain.exit();
	                    }
	                    setTimeout(flush, 0);
	                    if (domain) {
	                        domain.enter();
	                    }
	
	                    throw e;
	                } else {
	                    // In browsers, uncaught exceptions are not fatal.
	                    // Re-throw them asynchronously to avoid slow-downs.
	                    setTimeout(function () {
	                        throw e;
	                    }, 0);
	                }
	            }
	
	            if (domain) {
	                domain.exit();
	            }
	        }
	
	        nextTick = function nextTick(task) {
	            tail = tail.next = {
	                task: task,
	                domain: isNodeJS && process.domain,
	                next: null
	            };
	
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.toString() === "[object process]" && process.nextTick) {
	            // Ensure Q is in a real Node environment, with a `process.nextTick`.
	            // To see through fake Node environments:
	            // * Mocha test runner - exposes a `process` global without a `nextTick`
	            // * Browserify - exposes a `process.nexTick` function that uses
	            //   `setTimeout`. In this case `setImmediate` is preferred because
	            //    it is faster. Browserify's `process.toString()` yields
	            //   "[object Object]", while in a real Node environment
	            //   `process.toString()` yields "[object process]".
	            isNodeJS = true;
	
	            requestTick = function requestTick() {
	                process.nextTick(flush);
	            };
	        } else if (typeof setImmediate === "function") {
	            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	            if (typeof window !== "undefined") {
	                requestTick = setImmediate.bind(window, flush);
	            } else {
	                requestTick = function requestTick() {
	                    setImmediate(flush);
	                };
	            }
	        } else if (typeof MessageChannel !== "undefined") {
	            // modern browsers
	            // http://www.nonblocking.io/2011/06/windownexttick.html
	            var channel = new MessageChannel();
	            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	            // working message ports the first time a page loads.
	            channel.port1.onmessage = function () {
	                requestTick = requestPortTick;
	                channel.port1.onmessage = flush;
	                flush();
	            };
	            var requestPortTick = function requestPortTick() {
	                // Opera requires us to provide a message payload, regardless of
	                // whether we use it.
	                channel.port2.postMessage(0);
	            };
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	                requestPortTick();
	            };
	        } else {
	            // old browsers
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	            };
	        }
	        // runs a task after all other tasks have been run
	        // this is useful for unhandled rejection tracking that needs to happen
	        // after all `then`d tasks have been run.
	        nextTick.runAfter = function (task) {
	            laterQueue.push(task);
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	        return nextTick;
	    }();
	
	    // Attempt to make generics safe in the face of downstream
	    // modifications.
	    // There is no situation where this is necessary.
	    // If you need a security guarantee, these primordials need to be
	    // deeply frozen anyway, and if you don’t need a security guarantee,
	    // this is just plain paranoid.
	    // However, this **might** have the nice side-effect of reducing the size of
	    // the minified code by reducing x.call() to merely x()
	    // See Mark Miller’s explanation of what this does.
	    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	    var call = Function.call;
	    function uncurryThis(f) {
	        return function () {
	            return call.apply(f, arguments);
	        };
	    }
	    // This is equivalent, but slower:
	    // uncurryThis = Function_bind.bind(Function_bind.call);
	    // http://jsperf.com/uncurrythis
	
	    var array_slice = uncurryThis(Array.prototype.slice);
	
	    var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    });
	
	    var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    });
	
	    var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    });
	
	    var object_create = Object.create || function (prototype) {
	        function Type() {}
	        Type.prototype = prototype;
	        return new Type();
	    };
	
	    var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
	        obj[prop] = descriptor.value;
	        return obj;
	    };
	
	    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
	
	    var object_keys = Object.keys || function (object) {
	        var keys = [];
	        for (var key in object) {
	            if (object_hasOwnProperty(object, key)) {
	                keys.push(key);
	            }
	        }
	        return keys;
	    };
	
	    var object_toString = uncurryThis(Object.prototype.toString);
	
	    function isObject(value) {
	        return value === Object(value);
	    }
	
	    // generator related shims
	
	    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	    function isStopIteration(exception) {
	        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
	    }
	
	    // FIXME: Remove this helper and Q.return once ES6 generators are in
	    // SpiderMonkey.
	    var QReturnValue;
	    if (typeof ReturnValue !== "undefined") {
	        QReturnValue = ReturnValue;
	    } else {
	        QReturnValue = function QReturnValue(value) {
	            this.value = value;
	        };
	    }
	
	    // long stack traces
	
	    var STACK_JUMP_SEPARATOR = "From previous event:";
	
	    function makeStackTraceLong(error, promise) {
	        // If possible, transform the error stack trace by removing Node and Q
	        // cruft, then concatenating with the stack trace of `promise`. See #57.
	        if (hasStacks && promise.stack && (typeof error === "undefined" ? "undefined" : _typeof(error)) === "object" && error !== null && error.stack) {
	            var stacks = [];
	            for (var p = promise; !!p; p = p.source) {
	                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
	                    object_defineProperty(error, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
	                    stacks.unshift(p.stack);
	                }
	            }
	            stacks.unshift(error.stack);
	
	            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	            var stack = filterStackString(concatedStacks);
	            object_defineProperty(error, "stack", { value: stack, configurable: true });
	        }
	    }
	
	    function filterStackString(stackString) {
	        var lines = stackString.split("\n");
	        var desiredLines = [];
	        for (var i = 0; i < lines.length; ++i) {
	            var line = lines[i];
	
	            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	                desiredLines.push(line);
	            }
	        }
	        return desiredLines.join("\n");
	    }
	
	    function isNodeFrame(stackLine) {
	        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
	    }
	
	    function getFileNameAndLineNumber(stackLine) {
	        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	        // In IE10 function name can have spaces ("Anonymous function") O_o
	        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	        if (attempt1) {
	            return [attempt1[1], Number(attempt1[2])];
	        }
	
	        // Anonymous functions: "at filename:lineNumber:columnNumber"
	        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	        if (attempt2) {
	            return [attempt2[1], Number(attempt2[2])];
	        }
	
	        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	        if (attempt3) {
	            return [attempt3[1], Number(attempt3[2])];
	        }
	    }
	
	    function isInternalFrame(stackLine) {
	        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
	
	        if (!fileNameAndLineNumber) {
	            return false;
	        }
	
	        var fileName = fileNameAndLineNumber[0];
	        var lineNumber = fileNameAndLineNumber[1];
	
	        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
	    }
	
	    // discover own file name and line number range for filtering stack
	    // traces
	    function captureLine() {
	        if (!hasStacks) {
	            return;
	        }
	
	        try {
	            throw new Error();
	        } catch (e) {
	            var lines = e.stack.split("\n");
	            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	            if (!fileNameAndLineNumber) {
	                return;
	            }
	
	            qFileName = fileNameAndLineNumber[0];
	            return fileNameAndLineNumber[1];
	        }
	    }
	
	    function deprecate(callback, name, alternative) {
	        return function () {
	            if (typeof console !== "undefined" && typeof console.warn === "function") {
	                console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
	            }
	            return callback.apply(callback, arguments);
	        };
	    }
	
	    // end of shims
	    // beginning of real work
	
	    /**
	     * Constructs a promise for an immediate reference, passes promises through, or
	     * coerces promises from different systems.
	     * @param value immediate reference or promise
	     */
	    function Q(value) {
	        // If the object is already a Promise, return it directly.  This enables
	        // the resolve function to both be used to created references from objects,
	        // but to tolerably coerce non-promises to promises.
	        if (value instanceof Promise) {
	            return value;
	        }
	
	        // assimilate thenables
	        if (isPromiseAlike(value)) {
	            return coerce(value);
	        } else {
	            return fulfill(value);
	        }
	    }
	    Q.resolve = Q;
	
	    /**
	     * Performs a task in a future turn of the event loop.
	     * @param {Function} task
	     */
	    Q.nextTick = nextTick;
	
	    /**
	     * Controls whether or not long stack traces will be on
	     */
	    Q.longStackSupport = false;
	
	    /**
	     * The counter is used to determine the stopping point for building
	     * long stack traces. In makeStackTraceLong we walk backwards through
	     * the linked list of promises, only stacks which were created before
	     * the rejection are concatenated.
	     */
	    var longStackCounter = 1;
	
	    // enable long stacks if Q_DEBUG is set
	    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.env && process.env.Q_DEBUG) {
	        Q.longStackSupport = true;
	    }
	
	    /**
	     * Constructs a {promise, resolve, reject} object.
	     *
	     * `resolve` is a callback to invoke with a more resolved value for the
	     * promise. To fulfill the promise, invoke `resolve` with any value that is
	     * not a thenable. To reject the promise, invoke `resolve` with a rejected
	     * thenable, or invoke `reject` with the reason directly. To resolve the
	     * promise to another thenable, thus putting it in the same state, invoke
	     * `resolve` with that other thenable.
	     */
	    Q.defer = defer;
	    function defer() {
	        // if "messages" is an "Array", that indicates that the promise has not yet
	        // been resolved.  If it is "undefined", it has been resolved.  Each
	        // element of the messages array is itself an array of complete arguments to
	        // forward to the resolved promise.  We coerce the resolution value to a
	        // promise using the `resolve` function because it handles both fully
	        // non-thenable values and other thenables gracefully.
	        var messages = [],
	            progressListeners = [],
	            resolvedPromise;
	
	        var deferred = object_create(defer.prototype);
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, operands) {
	            var args = array_slice(arguments);
	            if (messages) {
	                messages.push(args);
	                if (op === "when" && operands[1]) {
	                    // progress operand
	                    progressListeners.push(operands[1]);
	                }
	            } else {
	                Q.nextTick(function () {
	                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	                });
	            }
	        };
	
	        // XXX deprecated
	        promise.valueOf = function () {
	            if (messages) {
	                return promise;
	            }
	            var nearerValue = nearer(resolvedPromise);
	            if (isPromise(nearerValue)) {
	                resolvedPromise = nearerValue; // shorten chain
	            }
	            return nearerValue;
	        };
	
	        promise.inspect = function () {
	            if (!resolvedPromise) {
	                return { state: "pending" };
	            }
	            return resolvedPromise.inspect();
	        };
	
	        if (Q.longStackSupport && hasStacks) {
	            try {
	                throw new Error();
	            } catch (e) {
	                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	                // accessor around; that causes memory leaks as per GH-111. Just
	                // reify the stack trace as a string ASAP.
	                //
	                // At the same time, cut off the first line; it's always just
	                // "[object Promise]\n", as per the `toString`.
	                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	                promise.stackCounter = longStackCounter++;
	            }
	        }
	
	        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	        // consolidating them into `become`, since otherwise we'd create new
	        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
	
	        function become(newPromise) {
	            resolvedPromise = newPromise;
	
	            if (Q.longStackSupport && hasStacks) {
	                // Only hold a reference to the new promise if long stacks
	                // are enabled to reduce memory usage
	                promise.source = newPromise;
	            }
	
	            array_reduce(messages, function (undefined, message) {
	                Q.nextTick(function () {
	                    newPromise.promiseDispatch.apply(newPromise, message);
	                });
	            }, void 0);
	
	            messages = void 0;
	            progressListeners = void 0;
	        }
	
	        deferred.promise = promise;
	        deferred.resolve = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(Q(value));
	        };
	
	        deferred.fulfill = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(fulfill(value));
	        };
	        deferred.reject = function (reason) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(reject(reason));
	        };
	        deferred.notify = function (progress) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            array_reduce(progressListeners, function (undefined, progressListener) {
	                Q.nextTick(function () {
	                    progressListener(progress);
	                });
	            }, void 0);
	        };
	
	        return deferred;
	    }
	
	    /**
	     * Creates a Node-style callback that will resolve or reject the deferred
	     * promise.
	     * @returns a nodeback
	     */
	    defer.prototype.makeNodeResolver = function () {
	        var self = this;
	        return function (error, value) {
	            if (error) {
	                self.reject(error);
	            } else if (arguments.length > 2) {
	                self.resolve(array_slice(arguments, 1));
	            } else {
	                self.resolve(value);
	            }
	        };
	    };
	
	    /**
	     * @param resolver {Function} a function that returns nothing and accepts
	     * the resolve, reject, and notify functions for a deferred.
	     * @returns a promise that may be resolved with the given resolve and reject
	     * functions, or rejected by a thrown exception in resolver
	     */
	    Q.Promise = promise; // ES6
	    Q.promise = promise;
	    function promise(resolver) {
	        if (typeof resolver !== "function") {
	            throw new TypeError("resolver must be a function.");
	        }
	        var deferred = defer();
	        try {
	            resolver(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (reason) {
	            deferred.reject(reason);
	        }
	        return deferred.promise;
	    }
	
	    promise.race = race; // ES6
	    promise.all = all; // ES6
	    promise.reject = reject; // ES6
	    promise.resolve = Q; // ES6
	
	    // XXX experimental.  This method is a way to denote that a local value is
	    // serializable and should be immediately dispatched to a remote upon request,
	    // instead of passing a reference.
	    Q.passByCopy = function (object) {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return object;
	    };
	
	    Promise.prototype.passByCopy = function () {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return this;
	    };
	
	    /**
	     * If two promises eventually fulfill to the same value, promises that value,
	     * but otherwise rejects.
	     * @param x {Any*}
	     * @param y {Any*}
	     * @returns {Any*} a promise for x and y if they are the same, but a rejection
	     * otherwise.
	     *
	     */
	    Q.join = function (x, y) {
	        return Q(x).join(y);
	    };
	
	    Promise.prototype.join = function (that) {
	        return Q([this, that]).spread(function (x, y) {
	            if (x === y) {
	                // TODO: "===" should be Object.is or equiv
	                return x;
	            } else {
	                throw new Error("Q can't join: not the same: " + x + " " + y);
	            }
	        });
	    };
	
	    /**
	     * Returns a promise for the first of an array of promises to become settled.
	     * @param answers {Array[Any*]} promises to race
	     * @returns {Any*} the first promise to be settled
	     */
	    Q.race = race;
	    function race(answerPs) {
	        return promise(function (resolve, reject) {
	            // Switch to this once we can assume at least ES5
	            // answerPs.forEach(function (answerP) {
	            //     Q(answerP).then(resolve, reject);
	            // });
	            // Use this in the meantime
	            for (var i = 0, len = answerPs.length; i < len; i++) {
	                Q(answerPs[i]).then(resolve, reject);
	            }
	        });
	    }
	
	    Promise.prototype.race = function () {
	        return this.then(Q.race);
	    };
	
	    /**
	     * Constructs a Promise with a promise descriptor object and optional fallback
	     * function.  The descriptor contains methods like when(rejected), get(name),
	     * set(name, value), post(name, args), and delete(name), which all
	     * return either a value, a promise for a value, or a rejection.  The fallback
	     * accepts the operation name, a resolver, and any further arguments that would
	     * have been forwarded to the appropriate method above had a method been
	     * provided with the proper name.  The API makes no guarantees about the nature
	     * of the returned object, apart from that it is usable whereever promises are
	     * bought and sold.
	     */
	    Q.makePromise = Promise;
	    function Promise(descriptor, fallback, inspect) {
	        if (fallback === void 0) {
	            fallback = function fallback(op) {
	                return reject(new Error("Promise does not support operation: " + op));
	            };
	        }
	        if (inspect === void 0) {
	            inspect = function inspect() {
	                return { state: "unknown" };
	            };
	        }
	
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, args) {
	            var result;
	            try {
	                if (descriptor[op]) {
	                    result = descriptor[op].apply(promise, args);
	                } else {
	                    result = fallback.call(promise, op, args);
	                }
	            } catch (exception) {
	                result = reject(exception);
	            }
	            if (resolve) {
	                resolve(result);
	            }
	        };
	
	        promise.inspect = inspect;
	
	        // XXX deprecated `valueOf` and `exception` support
	        if (inspect) {
	            var inspected = inspect();
	            if (inspected.state === "rejected") {
	                promise.exception = inspected.reason;
	            }
	
	            promise.valueOf = function () {
	                var inspected = inspect();
	                if (inspected.state === "pending" || inspected.state === "rejected") {
	                    return promise;
	                }
	                return inspected.value;
	            };
	        }
	
	        return promise;
	    }
	
	    Promise.prototype.toString = function () {
	        return "[object Promise]";
	    };
	
	    Promise.prototype.then = function (fulfilled, rejected, progressed) {
	        var self = this;
	        var deferred = defer();
	        var done = false; // ensure the untrusted promise makes at most a
	        // single call to one of the callbacks
	
	        function _fulfilled(value) {
	            try {
	                return typeof fulfilled === "function" ? fulfilled(value) : value;
	            } catch (exception) {
	                return reject(exception);
	            }
	        }
	
	        function _rejected(exception) {
	            if (typeof rejected === "function") {
	                makeStackTraceLong(exception, self);
	                try {
	                    return rejected(exception);
	                } catch (newException) {
	                    return reject(newException);
	                }
	            }
	            return reject(exception);
	        }
	
	        function _progressed(value) {
	            return typeof progressed === "function" ? progressed(value) : value;
	        }
	
	        Q.nextTick(function () {
	            self.promiseDispatch(function (value) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_fulfilled(value));
	            }, "when", [function (exception) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_rejected(exception));
	            }]);
	        });
	
	        // Progress propagator need to be attached in the current tick.
	        self.promiseDispatch(void 0, "when", [void 0, function (value) {
	            var newValue;
	            var threw = false;
	            try {
	                newValue = _progressed(value);
	            } catch (e) {
	                threw = true;
	                if (Q.onerror) {
	                    Q.onerror(e);
	                } else {
	                    throw e;
	                }
	            }
	
	            if (!threw) {
	                deferred.notify(newValue);
	            }
	        }]);
	
	        return deferred.promise;
	    };
	
	    Q.tap = function (promise, callback) {
	        return Q(promise).tap(callback);
	    };
	
	    /**
	     * Works almost like "finally", but not called for rejections.
	     * Original resolution value is passed through callback unaffected.
	     * Callback may return a promise that will be awaited for.
	     * @param {Function} callback
	     * @returns {Q.Promise}
	     * @example
	     * doSomething()
	     *   .then(...)
	     *   .tap(console.log)
	     *   .then(...);
	     */
	    Promise.prototype.tap = function (callback) {
	        callback = Q(callback);
	
	        return this.then(function (value) {
	            return callback.fcall(value).thenResolve(value);
	        });
	    };
	
	    /**
	     * Registers an observer on a promise.
	     *
	     * Guarantees:
	     *
	     * 1. that fulfilled and rejected will be called only once.
	     * 2. that either the fulfilled callback or the rejected callback will be
	     *    called, but not both.
	     * 3. that fulfilled and rejected will not be called in this turn.
	     *
	     * @param value      promise or immediate reference to observe
	     * @param fulfilled  function to be called with the fulfilled value
	     * @param rejected   function to be called with the rejection exception
	     * @param progressed function to be called on any progress notifications
	     * @return promise for the return value from the invoked callback
	     */
	    Q.when = when;
	    function when(value, fulfilled, rejected, progressed) {
	        return Q(value).then(fulfilled, rejected, progressed);
	    }
	
	    Promise.prototype.thenResolve = function (value) {
	        return this.then(function () {
	            return value;
	        });
	    };
	
	    Q.thenResolve = function (promise, value) {
	        return Q(promise).thenResolve(value);
	    };
	
	    Promise.prototype.thenReject = function (reason) {
	        return this.then(function () {
	            throw reason;
	        });
	    };
	
	    Q.thenReject = function (promise, reason) {
	        return Q(promise).thenReject(reason);
	    };
	
	    /**
	     * If an object is not a promise, it is as "near" as possible.
	     * If a promise is rejected, it is as "near" as possible too.
	     * If it’s a fulfilled promise, the fulfillment value is nearer.
	     * If it’s a deferred promise and the deferred has been resolved, the
	     * resolution is "nearer".
	     * @param object
	     * @returns most resolved (nearest) form of the object
	     */
	
	    // XXX should we re-do this?
	    Q.nearer = nearer;
	    function nearer(value) {
	        if (isPromise(value)) {
	            var inspected = value.inspect();
	            if (inspected.state === "fulfilled") {
	                return inspected.value;
	            }
	        }
	        return value;
	    }
	
	    /**
	     * @returns whether the given object is a promise.
	     * Otherwise it is a fulfilled value.
	     */
	    Q.isPromise = isPromise;
	    function isPromise(object) {
	        return object instanceof Promise;
	    }
	
	    Q.isPromiseAlike = isPromiseAlike;
	    function isPromiseAlike(object) {
	        return isObject(object) && typeof object.then === "function";
	    }
	
	    /**
	     * @returns whether the given object is a pending promise, meaning not
	     * fulfilled or rejected.
	     */
	    Q.isPending = isPending;
	    function isPending(object) {
	        return isPromise(object) && object.inspect().state === "pending";
	    }
	
	    Promise.prototype.isPending = function () {
	        return this.inspect().state === "pending";
	    };
	
	    /**
	     * @returns whether the given object is a value or fulfilled
	     * promise.
	     */
	    Q.isFulfilled = isFulfilled;
	    function isFulfilled(object) {
	        return !isPromise(object) || object.inspect().state === "fulfilled";
	    }
	
	    Promise.prototype.isFulfilled = function () {
	        return this.inspect().state === "fulfilled";
	    };
	
	    /**
	     * @returns whether the given object is a rejected promise.
	     */
	    Q.isRejected = isRejected;
	    function isRejected(object) {
	        return isPromise(object) && object.inspect().state === "rejected";
	    }
	
	    Promise.prototype.isRejected = function () {
	        return this.inspect().state === "rejected";
	    };
	
	    //// BEGIN UNHANDLED REJECTION TRACKING
	
	    // This promise library consumes exceptions thrown in handlers so they can be
	    // handled by a subsequent promise.  The exceptions get added to this array when
	    // they are created, and removed when they are handled.  Note that in ES6 or
	    // shimmed environments, this would naturally be a `Set`.
	    var unhandledReasons = [];
	    var unhandledRejections = [];
	    var reportedUnhandledRejections = [];
	    var trackUnhandledRejections = true;
	
	    function resetUnhandledRejections() {
	        unhandledReasons.length = 0;
	        unhandledRejections.length = 0;
	
	        if (!trackUnhandledRejections) {
	            trackUnhandledRejections = true;
	        }
	    }
	
	    function trackRejection(promise, reason) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	            Q.nextTick.runAfter(function () {
	                if (array_indexOf(unhandledRejections, promise) !== -1) {
	                    process.emit("unhandledRejection", reason, promise);
	                    reportedUnhandledRejections.push(promise);
	                }
	            });
	        }
	
	        unhandledRejections.push(promise);
	        if (reason && typeof reason.stack !== "undefined") {
	            unhandledReasons.push(reason.stack);
	        } else {
	            unhandledReasons.push("(no stack) " + reason);
	        }
	    }
	
	    function untrackRejection(promise) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	
	        var at = array_indexOf(unhandledRejections, promise);
	        if (at !== -1) {
	            if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	                Q.nextTick.runAfter(function () {
	                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
	                    if (atReport !== -1) {
	                        process.emit("rejectionHandled", unhandledReasons[at], promise);
	                        reportedUnhandledRejections.splice(atReport, 1);
	                    }
	                });
	            }
	            unhandledRejections.splice(at, 1);
	            unhandledReasons.splice(at, 1);
	        }
	    }
	
	    Q.resetUnhandledRejections = resetUnhandledRejections;
	
	    Q.getUnhandledReasons = function () {
	        // Make a copy so that consumers can't interfere with our internal state.
	        return unhandledReasons.slice();
	    };
	
	    Q.stopUnhandledRejectionTracking = function () {
	        resetUnhandledRejections();
	        trackUnhandledRejections = false;
	    };
	
	    resetUnhandledRejections();
	
	    //// END UNHANDLED REJECTION TRACKING
	
	    /**
	     * Constructs a rejected promise.
	     * @param reason value describing the failure
	     */
	    Q.reject = reject;
	    function reject(reason) {
	        var rejection = Promise({
	            "when": function when(rejected) {
	                // note that the error has been handled
	                if (rejected) {
	                    untrackRejection(this);
	                }
	                return rejected ? rejected(reason) : this;
	            }
	        }, function fallback() {
	            return this;
	        }, function inspect() {
	            return { state: "rejected", reason: reason };
	        });
	
	        // Note that the reason has not been handled.
	        trackRejection(rejection, reason);
	
	        return rejection;
	    }
	
	    /**
	     * Constructs a fulfilled promise for an immediate reference.
	     * @param value immediate reference
	     */
	    Q.fulfill = fulfill;
	    function fulfill(value) {
	        return Promise({
	            "when": function when() {
	                return value;
	            },
	            "get": function get(name) {
	                return value[name];
	            },
	            "set": function set(name, rhs) {
	                value[name] = rhs;
	            },
	            "delete": function _delete(name) {
	                delete value[name];
	            },
	            "post": function post(name, args) {
	                // Mark Miller proposes that post with no name should apply a
	                // promised function.
	                if (name === null || name === void 0) {
	                    return value.apply(void 0, args);
	                } else {
	                    return value[name].apply(value, args);
	                }
	            },
	            "apply": function apply(thisp, args) {
	                return value.apply(thisp, args);
	            },
	            "keys": function keys() {
	                return object_keys(value);
	            }
	        }, void 0, function inspect() {
	            return { state: "fulfilled", value: value };
	        });
	    }
	
	    /**
	     * Converts thenables to Q promises.
	     * @param promise thenable promise
	     * @returns a Q promise
	     */
	    function coerce(promise) {
	        var deferred = defer();
	        Q.nextTick(function () {
	            try {
	                promise.then(deferred.resolve, deferred.reject, deferred.notify);
	            } catch (exception) {
	                deferred.reject(exception);
	            }
	        });
	        return deferred.promise;
	    }
	
	    /**
	     * Annotates an object such that it will never be
	     * transferred away from this process over any promise
	     * communication channel.
	     * @param object
	     * @returns promise a wrapping of that object that
	     * additionally responds to the "isDef" message
	     * without a rejection.
	     */
	    Q.master = master;
	    function master(object) {
	        return Promise({
	            "isDef": function isDef() {}
	        }, function fallback(op, args) {
	            return dispatch(object, op, args);
	        }, function () {
	            return Q(object).inspect();
	        });
	    }
	
	    /**
	     * Spreads the values of a promised array of arguments into the
	     * fulfillment callback.
	     * @param fulfilled callback that receives variadic arguments from the
	     * promised array
	     * @param rejected callback that receives the exception if the promise
	     * is rejected.
	     * @returns a promise for the return value or thrown exception of
	     * either callback.
	     */
	    Q.spread = spread;
	    function spread(value, fulfilled, rejected) {
	        return Q(value).spread(fulfilled, rejected);
	    }
	
	    Promise.prototype.spread = function (fulfilled, rejected) {
	        return this.all().then(function (array) {
	            return fulfilled.apply(void 0, array);
	        }, rejected);
	    };
	
	    /**
	     * The async function is a decorator for generator functions, turning
	     * them into asynchronous generators.  Although generators are only part
	     * of the newest ECMAScript 6 drafts, this code does not cause syntax
	     * errors in older engines.  This code should continue to work and will
	     * in fact improve over time as the language improves.
	     *
	     * ES6 generators are currently part of V8 version 3.19 with the
	     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	     * for longer, but under an older Python-inspired form.  This function
	     * works on both kinds of generators.
	     *
	     * Decorates a generator function such that:
	     *  - it may yield promises
	     *  - execution will continue when that promise is fulfilled
	     *  - the value of the yield expression will be the fulfilled value
	     *  - it returns a promise for the return value (when the generator
	     *    stops iterating)
	     *  - the decorated function returns a promise for the return value
	     *    of the generator or the first rejected promise among those
	     *    yielded.
	     *  - if an error is thrown in the generator, it propagates through
	     *    every following yield until it is caught, or until it escapes
	     *    the generator function altogether, and is translated into a
	     *    rejection for the promise returned by the decorated generator.
	     */
	    Q.async = async;
	    function async(makeGenerator) {
	        return function () {
	            // when verb is "send", arg is a value
	            // when verb is "throw", arg is an exception
	            function continuer(verb, arg) {
	                var result;
	
	                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	                // engine that has a deployed base of browsers that support generators.
	                // However, SM's generators use the Python-inspired semantics of
	                // outdated ES6 drafts.  We would like to support ES6, but we'd also
	                // like to make it possible to use generators in deployed browsers, so
	                // we also support Python-style generators.  At some point we can remove
	                // this block.
	
	                if (typeof StopIteration === "undefined") {
	                    // ES6 Generators
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        return reject(exception);
	                    }
	                    if (result.done) {
	                        return Q(result.value);
	                    } else {
	                        return when(result.value, callback, errback);
	                    }
	                } else {
	                    // SpiderMonkey Generators
	                    // FIXME: Remove this case when SM does ES6 generators.
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        if (isStopIteration(exception)) {
	                            return Q(exception.value);
	                        } else {
	                            return reject(exception);
	                        }
	                    }
	                    return when(result, callback, errback);
	                }
	            }
	            var generator = makeGenerator.apply(this, arguments);
	            var callback = continuer.bind(continuer, "next");
	            var errback = continuer.bind(continuer, "throw");
	            return callback();
	        };
	    }
	
	    /**
	     * The spawn function is a small wrapper around async that immediately
	     * calls the generator and also ends the promise chain, so that any
	     * unhandled errors are thrown instead of forwarded to the error
	     * handler. This is useful because it's extremely common to run
	     * generators at the top-level to work with libraries.
	     */
	    Q.spawn = spawn;
	    function spawn(makeGenerator) {
	        Q.done(Q.async(makeGenerator)());
	    }
	
	    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	    /**
	     * Throws a ReturnValue exception to stop an asynchronous generator.
	     *
	     * This interface is a stop-gap measure to support generator return
	     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	     * generators like Chromium 29, just use "return" in your generator
	     * functions.
	     *
	     * @param value the return value for the surrounding generator
	     * @throws ReturnValue exception with the value.
	     * @example
	     * // ES6 style
	     * Q.async(function* () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      return foo + bar;
	     * })
	     * // Older SpiderMonkey style
	     * Q.async(function () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      Q.return(foo + bar);
	     * })
	     */
	    Q["return"] = _return;
	    function _return(value) {
	        throw new QReturnValue(value);
	    }
	
	    /**
	     * The promised function decorator ensures that any promise arguments
	     * are settled and passed as values (`this` is also settled and passed
	     * as a value).  It will also ensure that the result of a function is
	     * always a promise.
	     *
	     * @example
	     * var add = Q.promised(function (a, b) {
	     *     return a + b;
	     * });
	     * add(Q(a), Q(B));
	     *
	     * @param {function} callback The function to decorate
	     * @returns {function} a function that has been decorated.
	     */
	    Q.promised = promised;
	    function promised(callback) {
	        return function () {
	            return spread([this, all(arguments)], function (self, args) {
	                return callback.apply(self, args);
	            });
	        };
	    }
	
	    /**
	     * sends a message to a value in a future turn
	     * @param object* the recipient
	     * @param op the name of the message operation, e.g., "when",
	     * @param args further arguments to be forwarded to the operation
	     * @returns result {Promise} a promise for the result of the operation
	     */
	    Q.dispatch = dispatch;
	    function dispatch(object, op, args) {
	        return Q(object).dispatch(op, args);
	    }
	
	    Promise.prototype.dispatch = function (op, args) {
	        var self = this;
	        var deferred = defer();
	        Q.nextTick(function () {
	            self.promiseDispatch(deferred.resolve, op, args);
	        });
	        return deferred.promise;
	    };
	
	    /**
	     * Gets the value of a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to get
	     * @return promise for the property value
	     */
	    Q.get = function (object, key) {
	        return Q(object).dispatch("get", [key]);
	    };
	
	    Promise.prototype.get = function (key) {
	        return this.dispatch("get", [key]);
	    };
	
	    /**
	     * Sets the value of a property in a future turn.
	     * @param object    promise or immediate reference for object object
	     * @param name      name of property to set
	     * @param value     new value of property
	     * @return promise for the return value
	     */
	    Q.set = function (object, key, value) {
	        return Q(object).dispatch("set", [key, value]);
	    };
	
	    Promise.prototype.set = function (key, value) {
	        return this.dispatch("set", [key, value]);
	    };
	
	    /**
	     * Deletes a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to delete
	     * @return promise for the return value
	     */
	    Q.del = // XXX legacy
	    Q["delete"] = function (object, key) {
	        return Q(object).dispatch("delete", [key]);
	    };
	
	    Promise.prototype.del = // XXX legacy
	    Promise.prototype["delete"] = function (key) {
	        return this.dispatch("delete", [key]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param value     a value to post, typically an array of
	     *                  invocation arguments for promises that
	     *                  are ultimately backed with `resolve` values,
	     *                  as opposed to those backed with URLs
	     *                  wherein the posted value can be any
	     *                  JSON serializable object.
	     * @return promise for the return value
	     */
	    // bound locally because it is used by other methods
	    Q.mapply = // XXX As proposed by "Redsandro"
	    Q.post = function (object, name, args) {
	        return Q(object).dispatch("post", [name, args]);
	    };
	
	    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.post = function (name, args) {
	        return this.dispatch("post", [name, args]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param ...args   array of invocation arguments
	     * @return promise for the return value
	     */
	    Q.send = // XXX Mark Miller's proposed parlance
	    Q.mcall = // XXX As proposed by "Redsandro"
	    Q.invoke = function (object, name /*...args*/) {
	        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	    };
	
	    Promise.prototype.send = // XXX Mark Miller's proposed parlance
	    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	    Promise.prototype.invoke = function (name /*...args*/) {
	        return this.dispatch("post", [name, array_slice(arguments, 1)]);
	    };
	
	    /**
	     * Applies the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param args      array of application arguments
	     */
	    Q.fapply = function (object, args) {
	        return Q(object).dispatch("apply", [void 0, args]);
	    };
	
	    Promise.prototype.fapply = function (args) {
	        return this.dispatch("apply", [void 0, args]);
	    };
	
	    /**
	     * Calls the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q["try"] = Q.fcall = function (object /* ...args*/) {
	        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	    };
	
	    Promise.prototype.fcall = function () /*...args*/{
	        return this.dispatch("apply", [void 0, array_slice(arguments)]);
	    };
	
	    /**
	     * Binds the promised function, transforming return values into a fulfilled
	     * promise and thrown errors into a rejected one.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q.fbind = function (object /*...args*/) {
	        var promise = Q(object);
	        var args = array_slice(arguments, 1);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	    Promise.prototype.fbind = function () /*...args*/{
	        var promise = this;
	        var args = array_slice(arguments);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	
	    /**
	     * Requests the names of the owned properties of a promised
	     * object in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @return promise for the keys of the eventually settled object
	     */
	    Q.keys = function (object) {
	        return Q(object).dispatch("keys", []);
	    };
	
	    Promise.prototype.keys = function () {
	        return this.dispatch("keys", []);
	    };
	
	    /**
	     * Turns an array of promises into a promise for an array.  If any of
	     * the promises gets rejected, the whole array is rejected immediately.
	     * @param {Array*} an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns a promise for an array of the corresponding values
	     */
	    // By Mark Miller
	    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	    Q.all = all;
	    function all(promises) {
	        return when(promises, function (promises) {
	            var pendingCount = 0;
	            var deferred = defer();
	            array_reduce(promises, function (undefined, promise, index) {
	                var snapshot;
	                if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
	                    promises[index] = snapshot.value;
	                } else {
	                    ++pendingCount;
	                    when(promise, function (value) {
	                        promises[index] = value;
	                        if (--pendingCount === 0) {
	                            deferred.resolve(promises);
	                        }
	                    }, deferred.reject, function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    });
	                }
	            }, void 0);
	            if (pendingCount === 0) {
	                deferred.resolve(promises);
	            }
	            return deferred.promise;
	        });
	    }
	
	    Promise.prototype.all = function () {
	        return all(this);
	    };
	
	    /**
	     * Returns the first resolved promise of an array. Prior rejected promises are
	     * ignored.  Rejects only if all promises are rejected.
	     * @param {Array*} an array containing values or promises for values
	     * @returns a promise fulfilled with the value of the first resolved promise,
	     * or a rejected promise if all promises are rejected.
	     */
	    Q.any = any;
	
	    function any(promises) {
	        if (promises.length === 0) {
	            return Q.resolve();
	        }
	
	        var deferred = Q.defer();
	        var pendingCount = 0;
	        array_reduce(promises, function (prev, current, index) {
	            var promise = promises[index];
	
	            pendingCount++;
	
	            when(promise, onFulfilled, onRejected, onProgress);
	            function onFulfilled(result) {
	                deferred.resolve(result);
	            }
	            function onRejected(err) {
	                pendingCount--;
	                if (pendingCount === 0) {
	                    err.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + err.message;
	                    deferred.reject(err);
	                }
	            }
	            function onProgress(progress) {
	                deferred.notify({
	                    index: index,
	                    value: progress
	                });
	            }
	        }, undefined);
	
	        return deferred.promise;
	    }
	
	    Promise.prototype.any = function () {
	        return any(this);
	    };
	
	    /**
	     * Waits for all promises to be settled, either fulfilled or
	     * rejected.  This is distinct from `all` since that would stop
	     * waiting at the first rejection.  The promise returned by
	     * `allResolved` will never be rejected.
	     * @param promises a promise for an array (or an array) of promises
	     * (or values)
	     * @return a promise for an array of promises
	     */
	    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	    function allResolved(promises) {
	        return when(promises, function (promises) {
	            promises = array_map(promises, Q);
	            return when(all(array_map(promises, function (promise) {
	                return when(promise, noop, noop);
	            })), function () {
	                return promises;
	            });
	        });
	    }
	
	    Promise.prototype.allResolved = function () {
	        return allResolved(this);
	    };
	
	    /**
	     * @see Promise#allSettled
	     */
	    Q.allSettled = allSettled;
	    function allSettled(promises) {
	        return Q(promises).allSettled();
	    }
	
	    /**
	     * Turns an array of promises into a promise for an array of their states (as
	     * returned by `inspect`) when they have all settled.
	     * @param {Array[Any*]} values an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns {Array[State]} an array of states for the respective values.
	     */
	    Promise.prototype.allSettled = function () {
	        return this.then(function (promises) {
	            return all(array_map(promises, function (promise) {
	                promise = Q(promise);
	                function regardless() {
	                    return promise.inspect();
	                }
	                return promise.then(regardless, regardless);
	            }));
	        });
	    };
	
	    /**
	     * Captures the failure of a promise, giving an oportunity to recover
	     * with a callback.  If the given promise is fulfilled, the returned
	     * promise is fulfilled.
	     * @param {Any*} promise for something
	     * @param {Function} callback to fulfill the returned promise if the
	     * given promise is rejected
	     * @returns a promise for the return value of the callback
	     */
	    Q.fail = // XXX legacy
	    Q["catch"] = function (object, rejected) {
	        return Q(object).then(void 0, rejected);
	    };
	
	    Promise.prototype.fail = // XXX legacy
	    Promise.prototype["catch"] = function (rejected) {
	        return this.then(void 0, rejected);
	    };
	
	    /**
	     * Attaches a listener that can respond to progress notifications from a
	     * promise's originating deferred. This listener receives the exact arguments
	     * passed to ``deferred.notify``.
	     * @param {Any*} promise for something
	     * @param {Function} callback to receive any progress notifications
	     * @returns the given promise, unchanged
	     */
	    Q.progress = progress;
	    function progress(object, progressed) {
	        return Q(object).then(void 0, void 0, progressed);
	    }
	
	    Promise.prototype.progress = function (progressed) {
	        return this.then(void 0, void 0, progressed);
	    };
	
	    /**
	     * Provides an opportunity to observe the settling of a promise,
	     * regardless of whether the promise is fulfilled or rejected.  Forwards
	     * the resolution to the returned promise when the callback is done.
	     * The callback can return a promise to defer completion.
	     * @param {Any*} promise
	     * @param {Function} callback to observe the resolution of the given
	     * promise, takes no arguments.
	     * @returns a promise for the resolution of the given promise when
	     * ``fin`` is done.
	     */
	    Q.fin = // XXX legacy
	    Q["finally"] = function (object, callback) {
	        return Q(object)["finally"](callback);
	    };
	
	    Promise.prototype.fin = // XXX legacy
	    Promise.prototype["finally"] = function (callback) {
	        if (!callback || typeof callback.apply !== "function") {
	            throw new Error("Q can't apply finally callback");
	        }
	        callback = Q(callback);
	        return this.then(function (value) {
	            return callback.fcall().then(function () {
	                return value;
	            });
	        }, function (reason) {
	            // TODO attempt to recycle the rejection with "this".
	            return callback.fcall().then(function () {
	                throw reason;
	            });
	        });
	    };
	
	    /**
	     * Terminates a chain of promises, forcing rejections to be
	     * thrown as exceptions.
	     * @param {Any*} promise at the end of a chain of promises
	     * @returns nothing
	     */
	    Q.done = function (object, fulfilled, rejected, progress) {
	        return Q(object).done(fulfilled, rejected, progress);
	    };
	
	    Promise.prototype.done = function (fulfilled, rejected, progress) {
	        var onUnhandledError = function onUnhandledError(error) {
	            // forward to a future turn so that ``when``
	            // does not catch it and turn it into a rejection.
	            Q.nextTick(function () {
	                makeStackTraceLong(error, promise);
	                if (Q.onerror) {
	                    Q.onerror(error);
	                } else {
	                    throw error;
	                }
	            });
	        };
	
	        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.domain) {
	            onUnhandledError = process.domain.bind(onUnhandledError);
	        }
	
	        promise.then(void 0, onUnhandledError);
	    };
	
	    /**
	     * Causes a promise to be rejected if it does not get fulfilled before
	     * some milliseconds time out.
	     * @param {Any*} promise
	     * @param {Number} milliseconds timeout
	     * @param {Any*} custom error message or Error object (optional)
	     * @returns a promise for the resolution of the given promise if it is
	     * fulfilled before the timeout, otherwise rejected.
	     */
	    Q.timeout = function (object, ms, error) {
	        return Q(object).timeout(ms, error);
	    };
	
	    Promise.prototype.timeout = function (ms, error) {
	        var deferred = defer();
	        var timeoutId = setTimeout(function () {
	            if (!error || "string" === typeof error) {
	                error = new Error(error || "Timed out after " + ms + " ms");
	                error.code = "ETIMEDOUT";
	            }
	            deferred.reject(error);
	        }, ms);
	
	        this.then(function (value) {
	            clearTimeout(timeoutId);
	            deferred.resolve(value);
	        }, function (exception) {
	            clearTimeout(timeoutId);
	            deferred.reject(exception);
	        }, deferred.notify);
	
	        return deferred.promise;
	    };
	
	    /**
	     * Returns a promise for the given value (or promised value), some
	     * milliseconds after it resolved. Passes rejections immediately.
	     * @param {Any*} promise
	     * @param {Number} milliseconds
	     * @returns a promise for the resolution of the given promise after milliseconds
	     * time has elapsed since the resolution of the given promise.
	     * If the given promise rejects, that is passed immediately.
	     */
	    Q.delay = function (object, timeout) {
	        if (timeout === void 0) {
	            timeout = object;
	            object = void 0;
	        }
	        return Q(object).delay(timeout);
	    };
	
	    Promise.prototype.delay = function (timeout) {
	        return this.then(function (value) {
	            var deferred = defer();
	            setTimeout(function () {
	                deferred.resolve(value);
	            }, timeout);
	            return deferred.promise;
	        });
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided as an array, and returns a promise.
	     *
	     *      Q.nfapply(FS.readFile, [__filename])
	     *      .then(function (content) {
	     *      })
	     *
	     */
	    Q.nfapply = function (callback, args) {
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfapply = function (args) {
	        var deferred = defer();
	        var nodeArgs = array_slice(args);
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided individually, and returns a promise.
	     * @example
	     * Q.nfcall(FS.readFile, __filename)
	     * .then(function (content) {
	     * })
	     *
	     */
	    Q.nfcall = function (callback /*...args*/) {
	        var args = array_slice(arguments, 1);
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfcall = function () /*...args*/{
	        var nodeArgs = array_slice(arguments);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Wraps a NodeJS continuation passing function and returns an equivalent
	     * version that returns a promise.
	     * @example
	     * Q.nfbind(FS.readFile, __filename)("utf-8")
	     * .then(console.log)
	     * .done()
	     */
	    Q.nfbind = Q.denodeify = function (callback /*...args*/) {
	        if (callback === undefined) {
	            throw new Error("Q can't wrap an undefined function");
	        }
	        var baseArgs = array_slice(arguments, 1);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            Q(callback).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nfbind = Promise.prototype.denodeify = function () /*...args*/{
	        var args = array_slice(arguments);
	        args.unshift(this);
	        return Q.denodeify.apply(void 0, args);
	    };
	
	    Q.nbind = function (callback, thisp /*...args*/) {
	        var baseArgs = array_slice(arguments, 2);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            function bound() {
	                return callback.apply(thisp, arguments);
	            }
	            Q(bound).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nbind = function () /*thisp, ...args*/{
	        var args = array_slice(arguments, 0);
	        args.unshift(this);
	        return Q.nbind.apply(void 0, args);
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback with a given array of arguments, plus a provided callback.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param {Array} args arguments to pass to the method; the callback
	     * will be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nmapply = // XXX As proposed by "Redsandro"
	    Q.npost = function (object, name, args) {
	        return Q(object).npost(name, args);
	    };
	
	    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.npost = function (name, args) {
	        var nodeArgs = array_slice(args || []);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback, forwarding the given variadic arguments, plus a provided
	     * callback argument.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param ...args arguments to pass to the method; the callback will
	     * be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nsend = // XXX Based on Mark Miller's proposed "send"
	    Q.nmcall = // XXX Based on "Redsandro's" proposal
	    Q.ninvoke = function (object, name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 2);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	    Promise.prototype.ninvoke = function (name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 1);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * If a function would like to support both Node continuation-passing-style and
	     * promise-returning-style, it can end its internal promise chain with
	     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	     * elects to use a nodeback, the result will be sent there.  If they do not
	     * pass a nodeback, they will receive the result promise.
	     * @param object a result (or a promise for a result)
	     * @param {Function} nodeback a Node.js-style callback
	     * @returns either the promise or nothing
	     */
	    Q.nodeify = nodeify;
	    function nodeify(object, nodeback) {
	        return Q(object).nodeify(nodeback);
	    }
	
	    Promise.prototype.nodeify = function (nodeback) {
	        if (nodeback) {
	            this.then(function (value) {
	                Q.nextTick(function () {
	                    nodeback(null, value);
	                });
	            }, function (error) {
	                Q.nextTick(function () {
	                    nodeback(error);
	                });
	            });
	        } else {
	            return this;
	        }
	    };
	
	    Q.noConflict = function () {
	        throw new Error("Q.noConflict only works when Q is used as a global");
	    };
	
	    // All code before this point will be filtered from stack traces.
	    var qEndingLine = captureLine();
	
	    return Q;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(9).setImmediate, __webpack_require__(11)(module)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function () {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function () {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout = exports.clearInterval = function (timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function () {};
	Timeout.prototype.close = function () {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function (item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function (item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function (item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout) item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(10);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	
	(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	        // Callback can either be a function or a string
	        if (typeof callback !== "function") {
	            callback = new Function("" + callback);
	        }
	        // Copy function arguments
	        var args = new Array(arguments.length - 1);
	        for (var i = 0; i < args.length; i++) {
	            args[i] = arguments[i + 1];
	        }
	        // Store and register the task
	        var task = { callback: callback, args: args };
	        tasksByHandle[nextHandle] = task;
	        registerImmediate(nextHandle);
	        return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	            case 0:
	                callback();
	                break;
	            case 1:
	                callback(args[0]);
	                break;
	            case 2:
	                callback(args[0], args[1]);
	                break;
	            case 3:
	                callback(args[0], args[1], args[2]);
	                break;
	            default:
	                callback.apply(undefined, args);
	                break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            process.nextTick(function () {
	                runIfPresent(handle);
	            });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function () {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function onGlobalMessage(event) {
	            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function registerImmediate(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function registerImmediate(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function registerImmediate(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _algoliasearch = __webpack_require__(13);
	
	var _algoliasearch2 = _interopRequireDefault(_algoliasearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var escapeRegExp = function escapeRegExp(str) {
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	};
	
	var Search = {
	  install: function install(Vue, options) {
	    _loglevel2.default.trace(options);
	    var AlgoliaClient = (0, _algoliasearch2.default)(options.appID, options.apiKey, {
	      protocol: 'https:'
	    });
	    var AlgoliaIndex = AlgoliaClient.initIndex(options.index);
	
	    var advancedSearch = function advancedSearch(params) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.clearCache();
	      AlgoliaIndex.search(params, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          fetchListItemCards(content.hits).then(function () {
	            d.resolve(content.hits);
	          });
	        }
	      });
	      return d.promise;
	    };
	
	    var searchCards = function searchCards(userID, searchText, hitsPerPage) {
	      var d = _q2.default.defer();
	      var params = {
	        query: searchText,
	        filters: userID.length ? 'userID: ' + userID : '',
	        hitsPerPage: hitsPerPage || null
	      };
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (hits) {
	        _loglevel2.default.trace(hits);
	        d.resolve(hits);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var fetchListItemCards = function fetchListItemCards(cards) {
	      var d = _q2.default.defer();
	      var self = this;
	      var promises = [];
	      cards.forEach(function (card) {
	        card = correctCard(card);
	        card.content.listCards = [];
	        if (!card.content.listItems) card.content.listItems = [];
	        card.content.listItems.forEach(function (key) {
	          var p = _q2.default.defer();
	          promises.push(getCard(key)); // Do we need to notify the card or provide callbacks etc here?
	          // promises.push(p.promise)
	        });
	      });
	      _loglevel2.default.trace(promises);
	      _q2.default.allSettled(promises).then(function (results) {
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getCard = function getCard(objectID) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.getObject(objectID, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          d.resolve(content);
	        }
	      });
	      return d.promise;
	    };
	
	    var correctCard = function correctCard(card) {
	      if (!card.content) card.content = {
	        description: card.description || card.sentence || card.text,
	        listItems: card.listItems || []
	      };
	      card.sentence = card.content.description;
	      card.description = card.content.description;
	      // if (card.sentence) delete card.sentence
	      // if (card.text) delete card.text
	      // if (card.description) delete card.description
	      if (card.objectID == "624391002") console.log(hit);
	      return card;
	    };
	
	    var compoundSearch = function compoundSearch(userID, searchText) {
	      var d = _q2.default.defer();
	      var maxLength = 400;
	      var searchTextArray = [];
	      var hitsPerPage = Math.min(Math.max(Math.ceil(10 / (searchText.length / maxLength)), 3), 12);
	      for (var i = 0; i < searchText.length; i += maxLength) {
	        searchTextArray.push(searchText.substring(i, i + maxLength));
	      }
	      var promises = searchTextArray.map(function (t, j) {
	        return searchCards(userID, t, hitsPerPage);
	      });
	      _q2.default.allSettled(promises).then(function (results) {
	        var results = [].concat.apply([], results.map(function (r) {
	          return r.value;
	        }));
	        results = removeDuplicates(results, 'objectID');
	        _loglevel2.default.trace(results);
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	      });
	      return d.promise;
	    };
	
	    var removeDuplicates = function removeDuplicates(originalArray, objKey) {
	      var trimmedArray = [],
	          values = [],
	          value;
	      for (var i = 0; i < originalArray.length; i++) {
	        value = originalArray[i][objKey];
	        if (values.indexOf(value) === -1) {
	          trimmedArray.push(originalArray[i]);
	          values.push(value);
	        }
	      }
	      return trimmedArray;
	    };
	
	    var checkPageHit = function checkPageHit(pageData, results) {
	      //Not yet accounting for capitals
	      var boringWords = ['favourite', 'world', 'name', 'this', 'plan', 'need', 'best', 'like', 'the', 'are', 'is', 'my', 'my'];
	      var hits = [];
	      results.forEach(function (result, i) {
	        _loglevel2.default.trace('---');
	        _loglevel2.default.trace(i);
	        var count = [];
	        result.context.forEach(function (c) {
	          if (pageData.pageText.indexOf(c.value) > -1 && hits.indexOf(result.objectID) == -1 && c.value && c.value.length > 3 && boringWords.indexOf(c.value) == -1 && count.indexOf(c.value) == -1) {
	            _loglevel2.default.trace(c.value);
	            count.push(c.value);
	            (c.value.match(/ /g) || []).forEach(function () {
	              count.push(c.value);
	            });
	          }
	        });
	        if (count.length > 2) {
	          _loglevel2.default.trace(result.sentence);
	          hits.push(result);
	        }
	        _loglevel2.default.trace('---');
	      });
	
	      // return hits;
	      //Force no hits
	      return [];
	    };
	
	    var checkPageReminder = function checkPageReminder(userID, pageData) {
	      var d = _q2.default.defer();
	      _loglevel2.default.trace(pageData);
	      var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	      var params = {
	        query: '',
	        filters: 'userID: ' + userID + ' AND (triggerUrl: ' + urlRoot + ' OR triggerUrl: ' + urlRoot + '.com OR triggerUrl: ' + urlRoot + '.co.uk OR triggerUrl: ' + urlRoot + '.org OR triggerURL: ' + urlRoot + ' OR triggerURL: ' + urlRoot + '.com OR triggerURL: ' + urlRoot + '.co.uk OR triggerURL: ' + urlRoot + '.org)'
	      };
	      _loglevel2.default.trace('params');
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (reminders) {
	        _loglevel2.default.trace('reminders');
	        _loglevel2.default.trace(reminders);
	        d.resolve(reminders);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getPageResults = function getPageResults(userID, pageData, allUserCards) {
	      var d = _q2.default.defer();
	      // Gets all results
	      var pageResults = {
	        hits: [],
	        reminders: [],
	        pings: [],
	        memories: []
	      };
	      _loglevel2.default.trace(userID, pageData);
	      var gmailBoringPhrases = ['Skip to content', 'Using', 'with screen readers', 'Search', 'Mail', 'COMPOSE', 'Labels', 'Inbox', 'Starred', 'Sent Mail', 'Drafts', 'More', '---------- Forwarded message ----------', 'From: ', 'Date: ', 'Subject: ', 'To: ', 'Click here to Reply or Forward', 'GB', 'GB used', 'Manage', 'Program Policies', 'Powered by Google', 'Last account activity:', 'hour ago', 'hours ago', 'Details'];
	      gmailBoringPhrases.forEach(function (phrase) {
	        pageData.pageText = pageData.pageText.replace(phrase, '');
	      });
	      var boringWords = ["i", "a", "of", "me", "my", "is", "im", "so", "all", "get", "how", "new", "out", "the", "use", "best", "name", "next", "take", "what", "image", "something"];
	
	      try {
	        var allWords = [];
	        allUserCards.forEach(function (card) {
	          var score = 0;
	          card.context.forEach(function (entity) {
	            var val = String(entity.value);
	            if (boringWords.indexOf(val.toLowerCase()) == -1 && val.length > 1) {
	              var reg = new RegExp(escapeRegExp(val), "gi");
	              var points = (pageData.pageText.match(reg) || []).length * val.length;
	              score += points;
	              if (points) {
	                if (allWords.indexOf(val) == -1) allWords.push(val);
	              }
	            }
	          });
	          if (score > 100) {
	            pageResults.hits.push(card);
	          } else if (score > 0) {
	            pageResults.memories.push(card);
	          }
	        });
	        _loglevel2.default.debug(allWords);
	
	        pageResults.reminders = allUserCards.filter(function (card) {
	          var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	          _loglevel2.default.info(card.triggerURL);
	          return card.triggerURL && (card.triggerURL.indexOf(urlRoot) > -1 || card.triggerURL.indexOf(urlRoot) > -1);
	        });
	        pageResults.pings = pageResults.reminders; //.concat(pageResults.hits)
	        pageResults.pings.forEach(function (ping) {
	          ping.highlight = true;
	        });
	        // pageResults.memories = pageResults.pings.concat(pageResults.memories)
	        pageResults.memories = removeDuplicates(pageResults.memories, 'objectID');
	        _loglevel2.default.debug(pageResults);
	        d.resolve(pageResults);
	      } catch (e) {
	        _loglevel2.default.error(e);
	      }
	
	      // compoundSearch(userID, pageData.pageText)
	      // .then(function(results) {
	      //   log.trace(1);
	      //   log.trace(results);
	      //   pageResults.memories = results;
	      //   // Checks whether a ping is required
	      //   pageResults.hits = checkPageHit(pageData, results);
	      //   log.trace(2);
	      //   log.trace(pageResults.hits);
	      //   return checkPageReminder(userID, pageData)
	      // }).then(function(reminders) {
	      //   pageResults.reminders = reminders;
	      //   log.trace(3);
	      //   log.trace(pageResults.reminders);
	      //   // Returns results plus ping
	      //   pageResults.pings = pageResults.reminders.concat(pageResults.hits)
	      //   pageResults.pings.forEach(function(ping) {
	      //     log.trace(ping.objectID);
	      //     ping.highlight = true;
	      //   })
	      //   pageResults.memories = pageResults.pings.concat(pageResults.memories)
	      //   pageResults.memories = removeDuplicates(pageResults.memories, 'objectID')
	      //   log.trace(pageResults);
	      //   d.resolve(pageResults)
	      // }).catch(function(e) {
	      //   log.trace(e);
	      //   d.reject(e)
	      // })
	      return d.promise;
	    };
	
	    this.advancedSearch = advancedSearch;
	    this.searchCards = searchCards;
	    this.compoundSearch = compoundSearch;
	    this.getPageResults = getPageResults;
	  }
	};
	
	exports.default = Search;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var AlgoliaSearch = __webpack_require__(14);
	var createAlgoliasearch = __webpack_require__(38);
	
	module.exports = createAlgoliasearch(AlgoliaSearch);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = AlgoliaSearch;
	
	var Index = __webpack_require__(15);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var AlgoliaSearchCore = __webpack_require__(33);
	var inherits = __webpack_require__(16);
	var errors = __webpack_require__(19);
	
	function AlgoliaSearch() {
	  AlgoliaSearchCore.apply(this, arguments);
	}
	
	inherits(AlgoliaSearch, AlgoliaSearchCore);
	
	/*
	 * Delete an index
	 *
	 * @param indexName the name of index to delete
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.deleteIndex = function (indexName, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexName),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Move an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy of
	 * srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.moveIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'move', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Copy an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy
	 * of srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.copyIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'copy', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Return last log entries.
	 * @param offset Specify the first entry to retrieve (0-based, 0 is the most recent log entry).
	 * @param length Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param type Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.getLogs = function (offset, length, callback) {
	  var clone = __webpack_require__(24);
	  var params = {};
	  if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) === 'object') {
	    // getLogs(params)
	    params = clone(offset);
	    callback = length;
	  } else if (arguments.length === 0 || typeof offset === 'function') {
	    // getLogs([cb])
	    callback = offset;
	  } else if (arguments.length === 1 || typeof length === 'function') {
	    // getLogs(1, [cb)]
	    callback = length;
	    params.offset = offset;
	  } else {
	    // getLogs(1, 2, [cb])
	    params.offset = offset;
	    params.length = length;
	  }
	
	  if (params.offset === undefined) params.offset = 0;
	  if (params.length === undefined) params.length = 10;
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/logs?' + this._getSearchParams(params, ''),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * List all existing indexes (paginated)
	 *
	 * @param page The page to retrieve, starting at 0.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with index list
	 */
	AlgoliaSearch.prototype.listIndexes = function (page, callback) {
	  var params = '';
	
	  if (page === undefined || typeof page === 'function') {
	    callback = page;
	  } else {
	    params = '?page=' + page;
	  }
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes' + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearch.prototype.initIndex = function (indexName) {
	  return new Index(this, indexName);
	};
	
	/*
	 * @deprecated use client.listApiKeys
	 */
	AlgoliaSearch.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('client.listUserKeys()', 'client.listApiKeys()'));
	
	/*
	 * List all existing api keys with their associated ACLs
	 *
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with api keys list
	 */
	AlgoliaSearch.prototype.listApiKeys = function (callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.getApiKey
	 */
	AlgoliaSearch.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('client.getUserKeyACL()', 'client.getApiKey()'));
	
	/*
	 * Get an API key
	 *
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the right API key
	 */
	AlgoliaSearch.prototype.getApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.deleteApiKey
	 */
	AlgoliaSearch.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('client.deleteUserKey()', 'client.deleteApiKey()'));
	
	/*
	 * Delete an existing API key
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the date of deletion
	 */
	AlgoliaSearch.prototype.deleteApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see client.addApiKey
	 */
	AlgoliaSearch.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKey()', 'client.addApiKey()'));
	
	/*
	 * Add a new global API key
	 *
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the added API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.addUserKey(['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#AddKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.indexes = params.indexes;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * @deprecated Please use client.addApiKey()
	 */
	AlgoliaSearch.prototype.addUserKeyWithValidity = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKeyWithValidity()', 'client.addApiKey()'));
	
	/**
	 * @deprecated Please use client.updateApiKey()
	 */
	AlgoliaSearch.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('client.updateUserKey()', 'client.updateApiKey()'));
	
	/**
	 * Update an existing API key
	 * @param {string} key - The key to update
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the modified API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.updateApiKey('APIKEY', ['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.indexes = params.indexes;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'PUT',
	    url: '/1/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Initialize a new batch of search queries
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.startQueriesBatch = deprecate(function startQueriesBatchDeprecated() {
	  this._batch = [];
	}, deprecatedMessage('client.startQueriesBatch()', 'client.search()'));
	
	/**
	 * Add a search query in the batch
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.addQueryInBatch = deprecate(function addQueryInBatchDeprecated(indexName, query, args) {
	  this._batch.push({
	    indexName: indexName,
	    query: query,
	    params: args
	  });
	}, deprecatedMessage('client.addQueryInBatch()', 'client.search()'));
	
	/**
	 * Launch the batch of queries using XMLHttpRequest.
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.sendQueriesBatch = deprecate(function sendQueriesBatchDeprecated(callback) {
	  return this.search(this._batch, callback);
	}, deprecatedMessage('client.sendQueriesBatch()', 'client.search()'));
	
	/**
	 * Perform write operations accross multiple indexes.
	 *
	 * To reduce the amount of time spent on network round trips,
	 * you can create, update, or delete several objects in one call,
	 * using the batch endpoint (all operations are done in the given order).
	 *
	 * Available actions:
	 *   - addObject
	 *   - updateObject
	 *   - partialUpdateObject
	 *   - partialUpdateObjectNoCreate
	 *   - deleteObject
	 *
	 * https://www.algolia.com/doc/rest_api#Indexes
	 * @param  {Object[]} operations An array of operations to perform
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.batch([{
	 *   action: 'addObject',
	 *   indexName: 'clients',
	 *   body: {
	 *     name: 'Bill'
	 *   }
	 * }, {
	 *   action: 'udpateObject',
	 *   indexName: 'fruits',
	 *   body: {
	 *     objectID: '29138',
	 *     name: 'banana'
	 *   }
	 * }], cb)
	 */
	AlgoliaSearch.prototype.batch = function (operations, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.batch(operations[, callback])';
	
	  if (!isArray(operations)) {
	    throw new Error(usage);
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/batch',
	    body: {
	      requests: operations
	    },
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	// environment specific methods
	AlgoliaSearch.prototype.destroy = notImplemented;
	AlgoliaSearch.prototype.enableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.disableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.useSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.disableSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.generateSecuredApiKey = notImplemented;
	
	function notImplemented() {
	  var message = 'Not implemented in this environment.\n' + 'If you feel this is a mistake, write to support@algolia.com';
	
	  throw new errors.AlgoliaSearchError(message);
	}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var inherits = __webpack_require__(16);
	var IndexCore = __webpack_require__(17);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var exitPromise = __webpack_require__(30);
	var errors = __webpack_require__(19);
	
	var deprecateForwardToSlaves = deprecate(function () {}, deprecatedMessage('forwardToSlaves', 'forwardToReplicas'));
	
	module.exports = Index;
	
	function Index() {
	  IndexCore.apply(this, arguments);
	}
	
	inherits(Index, IndexCore);
	
	/*
	* Add an object in this index
	*
	* @param content contains the javascript object to add inside the index
	* @param objectID (optional) an objectID you want to attribute to this object
	* (if the attribute already exist the old object will be overwrite)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.addObject = function (content, objectID, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof objectID === 'function') {
	    callback = objectID;
	    objectID = undefined;
	  }
	
	  return this.as._jsonRequest({
	    method: objectID !== undefined ? 'PUT' : // update or create
	    'POST', // create (API generates an objectID)
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + ( // create
	    objectID !== undefined ? '/' + encodeURIComponent(objectID) : ''), // update or create
	    body: content,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Add several objects
	*
	* @param objects contains an array of objects to add
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.addObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'addObject',
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Update partially an object (only update attributes passed in argument)
	*
	* @param partialObject contains the javascript attributes to override, the
	*  object must contains an objectID attribute
	* @param createIfNotExists (optional) if false, avoid an automatic creation of the object
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.partialUpdateObject = function (partialObject, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = undefined;
	  }
	
	  var indexObj = this;
	  var url = '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(partialObject.objectID) + '/partial';
	  if (createIfNotExists === false) {
	    url += '?createIfNotExists=false';
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: url,
	    body: partialObject,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Partially Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.partialUpdateObjects = function (objects, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = true;
	  }
	
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.partialUpdateObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: createIfNotExists === true ? 'partialUpdateObject' : 'partialUpdateObjectNoCreate',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of object
	*
	* @param object contains the javascript object to save, the object must contains an objectID attribute
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObject = function (object, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(object.objectID),
	    body: object,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.saveObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'updateObject',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete an object from the index
	*
	* @param objectID the unique identifier of object to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObject = function (objectID, callback) {
	  if (typeof objectID === 'function' || typeof objectID !== 'string' && typeof objectID !== 'number') {
	    var err = new errors.AlgoliaSearchError('Cannot delete an object without an objectID');
	    callback = objectID;
	    if (typeof callback === 'function') {
	      return callback(err);
	    }
	
	    return this.as._promise.reject(err);
	  }
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete several objects from an index
	*
	* @param objectIDs contains an array of objectID to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObjects = function (objectIDs, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.deleteObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      return {
	        action: 'deleteObject',
	        objectID: objectID,
	        body: {
	          objectID: objectID
	        }
	      };
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete all objects matching a query
	*
	* @param query the query string
	* @param params the optional query parameters
	* @param callback (optional) the result callback called with one argument
	*  error: null or Error('message')
	*/
	Index.prototype.deleteByQuery = function (query, params, callback) {
	  var clone = __webpack_require__(24);
	  var map = __webpack_require__(29);
	
	  var indexObj = this;
	  var client = indexObj.as;
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else {
	    params = clone(params);
	  }
	
	  params.attributesToRetrieve = 'objectID';
	  params.hitsPerPage = 1000;
	  params.distinct = false;
	
	  // when deleting, we should never use cache to get the
	  // search results
	  this.clearCache();
	
	  // there's a problem in how we use the promise chain,
	  // see how waitTask is done
	  var promise = this.search(query, params).then(stopOrDelete);
	
	  function stopOrDelete(searchContent) {
	    // stop here
	    if (searchContent.nbHits === 0) {
	      // return indexObj.as._request.resolve();
	      return searchContent;
	    }
	
	    // continue and do a recursive call
	    var objectIDs = map(searchContent.hits, function getObjectID(object) {
	      return object.objectID;
	    });
	
	    return indexObj.deleteObjects(objectIDs).then(waitTask).then(doDeleteByQuery);
	  }
	
	  function waitTask(deleteObjectsContent) {
	    return indexObj.waitTask(deleteObjectsContent.taskID);
	  }
	
	  function doDeleteByQuery() {
	    return indexObj.deleteByQuery(query, params);
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(success, failure);
	
	  function success() {
	    exitPromise(function exit() {
	      callback(null);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failure(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* Browse all content from an index using events. Basically this will do
	* .browse() -> .browseFrom -> .browseFrom -> .. until all the results are returned
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @return {EventEmitter}
	* @example
	* var browser = index.browseAll('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* });
	*
	* browser.on('result', function resultCallback(content) {
	*   console.log(content.hits);
	* });
	*
	* // if any error occurs, you get it
	* browser.on('error', function(err) {
	*   throw err;
	* });
	*
	* // when you have browsed the whole index, you get this event
	* browser.on('end', function() {
	*   console.log('finished');
	* });
	*
	* // at any point if you want to stop the browsing process, you can stop it manually
	* // otherwise it will go on and on
	* browser.stop();
	*
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	Index.prototype.browseAll = function (query, queryParameters) {
	  if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
	    queryParameters = query;
	    query = undefined;
	  }
	
	  var merge = __webpack_require__(23);
	
	  var IndexBrowser = __webpack_require__(31);
	
	  var browser = new IndexBrowser();
	  var client = this.as;
	  var index = this;
	  var params = client._getSearchParams(merge({}, queryParameters || {}, {
	    query: query
	  }), '');
	
	  // start browsing
	  browseLoop();
	
	  function browseLoop(cursor) {
	    if (browser._stopped) {
	      return;
	    }
	
	    var body;
	
	    if (cursor !== undefined) {
	      body = {
	        cursor: cursor
	      };
	    } else {
	      body = {
	        params: params
	      };
	    }
	
	    client._jsonRequest({
	      method: 'POST',
	      url: '/1/indexes/' + encodeURIComponent(index.indexName) + '/browse',
	      hostType: 'read',
	      body: body,
	      callback: browseCallback
	    });
	  }
	
	  function browseCallback(err, content) {
	    if (browser._stopped) {
	      return;
	    }
	
	    if (err) {
	      browser._error(err);
	      return;
	    }
	
	    browser._result(content);
	
	    // no cursor means we are finished browsing
	    if (content.cursor === undefined) {
	      browser._end();
	      return;
	    }
	
	    browseLoop(content.cursor);
	  }
	
	  return browser;
	};
	
	/*
	* Get a Typeahead.js adapter
	* @param searchParams contains an object with query parameters (see search for details)
	*/
	Index.prototype.ttAdapter = deprecate(function (params) {
	  var self = this;
	  return function ttAdapter(query, syncCb, asyncCb) {
	    var cb;
	
	    if (typeof asyncCb === 'function') {
	      // typeahead 0.11
	      cb = asyncCb;
	    } else {
	      // pre typeahead 0.11
	      cb = syncCb;
	    }
	
	    self.search(query, params, function searchDone(err, content) {
	      if (err) {
	        cb(err);
	        return;
	      }
	
	      cb(content.hits);
	    });
	  };
	}, 'ttAdapter is not necessary anymore and will be removed in the next version,\n' + 'have a look at autocomplete.js (https://github.com/algolia/autocomplete.js)');
	
	/*
	* Wait the publication of a task on the server.
	* All server task are asynchronous and you can check with this method that the task is published.
	*
	* @param taskID the id of the task returned by server
	* @param callback the result callback with with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains the list of results
	*/
	Index.prototype.waitTask = function (taskID, callback) {
	  // wait minimum 100ms before retrying
	  var baseDelay = 100;
	  // wait maximum 5s before retrying
	  var maxDelay = 5000;
	  var loop = 0;
	
	  // waitTask() must be handled differently from other methods,
	  // it's a recursive method using a timeout
	  var indexObj = this;
	  var client = indexObj.as;
	
	  var promise = retryLoop();
	
	  function retryLoop() {
	    return client._jsonRequest({
	      method: 'GET',
	      hostType: 'read',
	      url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/task/' + taskID
	    }).then(function success(content) {
	      loop++;
	      var delay = baseDelay * loop * loop;
	      if (delay > maxDelay) {
	        delay = maxDelay;
	      }
	
	      if (content.status !== 'published') {
	        return client._promise.delay(delay).then(retryLoop);
	      }
	
	      return content;
	    });
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(successCb, failureCb);
	
	  function successCb(content) {
	    exitPromise(function exit() {
	      callback(null, content);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failureCb(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* This function deletes the index content. Settings and index specific API keys are kept untouched.
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.clearIndex = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/clear',
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Get settings of this index
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.getSettings = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?getVersion=2',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.searchSynonyms = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveSynonym = function (synonym, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(synonym.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: synonym,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getSynonym = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteSynonym = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearSynonyms = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchSynonyms = function (synonyms, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/batch' + '?forwardToReplicas=' + forwardToReplicas + '&replaceExistingSynonyms=' + (opts.replaceExistingSynonyms ? 'true' : 'false'),
	    hostType: 'write',
	    body: synonyms,
	    callback: callback
	  });
	};
	
	Index.prototype.searchRules = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveRule = function (rule, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(rule.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: rule,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getRule = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteRule = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearRules = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchRules = function (rules, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/batch' + '?forwardToReplicas=' + forwardToReplicas + '&clearExistingRules=' + (opts.clearExistingRules === true ? 'true' : 'false'),
	    hostType: 'write',
	    body: rules,
	    callback: callback
	  });
	};
	
	/*
	* Set settings for this index
	*
	* @param settigns the settings object that can contains :
	* - minWordSizefor1Typo: (integer) the minimum number of characters to accept one typo (default = 3).
	* - minWordSizefor2Typos: (integer) the minimum number of characters to accept two typos (default = 7).
	* - hitsPerPage: (integer) the number of hits per page (default = 10).
	* - attributesToRetrieve: (array of strings) default list of attributes to retrieve in objects.
	*   If set to null, all attributes are retrieved.
	* - attributesToHighlight: (array of strings) default list of attributes to highlight.
	*   If set to null, all indexed attributes are highlighted.
	* - attributesToSnippet**: (array of strings) default list of attributes to snippet alongside the number
	* of words to return (syntax is attributeName:nbWords).
	*   By default no snippet is computed. If set to null, no snippet is computed.
	* - attributesToIndex: (array of strings) the list of fields you want to index.
	*   If set to null, all textual and numerical attributes of your objects are indexed,
	*   but you should update it to get optimal results.
	*   This parameter has two important uses:
	*     - Limit the attributes to index: For example if you store a binary image in base64,
	*     you want to store it and be able to
	*       retrieve it but you don't want to search in the base64 string.
	*     - Control part of the ranking*: (see the ranking parameter for full explanation)
	*     Matches in attributes at the beginning of
	*       the list will be considered more important than matches in attributes further down the list.
	*       In one attribute, matching text at the beginning of the attribute will be
	*       considered more important than text after, you can disable
	*       this behavior if you add your attribute inside `unordered(AttributeName)`,
	*       for example attributesToIndex: ["title", "unordered(text)"].
	* - attributesForFaceting: (array of strings) The list of fields you want to use for faceting.
	*   All strings in the attribute selected for faceting are extracted and added as a facet.
	*   If set to null, no attribute is used for faceting.
	* - attributeForDistinct: (string) The attribute name used for the Distinct feature.
	* This feature is similar to the SQL "distinct" keyword: when enabled
	*   in query with the distinct=1 parameter, all hits containing a duplicate
	*   value for this attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best one is kept and others are removed.
	* - ranking: (array of strings) controls the way results are sorted.
	*   We have six available criteria:
	*    - typo: sort according to number of typos,
	*    - geo: sort according to decreassing distance when performing a geo-location based search,
	*    - proximity: sort according to the proximity of query words in hits,
	*    - attribute: sort according to the order of attributes defined by attributesToIndex,
	*    - exact:
	*        - if the user query contains one word: sort objects having an attribute
	*        that is exactly the query word before others.
	*          For example if you search for the "V" TV show, you want to find it
	*          with the "V" query and avoid to have all popular TV
	*          show starting by the v letter before it.
	*        - if the user query contains multiple words: sort according to the
	*        number of words that matched exactly (and not as a prefix).
	*    - custom: sort according to a user defined formula set in **customRanking** attribute.
	*   The standard order is ["typo", "geo", "proximity", "attribute", "exact", "custom"]
	* - customRanking: (array of strings) lets you specify part of the ranking.
	*   The syntax of this condition is an array of strings containing attributes
	*   prefixed by asc (ascending order) or desc (descending order) operator.
	*   For example `"customRanking" => ["desc(population)", "asc(name)"]`
	* - queryType: Select how the query words are interpreted, it can be one of the following value:
	*   - prefixAll: all query words are interpreted as prefixes,
	*   - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*   - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - highlightPreTag: (string) Specify the string that is inserted before
	* the highlighted parts in the query result (default to "<em>").
	* - highlightPostTag: (string) Specify the string that is inserted after
	* the highlighted parts in the query result (default to "</em>").
	* - optionalWords: (array of strings) Specify a list of words that should
	* be considered as optional when found in the query.
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer or the error message if a failure occured
	*/
	Index.prototype.setSettings = function (settings, opts, callback) {
	  if (arguments.length === 1 || typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    body: settings,
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.listApiKeys
	 */
	Index.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('index.listUserKeys()', 'index.listApiKeys()'));
	
	/*
	* List all existing API keys to this index
	*
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with API keys belonging to the index
	*/
	Index.prototype.listApiKeys = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.getApiKey
	 */
	Index.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('index.getUserKeyACL()', 'index.getApiKey()'));
	
	/*
	* Get an API key from this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the right API key
	*/
	Index.prototype.getApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.deleteApiKey
	 */
	Index.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('index.deleteUserKey()', 'index.deleteApiKey()'));
	
	/*
	* Delete an existing API key associated to this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the deletion date
	*/
	Index.prototype.deleteApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.addApiKey
	 */
	Index.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKey()', 'index.addApiKey()'));
	
	/*
	* Add a new API key to this index
	*
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the added API key
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.addUserKey(['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#AddIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	* @deprecated use index.addApiKey()
	*/
	Index.prototype.addUserKeyWithValidity = deprecate(function deprecatedAddUserKeyWithValidity(acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKeyWithValidity()', 'index.addApiKey()'));
	
	/*
	 @deprecated see index.updateApiKey
	 */
	Index.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('index.updateUserKey()', 'index.updateApiKey()'));
	
	/**
	* Update an existing API key of this index
	* @param {string} key - The key to update
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with user keys list
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.updateApiKey('APIKEY', ['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';
	
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var buildSearchMethod = __webpack_require__(18);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	
	module.exports = IndexCore;
	
	/*
	* Index class constructor.
	* You should not use this method directly but use initIndex() function
	*/
	function IndexCore(algoliasearch, indexName) {
	  this.indexName = indexName;
	  this.as = algoliasearch;
	  this.typeAheadArgs = null;
	  this.typeAheadValueOption = null;
	
	  // make sure every index instance has it's own cache
	  this.cache = {};
	}
	
	/*
	* Clear all queries in cache
	*/
	IndexCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/*
	* Search inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the full text query
	* @param {object} [args] (optional) if set, contains an object with query parameters:
	* - page: (integer) Pagination parameter used to select the page to retrieve.
	*                   Page is zero-based and defaults to 0. Thus,
	*                   to retrieve the 10th page you need to set page=9
	* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.
	* - attributesToRetrieve: a string that contains the list of object attributes
	* you want to retrieve (let you minimize the answer size).
	*   Attributes are separated with a comma (for example "name,address").
	*   You can also use an array (for example ["name","address"]).
	*   By default, all attributes are retrieved. You can also use '*' to retrieve all
	*   values when an attributesToRetrieve setting is specified for your index.
	* - attributesToHighlight: a string that contains the list of attributes you
	*   want to highlight according to the query.
	*   Attributes are separated by a comma. You can also use an array (for example ["name","address"]).
	*   If an attribute has no match for the query, the raw value is returned.
	*   By default all indexed text attributes are highlighted.
	*   You can use `*` if you want to highlight all textual attributes.
	*   Numerical attributes are not highlighted.
	*   A matchLevel is returned for each highlighted attribute and can contain:
	*      - full: if all the query terms were found in the attribute,
	*      - partial: if only some of the query terms were found,
	*      - none: if none of the query terms were found.
	* - attributesToSnippet: a string that contains the list of attributes to snippet alongside
	* the number of words to return (syntax is `attributeName:nbWords`).
	*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).
	*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).
	*    By default no snippet is computed.
	* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.
	* Defaults to 3.
	* - minWordSizefor2Typos: the minimum number of characters in a query word
	* to accept two typos in this word. Defaults to 7.
	* - getRankingInfo: if set to 1, the result hits will contain ranking
	* information in _rankingInfo attribute.
	* - aroundLatLng: search for entries around a given
	* latitude/longitude (specified as two floats separated by a comma).
	*   For example aroundLatLng=47.316669,5.016670).
	*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)
	*   and the precision for ranking with aroundPrecision
	*   (for example if you set aroundPrecision=100, two objects that are distant of
	*   less than 100m will be considered as identical for "geo" ranking parameter).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - insideBoundingBox: search entries inside a given area defined by the two extreme points
	* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).
	*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - numericFilters: a string that contains the list of numeric filters you want to
	* apply separated by a comma.
	*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.
	*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.
	*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.
	*   You can also use an array (for example numericFilters: ["price>100","price<1000"]).
	* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.
	*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).
	*   You can also use an array, for example tagFilters: ["tag1",["tag2","tag3"]]
	*   means tag1 AND (tag2 OR tag3).
	*   At indexing, tags should be added in the _tags** attribute
	*   of objects (for example {"_tags":["tag1","tag2"]}).
	* - facetFilters: filter the query by a list of facets.
	*   Facets are separated by commas and each facet is encoded as `attributeName:value`.
	*   For example: `facetFilters=category:Book,author:John%20Doe`.
	*   You can also use an array (for example `["category:Book","author:John%20Doe"]`).
	* - facets: List of object attributes that you want to use for faceting.
	*   Comma separated list: `"category,author"` or array `['category','author']`
	*   Only attributes that have been added in **attributesForFaceting** index setting
	*   can be used in this parameter.
	*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.
	* - queryType: select how the query words are interpreted, it can be one of the following value:
	*    - prefixAll: all query words are interpreted as prefixes,
	*    - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - optionalWords: a string that contains the list of words that should
	* be considered as optional when found in the query.
	*   Comma separated and array are accepted.
	* - distinct: If set to 1, enable the distinct feature (disabled by default)
	* if the attributeForDistinct index setting is set.
	*   This feature is similar to the SQL "distinct" keyword: when enabled
	*   in a query with the distinct=1 parameter,
	*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best
	*   one is kept and others are removed.
	* - restrictSearchableAttributes: List of attributes you want to use for
	* textual search (must be a subset of the attributesToIndex index setting)
	* either comma separated or as an array
	* @param {function} [callback] the result callback called with two arguments:
	*  error: null or Error('message'). If false, the content contains the error.
	*  content: the server answer that contains the list of results.
	*/
	IndexCore.prototype.search = buildSearchMethod('query');
	
	/*
	* -- BETA --
	* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the similar query
	* @param {object} [args] (optional) if set, contains an object with query parameters.
	*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters
	*   are the two most useful to restrict the similar results and get more relevant content
	*/
	IndexCore.prototype.similarSearch = buildSearchMethod('similarQuery');
	
	/*
	* Browse index content. The response content will have a `cursor` property that you can use
	* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browse('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* }, callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browse = function (query, queryParameters, callback) {
	  var merge = __webpack_require__(23);
	
	  var indexObj = this;
	
	  var page;
	  var hitsPerPage;
	
	  // we check variadic calls that are not the one defined
	  // .browse()/.browse(fn)
	  // => page = 0
	  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {
	    page = 0;
	    callback = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'number') {
	    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)
	    page = arguments[0];
	    if (typeof arguments[1] === 'number') {
	      hitsPerPage = arguments[1];
	    } else if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	      hitsPerPage = undefined;
	    }
	    query = undefined;
	    queryParameters = undefined;
	  } else if (_typeof(arguments[0]) === 'object') {
	    // .browse(queryParameters)/.browse(queryParameters, cb)
	    if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	    }
	    queryParameters = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {
	    // .browse(query, cb)
	    callback = arguments[1];
	    queryParameters = undefined;
	  }
	
	  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)
	
	  // get search query parameters combining various possible calls
	  // to .browse();
	  queryParameters = merge({}, queryParameters || {}, {
	    page: page,
	    hitsPerPage: hitsPerPage,
	    query: query
	  });
	
	  var params = this.as._getSearchParams(queryParameters, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',
	    body: { params: params },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browseFrom('14lkfsakl32', callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browseFrom = function (cursor, callback) {
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',
	    body: { cursor: cursor },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Search for facet values
	* https://www.algolia.com/doc/rest-api/search#search-for-facet-values
	*
	* @param {string} params.facetName Facet name, name of the attribute to search for values in.
	* Must be declared as a facet
	* @param {string} params.facetQuery Query for the facet search
	* @param {string} [params.*] Any search parameter of Algolia,
	* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters
	* Pagination is not supported. The page and hitsPerPage parameters will be ignored.
	* @param callback (optional)
	*/
	IndexCore.prototype.searchForFacetValues = function (params, callback) {
	  var clone = __webpack_require__(24);
	  var omit = __webpack_require__(25);
	  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';
	
	  if (params.facetName === undefined || params.facetQuery === undefined) {
	    throw new Error(usage);
	  }
	
	  var facetName = params.facetName;
	  var filteredParams = omit(clone(params), function (keyName) {
	    return keyName === 'facetName';
	  });
	  var searchParameters = this.as._getSearchParams(filteredParams, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',
	    hostType: 'read',
	    body: { params: searchParameters },
	    callback: callback
	  });
	};
	
	IndexCore.prototype.searchFacet = deprecate(function (params, callback) {
	  return this.searchForFacetValues(params, callback);
	}, deprecatedMessage('index.searchFacet(params[, callback])', 'index.searchForFacetValues(params[, callback])'));
	
	IndexCore.prototype._search = function (params, url, callback, additionalUA) {
	  return this.as._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',
	    body: { params: params },
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/' + encodeURIComponent(this.indexName),
	      body: { params: params }
	    },
	    callback: callback,
	    additionalUA: additionalUA
	  });
	};
	
	/*
	* Get an object from this index
	*
	* @param objectID the unique identifier of the object to retrieve
	* @param attrs (optional) if set, contains the array of attribute names to retrieve
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the object to retrieve or the error message if a failure occured
	*/
	IndexCore.prototype.getObject = function (objectID, attrs, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attrs === 'function') {
	    callback = attrs;
	    attrs = undefined;
	  }
	
	  var params = '';
	  if (attrs !== undefined) {
	    params = '?attributes=';
	    for (var i = 0; i < attrs.length; ++i) {
	      if (i !== 0) {
	        params += ',';
	      }
	      params += attrs[i];
	    }
	  }
	
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Get several objects from this index
	*
	* @param objectIDs the array of unique identifier of objects to retrieve
	*/
	IndexCore.prototype.getObjects = function (objectIDs, attributesToRetrieve, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {
	    callback = attributesToRetrieve;
	    attributesToRetrieve = undefined;
	  }
	
	  var body = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      var request = {
	        indexName: indexObj.indexName,
	        objectID: objectID
	      };
	
	      if (attributesToRetrieve) {
	        request.attributesToRetrieve = attributesToRetrieve.join(',');
	      }
	
	      return request;
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/objects',
	    hostType: 'read',
	    body: body,
	    callback: callback
	  });
	};
	
	IndexCore.prototype.as = null;
	IndexCore.prototype.indexName = null;
	IndexCore.prototype.typeAheadArgs = null;
	IndexCore.prototype.typeAheadValueOption = null;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = buildSearchMethod;
	
	var errors = __webpack_require__(19);
	
	/**
	 * Creates a search method to be used in clients
	 * @param {string} queryParam the name of the attribute used for the query
	 * @param {string} url the url
	 * @return {function} the search method
	 */
	function buildSearchMethod(queryParam, url) {
	  /**
	   * The search method. Prepares the data and send the query to Algolia.
	   * @param {string} query the string used for query search
	   * @param {object} args additional parameters to send with the search
	   * @param {function} [callback] the callback to be called with the client gets the answer
	   * @return {undefined|Promise} If the callback is not provided then this methods returns a Promise
	   */
	  return function search(query, args, callback) {
	    // warn V2 users on how to search
	    if (typeof query === 'function' && (typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' || (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) === 'object') {
	      // .search(query, params, cb)
	      // .search(cb, params)
	      throw new errors.AlgoliaSearchError('index.search usage is index.search(query, params, cb)');
	    }
	
	    // Normalizing the function signature
	    if (arguments.length === 0 || typeof query === 'function') {
	      // Usage : .search(), .search(cb)
	      callback = query;
	      query = '';
	    } else if (arguments.length === 1 || typeof args === 'function') {
	      // Usage : .search(query/args), .search(query, cb)
	      callback = args;
	      args = undefined;
	    }
	    // At this point we have 3 arguments with values
	
	    // Usage : .search(args) // careful: typeof null === 'object'
	    if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object' && query !== null) {
	      args = query;
	      query = undefined;
	    } else if (query === undefined || query === null) {
	      // .search(undefined/null)
	      query = '';
	    }
	
	    var params = '';
	
	    if (query !== undefined) {
	      params += queryParam + '=' + encodeURIComponent(query);
	    }
	
	    var additionalUA;
	    if (args !== undefined) {
	      if (args.additionalUA) {
	        additionalUA = args.additionalUA;
	        delete args.additionalUA;
	      }
	      // `_getSearchParams` will augment params, do not be fooled by the = versus += from previous if
	      params = this.as._getSearchParams(args, params);
	    }
	
	    return this._search(params, url, callback, additionalUA);
	  };
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This file hosts our error definitions
	// We use custom error "types" so that we can act on them when we need it
	// e.g.: if error instanceof errors.UnparsableJSON then..
	
	var inherits = __webpack_require__(16);
	
	function AlgoliaSearchError(message, extraProperties) {
	  var forEach = __webpack_require__(20);
	
	  var error = this;
	
	  // try to get a stacktrace
	  if (typeof Error.captureStackTrace === 'function') {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    error.stack = new Error().stack || 'Cannot get a stacktrace, browser is too old';
	  }
	
	  this.name = 'AlgoliaSearchError';
	  this.message = message || 'Unknown error';
	
	  if (extraProperties) {
	    forEach(extraProperties, function addToErrorObject(value, key) {
	      error[key] = value;
	    });
	  }
	}
	
	inherits(AlgoliaSearchError, Error);
	
	function createCustomError(name, message) {
	  function AlgoliaSearchCustomError() {
	    var args = Array.prototype.slice.call(arguments, 0);
	
	    // custom message not set, use default
	    if (typeof args[0] !== 'string') {
	      args.unshift(message);
	    }
	
	    AlgoliaSearchError.apply(this, args);
	    this.name = 'AlgoliaSearch' + name + 'Error';
	  }
	
	  inherits(AlgoliaSearchCustomError, AlgoliaSearchError);
	
	  return AlgoliaSearchCustomError;
	}
	
	// late exports to let various fn defs and inherits take place
	module.exports = {
	  AlgoliaSearchError: AlgoliaSearchError,
	  UnparsableJSON: createCustomError('UnparsableJSON', 'Could not parse the incoming response as JSON, see err.more for details'),
	  RequestTimeout: createCustomError('RequestTimeout', 'Request timedout before getting a response'),
	  Network: createCustomError('Network', 'Network issue, see err.more for details'),
	  JSONPScriptFail: createCustomError('JSONPScriptFail', '<script> was loaded but did not call our provided callback'),
	  JSONPScriptError: createCustomError('JSONPScriptError', '<script> unable to load due to an `error` event on it'),
	  Unknown: createCustomError('Unknown', 'Unknown error occured')
	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = function forEach(obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function deprecate(fn, message) {
	  var warned = false;
	
	  function deprecated() {
	    if (!warned) {
	      /* eslint no-console:0 */
	      console.warn(message);
	      warned = true;
	    }
	
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function deprecatedMessage(previousUsage, newUsage) {
	  var githubAnchorLink = previousUsage.toLowerCase().replace(/[\.\(\)]/g, '');
	
	  return 'algoliasearch: `' + previousUsage + '` was replaced by `' + newUsage + '`. Please see https://github.com/algolia/algoliasearch-client-javascript/wiki/Deprecated#' + githubAnchorLink;
	};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var foreach = __webpack_require__(20);
	
	module.exports = function merge(destination /* , sources */) {
	  var sources = Array.prototype.slice.call(arguments);
	
	  foreach(sources, function (source) {
	    for (var keyName in source) {
	      if (source.hasOwnProperty(keyName)) {
	        if (_typeof(destination[keyName]) === 'object' && _typeof(source[keyName]) === 'object') {
	          destination[keyName] = merge({}, destination[keyName], source[keyName]);
	        } else if (source[keyName] !== undefined) {
	          destination[keyName] = source[keyName];
	        }
	      }
	    }
	  });
	
	  return destination;
	};

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function clone(obj) {
	  return JSON.parse(JSON.stringify(obj));
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = function omit(obj, test) {
	  var keys = __webpack_require__(26);
	  var foreach = __webpack_require__(20);
	
	  var filtered = {};
	
	  foreach(keys(obj), function doFilter(keyName) {
	    if (test(keyName) !== true) {
	      filtered[keyName] = obj[keyName];
	    }
	  });
	
	  return filtered;
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// modified from https://github.com/es-shims/es5-shim
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(27);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
	var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = function () {
		/* global window */
		if (typeof window === 'undefined') {
			return false;
		}
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}();
	var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};
	
	var keysShim = function keys(object) {
		var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];
	
		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}
	
		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}
	
		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}
	
		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	
			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
	
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2);
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};
	
	module.exports = keysShim;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toStr = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	'use strict';
	
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var foreach = __webpack_require__(20);
	
	module.exports = function map(arr, fn) {
	  var newArr = [];
	  foreach(arr, function (item, itemIndex) {
	    newArr.push(fn(item, itemIndex, arr));
	  });
	  return newArr;
	};

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	"use strict";
	
	// Parse cloud does not supports setTimeout
	// We do not store a setTimeout reference in the client everytime
	// We only fallback to a fake setTimeout when not available
	// setTimeout cannot be override globally sadly
	module.exports = function exitPromise(fn, _setTimeout) {
	  _setTimeout(fn, 0);
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This is the object returned by the `index.browseAll()` method
	
	module.exports = IndexBrowser;
	
	var inherits = __webpack_require__(16);
	var EventEmitter = __webpack_require__(32).EventEmitter;
	
	function IndexBrowser() {}
	
	inherits(IndexBrowser, EventEmitter);
	
	IndexBrowser.prototype.stop = function () {
	  this._stopped = true;
	  this._clean();
	};
	
	IndexBrowser.prototype._end = function () {
	  this.emit('end');
	  this._clean();
	};
	
	IndexBrowser.prototype._error = function (err) {
	  this.emit('error', err);
	  this._clean();
	};
	
	IndexBrowser.prototype._result = function (content) {
	  this.emit('result', content);
	};
	
	IndexBrowser.prototype._clean = function () {
	  this.removeAllListeners('stop');
	  this.removeAllListeners('end');
	  this.removeAllListeners('error');
	  this.removeAllListeners('result');
	};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function (type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events) this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler)) return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function (type, listener) {
	  var m;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events) this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function (type, listener) {
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function (type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type]) return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener || isFunction(list.listener) && list.listener === listener) {
	    delete this._events[type];
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0) return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function (type) {
	  var key, listeners;
	
	  if (!this._events) return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length) {
	      this.removeListener(type, listeners[listeners.length - 1]);
	    }
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function (type) {
	  var ret;
	  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function (type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function (emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = AlgoliaSearchCore;
	
	var errors = __webpack_require__(19);
	var exitPromise = __webpack_require__(30);
	var IndexCore = __webpack_require__(17);
	var store = __webpack_require__(34);
	
	// We will always put the API KEY in the JSON body in case of too long API KEY,
	// to avoid query string being too long and failing in various conditions (our server limit, browser limit,
	// proxies limit)
	var MAX_API_KEY_LENGTH = 500;
	var RESET_APP_DATA_TIMER = process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) || 60 * 2 * 1000; // after 2 minutes reset to first host
	
	/*
	 * Algolia Search library initialization
	 * https://www.algolia.com/
	 *
	 * @param {string} applicationID - Your applicationID, found in your dashboard
	 * @param {string} apiKey - Your API key, found in your dashboard
	 * @param {Object} [opts]
	 * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,
	 * another request will be issued after this timeout
	 * @param {string} [opts.protocol='http:'] - The protocol used to query Algolia Search API.
	 *                                        Set to 'https:' to force using https.
	 *                                        Default to document.location.protocol in browsers
	 * @param {Object|Array} [opts.hosts={
	 *           read: [this.applicationID + '-dsn.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]),
	 *           write: [this.applicationID + '.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]) - The hosts to use for Algolia Search API.
	 *           If you provide them, you will less benefit from our HA implementation
	 */
	function AlgoliaSearchCore(applicationID, apiKey, opts) {
	  var debug = __webpack_require__(35)('algoliasearch');
	
	  var clone = __webpack_require__(24);
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';
	
	  if (opts._allowEmptyCredentials !== true && !applicationID) {
	    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);
	  }
	
	  if (opts._allowEmptyCredentials !== true && !apiKey) {
	    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);
	  }
	
	  this.applicationID = applicationID;
	  this.apiKey = apiKey;
	
	  this.hosts = {
	    read: [],
	    write: []
	  };
	
	  opts = opts || {};
	
	  var protocol = opts.protocol || 'https:';
	  this._timeouts = opts.timeouts || {
	    connect: 1 * 1000, // 500ms connect is GPRS latency
	    read: 2 * 1000,
	    write: 30 * 1000
	  };
	
	  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before
	  if (opts.timeout) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;
	  }
	
	  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`
	  // we also accept `http` and `https`. It's a common error.
	  if (!/:$/.test(protocol)) {
	    protocol = protocol + ':';
	  }
	
	  if (opts.protocol !== 'http:' && opts.protocol !== 'https:') {
	    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');
	  }
	
	  this._checkAppIdData();
	
	  if (!opts.hosts) {
	    var defaultHosts = map(this._shuffleResult, function (hostNumber) {
	      return applicationID + '-' + hostNumber + '.algolianet.com';
	    });
	
	    // no hosts given, compute defaults
	    this.hosts.read = [this.applicationID + '-dsn.algolia.net'].concat(defaultHosts);
	    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);
	  } else if (isArray(opts.hosts)) {
	    // when passing custom hosts, we need to have a different host index if the number
	    // of write/read hosts are different.
	    this.hosts.read = clone(opts.hosts);
	    this.hosts.write = clone(opts.hosts);
	  } else {
	    this.hosts.read = clone(opts.hosts.read);
	    this.hosts.write = clone(opts.hosts.write);
	  }
	
	  // add protocol and lowercase hosts
	  this.hosts.read = map(this.hosts.read, prepareHost(protocol));
	  this.hosts.write = map(this.hosts.write, prepareHost(protocol));
	
	  this.extraHeaders = {};
	
	  // In some situations you might want to warm the cache
	  this.cache = opts._cache || {};
	
	  this._ua = opts._ua;
	  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;
	  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;
	
	  this._setTimeout = opts._setTimeout;
	
	  debug('init done, %j', this);
	}
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearchCore.prototype.initIndex = function (indexName) {
	  return new IndexCore(this, indexName);
	};
	
	/**
	* Add an extra field to the HTTP request
	*
	* @param name the header field name
	* @param value the header field value
	*/
	AlgoliaSearchCore.prototype.setExtraHeader = function (name, value) {
	  this.extraHeaders[name.toLowerCase()] = value;
	};
	
	/**
	* Get the value of an extra HTTP header
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.getExtraHeader = function (name) {
	  return this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Remove an extra field from the HTTP request
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.unsetExtraHeader = function (name) {
	  delete this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Augment sent x-algolia-agent with more data, each agent part
	* is automatically separated from the others by a semicolon;
	*
	* @param algoliaAgent the agent to add
	*/
	AlgoliaSearchCore.prototype.addAlgoliaAgent = function (algoliaAgent) {
	  if (this._ua.indexOf(';' + algoliaAgent) === -1) {
	    this._ua += ';' + algoliaAgent;
	  }
	};
	
	/*
	 * Wrapper that try all hosts to maximize the quality of service
	 */
	AlgoliaSearchCore.prototype._jsonRequest = function (initialOpts) {
	  this._checkAppIdData();
	
	  var requestDebug = __webpack_require__(35)('algoliasearch:' + initialOpts.url);
	
	  var body;
	  var additionalUA = initialOpts.additionalUA || '';
	  var cache = initialOpts.cache;
	  var client = this;
	  var tries = 0;
	  var usingFallback = false;
	  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;
	  var headers;
	
	  if (this.apiKey.length > MAX_API_KEY_LENGTH && initialOpts.body !== undefined && (initialOpts.body.params !== undefined || // index.search()
	  initialOpts.body.requests !== undefined) // client.search()
	  ) {
	      initialOpts.body.apiKey = this.apiKey;
	      headers = this._computeRequestHeaders(additionalUA, false);
	    } else {
	    headers = this._computeRequestHeaders(additionalUA);
	  }
	
	  if (initialOpts.body !== undefined) {
	    body = safeJSONStringify(initialOpts.body);
	  }
	
	  requestDebug('request start');
	  var debugData = [];
	
	  function doRequest(requester, reqOpts) {
	    client._checkAppIdData();
	
	    var startTime = new Date();
	    var cacheID;
	
	    if (client._useCache) {
	      cacheID = initialOpts.url;
	    }
	
	    // as we sometime use POST requests to pass parameters (like query='aa'),
	    // the cacheID must also include the body to be different between calls
	    if (client._useCache && body) {
	      cacheID += '_body_' + reqOpts.body;
	    }
	
	    // handle cache existence
	    if (client._useCache && cache && cache[cacheID] !== undefined) {
	      requestDebug('serving response from cache');
	      return client._promise.resolve(JSON.parse(cache[cacheID]));
	    }
	
	    // if we reached max tries
	    if (tries >= client.hosts[initialOpts.hostType].length) {
	      if (!hasFallback || usingFallback) {
	        requestDebug('could not get any response');
	        // then stop
	        return client._promise.reject(new errors.AlgoliaSearchError('Cannot connect to the AlgoliaSearch API.' + ' Send an email to support@algolia.com to report and resolve the issue.' + ' Application id was: ' + client.applicationID, { debugData: debugData }));
	      }
	
	      requestDebug('switching to fallback');
	
	      // let's try the fallback starting from here
	      tries = 0;
	
	      // method, url and body are fallback dependent
	      reqOpts.method = initialOpts.fallback.method;
	      reqOpts.url = initialOpts.fallback.url;
	      reqOpts.jsonBody = initialOpts.fallback.body;
	      if (reqOpts.jsonBody) {
	        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);
	      }
	      // re-compute headers, they could be omitting the API KEY
	      headers = client._computeRequestHeaders(additionalUA);
	
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      client._setHostIndexByType(0, initialOpts.hostType);
	      usingFallback = true; // the current request is now using fallback
	      return doRequest(client._request.fallback, reqOpts);
	    }
	
	    var currentHost = client._getHostByType(initialOpts.hostType);
	
	    var url = currentHost + reqOpts.url;
	    var options = {
	      body: reqOpts.body,
	      jsonBody: reqOpts.jsonBody,
	      method: reqOpts.method,
	      headers: headers,
	      timeouts: reqOpts.timeouts,
	      debug: requestDebug
	    };
	
	    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d', options.method, url, options.headers, options.timeouts);
	
	    if (requester === client._request.fallback) {
	      requestDebug('using fallback');
	    }
	
	    // `requester` is any of this._request or this._request.fallback
	    // thus it needs to be called using the client as context
	    return requester.call(client, url, options).then(success, tryFallback);
	
	    function success(httpResponse) {
	      // compute the status of the response,
	      //
	      // When in browser mode, using XDR or JSONP, we have no statusCode available
	      // So we rely on our API response `status` property.
	      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)
	      // So we check if there's a `message` along `status` and it means it's an error
	      //
	      // That's the only case where we have a response.status that's not the http statusCode
	      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||
	
	      // this is important to check the request statusCode AFTER the body eventual
	      // statusCode because some implementations (jQuery XDomainRequest transport) may
	      // send statusCode 200 while we had an error
	      httpResponse.statusCode ||
	
	      // When in browser mode, using XDR or JSONP
	      // we default to success when no error (no response.status && response.message)
	      // If there was a JSON.parse() error then body is null and it fails
	      httpResponse && httpResponse.body && 200;
	
	      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j', httpResponse.statusCode, status, httpResponse.headers);
	
	      var httpResponseOk = Math.floor(status / 100) === 2;
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime,
	        statusCode: status
	      });
	
	      if (httpResponseOk) {
	        if (client._useCache && cache) {
	          cache[cacheID] = httpResponse.responseText;
	        }
	
	        return httpResponse.body;
	      }
	
	      var shouldRetry = Math.floor(status / 100) !== 4;
	
	      if (shouldRetry) {
	        tries += 1;
	        return retryRequest();
	      }
	
	      requestDebug('unrecoverable error');
	
	      // no success and no retry => fail
	      var unrecoverableError = new errors.AlgoliaSearchError(httpResponse.body && httpResponse.body.message, { debugData: debugData, statusCode: status });
	
	      return client._promise.reject(unrecoverableError);
	    }
	
	    function tryFallback(err) {
	      // error cases:
	      //  While not in fallback mode:
	      //    - CORS not supported
	      //    - network error
	      //  While in fallback mode:
	      //    - timeout
	      //    - network error
	      //    - badly formatted JSONP (script loaded, did not call our callback)
	      //  In both cases:
	      //    - uncaught exception occurs (TypeError)
	      requestDebug('error: %s, stack: %s', err.message, err.stack);
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime
	      });
	
	      if (!(err instanceof errors.AlgoliaSearchError)) {
	        err = new errors.Unknown(err && err.message, err);
	      }
	
	      tries += 1;
	
	      // stop the request implementation when:
	      if (
	      // we did not generate this error,
	      // it comes from a throw in some other piece of code
	      err instanceof errors.Unknown ||
	
	      // server sent unparsable JSON
	      err instanceof errors.UnparsableJSON ||
	
	      // max tries and already using fallback or no fallback
	      tries >= client.hosts[initialOpts.hostType].length && (usingFallback || !hasFallback)) {
	        // stop request implementation for this command
	        err.debugData = debugData;
	        return client._promise.reject(err);
	      }
	
	      // When a timeout occured, retry by raising timeout
	      if (err instanceof errors.RequestTimeout) {
	        return retryRequestWithHigherTimeout();
	      }
	
	      return retryRequest();
	    }
	
	    function retryRequest() {
	      requestDebug('retrying request');
	      client._incrementHostIndex(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	
	    function retryRequestWithHigherTimeout() {
	      requestDebug('retrying request with higher timeout');
	      client._incrementHostIndex(initialOpts.hostType);
	      client._incrementTimeoutMultipler();
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	  }
	
	  var promise = doRequest(client._request, {
	    url: initialOpts.url,
	    method: initialOpts.method,
	    body: body,
	    jsonBody: initialOpts.body,
	    timeouts: client._getTimeoutsForRequest(initialOpts.hostType)
	  });
	
	  // either we have a callback
	  // either we are using promises
	  if (typeof initialOpts.callback === 'function') {
	    promise.then(function okCb(content) {
	      exitPromise(function () {
	        initialOpts.callback(null, content);
	      }, client._setTimeout || setTimeout);
	    }, function nookCb(err) {
	      exitPromise(function () {
	        initialOpts.callback(err);
	      }, client._setTimeout || setTimeout);
	    });
	  } else {
	    return promise;
	  }
	};
	
	/*
	* Transform search param object in query string
	* @param {object} args arguments to add to the current query string
	* @param {string} params current query string
	* @return {string} the final query string
	*/
	AlgoliaSearchCore.prototype._getSearchParams = function (args, params) {
	  if (args === undefined || args === null) {
	    return params;
	  }
	  for (var key in args) {
	    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {
	      params += params === '' ? '' : '&';
	      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);
	    }
	  }
	  return params;
	};
	
	AlgoliaSearchCore.prototype._computeRequestHeaders = function (additionalUA, withAPIKey) {
	  var forEach = __webpack_require__(20);
	
	  var ua = additionalUA ? this._ua + ';' + additionalUA : this._ua;
	
	  var requestHeaders = {
	    'x-algolia-agent': ua,
	    'x-algolia-application-id': this.applicationID
	  };
	
	  // browser will inline headers in the url, node.js will use http headers
	  // but in some situations, the API KEY will be too long (big secured API keys)
	  // so if the request is a POST and the KEY is very long, we will be asked to not put
	  // it into headers but in the JSON body
	  if (withAPIKey !== false) {
	    requestHeaders['x-algolia-api-key'] = this.apiKey;
	  }
	
	  if (this.userToken) {
	    requestHeaders['x-algolia-usertoken'] = this.userToken;
	  }
	
	  if (this.securityTags) {
	    requestHeaders['x-algolia-tagfilters'] = this.securityTags;
	  }
	
	  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {
	    requestHeaders[key] = value;
	  });
	
	  return requestHeaders;
	};
	
	/**
	 * Search through multiple indices at the same time
	 * @param  {Object[]}   queries  An array of queries you want to run.
	 * @param {string} queries[].indexName The index name you want to target
	 * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`
	 * @param {Object} queries[].params Any search param like hitsPerPage, ..
	 * @param  {Function} callback Callback to be called
	 * @return {Promise|undefined} Returns a promise if no callback given
	 */
	AlgoliaSearchCore.prototype.search = function (queries, opts, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: client.search(arrayOfQueries[, callback])';
	
	  if (!isArray(queries)) {
	    throw new Error(usage);
	  }
	
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var client = this;
	
	  var postObj = {
	    requests: map(queries, function prepareRequest(query) {
	      var params = '';
	
	      // allow query.query
	      // so we are mimicing the index.search(query, params) method
	      // {indexName:, query:, params:}
	      if (query.query !== undefined) {
	        params += 'query=' + encodeURIComponent(query.query);
	      }
	
	      return {
	        indexName: query.indexName,
	        params: client._getSearchParams(query.params, params)
	      };
	    })
	  };
	
	  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {
	    return requestId + '=' + encodeURIComponent('/1/indexes/' + encodeURIComponent(request.indexName) + '?' + request.params);
	  }).join('&');
	
	  var url = '/1/indexes/*/queries';
	
	  if (opts.strategy !== undefined) {
	    url += '?strategy=' + opts.strategy;
	  }
	
	  return this._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url,
	    body: postObj,
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/*',
	      body: {
	        params: JSONPParams
	      }
	    },
	    callback: callback
	  });
	};
	
	/**
	 * Set the extra security tagFilters header
	 * @param {string|array} tags The list of tags defining the current security filters
	 */
	AlgoliaSearchCore.prototype.setSecurityTags = function (tags) {
	  if (Object.prototype.toString.call(tags) === '[object Array]') {
	    var strTags = [];
	    for (var i = 0; i < tags.length; ++i) {
	      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {
	        var oredTags = [];
	        for (var j = 0; j < tags[i].length; ++j) {
	          oredTags.push(tags[i][j]);
	        }
	        strTags.push('(' + oredTags.join(',') + ')');
	      } else {
	        strTags.push(tags[i]);
	      }
	    }
	    tags = strTags.join(',');
	  }
	
	  this.securityTags = tags;
	};
	
	/**
	 * Set the extra user token header
	 * @param {string} userToken The token identifying a uniq user (used to apply rate limits)
	 */
	AlgoliaSearchCore.prototype.setUserToken = function (userToken) {
	  this.userToken = userToken;
	};
	
	/**
	 * Clear all queries in client's cache
	 * @return undefined
	 */
	AlgoliaSearchCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/**
	* Set the number of milliseconds a request can take before automatically being terminated.
	* @deprecated
	* @param {Number} milliseconds
	*/
	AlgoliaSearchCore.prototype.setRequestTimeout = function (milliseconds) {
	  if (milliseconds) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;
	  }
	};
	
	/**
	* Set the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.setTimeouts = function (timeouts) {
	  this._timeouts = timeouts;
	};
	
	/**
	* Get the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.getTimeouts = function () {
	  return this._timeouts;
	};
	
	AlgoliaSearchCore.prototype._getAppIdData = function () {
	  var data = store.get(this.applicationID);
	  if (data !== null) this._cacheAppIdData(data);
	  return data;
	};
	
	AlgoliaSearchCore.prototype._setAppIdData = function (data) {
	  data.lastChange = new Date().getTime();
	  this._cacheAppIdData(data);
	  return store.set(this.applicationID, data);
	};
	
	AlgoliaSearchCore.prototype._checkAppIdData = function () {
	  var data = this._getAppIdData();
	  var now = new Date().getTime();
	  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {
	    return this._resetInitialAppIdData(data);
	  }
	
	  return data;
	};
	
	AlgoliaSearchCore.prototype._resetInitialAppIdData = function (data) {
	  var newData = data || {};
	  newData.hostIndexes = { read: 0, write: 0 };
	  newData.timeoutMultiplier = 1;
	  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);
	  return this._setAppIdData(newData);
	};
	
	AlgoliaSearchCore.prototype._cacheAppIdData = function (data) {
	  this._hostIndexes = data.hostIndexes;
	  this._timeoutMultiplier = data.timeoutMultiplier;
	  this._shuffleResult = data.shuffleResult;
	};
	
	AlgoliaSearchCore.prototype._partialAppIdDataUpdate = function (newData) {
	  var foreach = __webpack_require__(20);
	  var currentData = this._getAppIdData();
	  foreach(newData, function (value, key) {
	    currentData[key] = value;
	  });
	
	  return this._setAppIdData(currentData);
	};
	
	AlgoliaSearchCore.prototype._getHostByType = function (hostType) {
	  return this.hosts[hostType][this._getHostIndexByType(hostType)];
	};
	
	AlgoliaSearchCore.prototype._getTimeoutMultiplier = function () {
	  return this._timeoutMultiplier;
	};
	
	AlgoliaSearchCore.prototype._getHostIndexByType = function (hostType) {
	  return this._hostIndexes[hostType];
	};
	
	AlgoliaSearchCore.prototype._setHostIndexByType = function (hostIndex, hostType) {
	  var clone = __webpack_require__(24);
	  var newHostIndexes = clone(this._hostIndexes);
	  newHostIndexes[hostType] = hostIndex;
	  this._partialAppIdDataUpdate({ hostIndexes: newHostIndexes });
	  return hostIndex;
	};
	
	AlgoliaSearchCore.prototype._incrementHostIndex = function (hostType) {
	  return this._setHostIndexByType((this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType);
	};
	
	AlgoliaSearchCore.prototype._incrementTimeoutMultipler = function () {
	  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);
	  return this._partialAppIdDataUpdate({ timeoutMultiplier: timeoutMultiplier });
	};
	
	AlgoliaSearchCore.prototype._getTimeoutsForRequest = function (hostType) {
	  return {
	    connect: this._timeouts.connect * this._timeoutMultiplier,
	    complete: this._timeouts[hostType] * this._timeoutMultiplier
	  };
	};
	
	function prepareHost(protocol) {
	  return function prepare(host) {
	    return protocol + '//' + host.toLowerCase();
	  };
	}
	
	// Prototype.js < 1.7, a widely used library, defines a weird
	// Array.prototype.toJSON function that will fail to stringify our content
	// appropriately
	// refs:
	//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q
	//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c
	//   - http://stackoverflow.com/a/3148441/147079
	function safeJSONStringify(obj) {
	  /* eslint no-extend-native:0 */
	
	  if (Array.prototype.toJSON === undefined) {
	    return JSON.stringify(obj);
	  }
	
	  var toJSON = Array.prototype.toJSON;
	  delete Array.prototype.toJSON;
	  var out = JSON.stringify(obj);
	  Array.prototype.toJSON = toJSON;
	
	  return out;
	}
	
	function shuffle(array) {
	  var currentIndex = array.length;
	  var temporaryValue;
	  var randomIndex;
	
	  // While there remain elements to shuffle...
	  while (currentIndex !== 0) {
	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex -= 1;
	
	    // And swap it with the current element.
	    temporaryValue = array[currentIndex];
	    array[currentIndex] = array[randomIndex];
	    array[randomIndex] = temporaryValue;
	  }
	
	  return array;
	}
	
	function removeCredentials(headers) {
	  var newHeaders = {};
	
	  for (var headerName in headers) {
	    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {
	      var value;
	
	      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {
	        value = '**hidden for security purposes**';
	      } else {
	        value = headers[headerName];
	      }
	
	      newHeaders[headerName] = value;
	    }
	  }
	
	  return newHeaders;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var debug = __webpack_require__(35)('algoliasearch:src/hostIndexState.js');
	var localStorageNamespace = 'algoliasearch-client-js';
	
	var store;
	var moduleStore = {
	  state: {},
	  set: function set(key, data) {
	    this.state[key] = data;
	    return this.state[key];
	  },
	  get: function get(key) {
	    return this.state[key] || null;
	  }
	};
	
	var localStorageStore = {
	  set: function set(key, data) {
	    moduleStore.set(key, data); // always replicate localStorageStore to moduleStore in case of failure
	
	    try {
	      var namespace = JSON.parse(global.localStorage[localStorageNamespace]);
	      namespace[key] = data;
	      global.localStorage[localStorageNamespace] = JSON.stringify(namespace);
	      return namespace[key];
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  },
	  get: function get(key) {
	    try {
	      return JSON.parse(global.localStorage[localStorageNamespace])[key] || null;
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  }
	};
	
	function localStorageFailure(key, e) {
	  debug('localStorage failed with', e);
	  cleanup();
	  store = moduleStore;
	  return store.get(key);
	}
	
	store = supportsLocalStorage() ? localStorageStore : moduleStore;
	
	module.exports = {
	  get: getOrSet,
	  set: getOrSet,
	  supportsLocalStorage: supportsLocalStorage
	};
	
	function getOrSet(key, data) {
	  if (arguments.length === 1) {
	    return store.get(key);
	  }
	
	  return store.set(key, data);
	}
	
	function supportsLocalStorage() {
	  try {
	    if ('localStorage' in global && global.localStorage !== null) {
	      if (!global.localStorage[localStorageNamespace]) {
	        // actual creation of the namespace
	        global.localStorage.setItem(localStorageNamespace, JSON.stringify({}));
	      }
	      return true;
	    }
	
	    return false;
	  } catch (_) {
	    return false;
	  }
	}
	
	// In case of any error on localStorage, we clean our own namespace, this should handle
	// quota errors when a lot of keys + data are used
	function cleanup() {
	  try {
	    global.localStorage.removeItem(localStorageNamespace);
	  } catch (_) {
	    // nothing to do
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(36);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
	  // double check webkit in userAgent just in case we are in a worker
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(37);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0,
	      i;
	
	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var global = __webpack_require__(39);
	var Promise = global.Promise || __webpack_require__(40).Promise;
	
	// This is the standalone browser build entry point
	// Browser implementation of the Algolia Search JavaScript client,
	// using XMLHttpRequest, XDomainRequest and JSONP as fallback
	module.exports = function createAlgoliasearch(AlgoliaSearch, uaSuffix) {
	  var inherits = __webpack_require__(16);
	  var errors = __webpack_require__(19);
	  var inlineHeaders = __webpack_require__(42);
	  var jsonpRequest = __webpack_require__(44);
	  var places = __webpack_require__(45);
	  uaSuffix = uaSuffix || '';
	
	  if (process.env.NODE_ENV === 'debug') {
	    __webpack_require__(35).enable('algoliasearch*');
	  }
	
	  function algoliasearch(applicationID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    var getDocumentProtocol = __webpack_require__(46);
	
	    opts = cloneDeep(opts || {});
	
	    if (opts.protocol === undefined) {
	      opts.protocol = getDocumentProtocol();
	    }
	
	    opts._ua = opts._ua || algoliasearch.ua;
	
	    return new AlgoliaSearchBrowser(applicationID, apiKey, opts);
	  }
	
	  algoliasearch.version = __webpack_require__(47);
	  algoliasearch.ua = 'Algolia for vanilla JavaScript ' + uaSuffix + algoliasearch.version;
	  algoliasearch.initPlaces = places(algoliasearch);
	
	  // we expose into window no matter how we are used, this will allow
	  // us to easily debug any website running algolia
	  global.__algolia = {
	    debug: __webpack_require__(35),
	    algoliasearch: algoliasearch
	  };
	
	  var support = {
	    hasXMLHttpRequest: 'XMLHttpRequest' in global,
	    hasXDomainRequest: 'XDomainRequest' in global
	  };
	
	  if (support.hasXMLHttpRequest) {
	    support.cors = 'withCredentials' in new XMLHttpRequest();
	  }
	
	  function AlgoliaSearchBrowser() {
	    // call AlgoliaSearch constructor
	    AlgoliaSearch.apply(this, arguments);
	  }
	
	  inherits(AlgoliaSearchBrowser, AlgoliaSearch);
	
	  AlgoliaSearchBrowser.prototype._request = function request(url, opts) {
	    return new Promise(function wrapRequest(resolve, reject) {
	      // no cors or XDomainRequest, no request
	      if (!support.cors && !support.hasXDomainRequest) {
	        // very old browser, not supported
	        reject(new errors.Network('CORS not supported'));
	        return;
	      }
	
	      url = inlineHeaders(url, opts.headers);
	
	      var body = opts.body;
	      var req = support.cors ? new XMLHttpRequest() : new XDomainRequest();
	      var reqTimeout;
	      var timedOut;
	      var connected = false;
	
	      reqTimeout = setTimeout(onTimeout, opts.timeouts.connect);
	      // we set an empty onprogress listener
	      // so that XDomainRequest on IE9 is not aborted
	      // refs:
	      //  - https://github.com/algolia/algoliasearch-client-js/issues/76
	      //  - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
	      req.onprogress = onProgress;
	      if ('onreadystatechange' in req) req.onreadystatechange = onReadyStateChange;
	      req.onload = onLoad;
	      req.onerror = onError;
	
	      // do not rely on default XHR async flag, as some analytics code like hotjar
	      // breaks it and set it to false by default
	      if (req instanceof XMLHttpRequest) {
	        req.open(opts.method, url, true);
	      } else {
	        req.open(opts.method, url);
	      }
	
	      // headers are meant to be sent after open
	      if (support.cors) {
	        if (body) {
	          if (opts.method === 'POST') {
	            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests
	            req.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
	          } else {
	            req.setRequestHeader('content-type', 'application/json');
	          }
	        }
	        req.setRequestHeader('accept', 'application/json');
	      }
	
	      req.send(body);
	
	      // event object not received in IE8, at least
	      // but we do not use it, still important to note
	      function onLoad() /* event */{
	        // When browser does not supports req.timeout, we can
	        // have both a load and timeout event, since handled by a dumb setTimeout
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        var out;
	
	        try {
	          out = {
	            body: JSON.parse(req.responseText),
	            responseText: req.responseText,
	            statusCode: req.status,
	            // XDomainRequest does not have any response headers
	            headers: req.getAllResponseHeaders && req.getAllResponseHeaders() || {}
	          };
	        } catch (e) {
	          out = new errors.UnparsableJSON({
	            more: req.responseText
	          });
	        }
	
	        if (out instanceof errors.UnparsableJSON) {
	          reject(out);
	        } else {
	          resolve(out);
	        }
	      }
	
	      function onError(event) {
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        // error event is trigerred both with XDR/XHR on:
	        //   - DNS error
	        //   - unallowed cross domain request
	        reject(new errors.Network({
	          more: event
	        }));
	      }
	
	      function onTimeout() {
	        timedOut = true;
	        req.abort();
	
	        reject(new errors.RequestTimeout());
	      }
	
	      function onConnect() {
	        connected = true;
	        clearTimeout(reqTimeout);
	        reqTimeout = setTimeout(onTimeout, opts.timeouts.complete);
	      }
	
	      function onProgress() {
	        if (!connected) onConnect();
	      }
	
	      function onReadyStateChange() {
	        if (!connected && req.readyState > 1) onConnect();
	      }
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._request.fallback = function requestFallback(url, opts) {
	    url = inlineHeaders(url, opts.headers);
	
	    return new Promise(function wrapJsonpRequest(resolve, reject) {
	      jsonpRequest(url, opts, function jsonpRequestDone(err, content) {
	        if (err) {
	          reject(err);
	          return;
	        }
	
	        resolve(content);
	      });
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._promise = {
	    reject: function rejectPromise(val) {
	      return Promise.reject(val);
	    },
	    resolve: function resolvePromise(val) {
	      return Promise.resolve(val);
	    },
	    delay: function delayPromise(ms) {
	      return new Promise(function resolveOnTimeout(resolve /* , reject*/) {
	        setTimeout(resolve, ms);
	      });
	    }
	  };
	
	  return algoliasearch;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var win;
	
	if (typeof window !== "undefined") {
	    win = window;
	} else if (typeof global !== "undefined") {
	    win = global;
	} else if (typeof self !== "undefined") {
	    win = self;
	} else {
	    win = {};
	}
	
	module.exports = win;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.1.1
	 */
	
	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.ES6Promise = factory();
	})(undefined, function () {
	  'use strict';
	
	  function objectOrFunction(x) {
	    var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);
	    return x !== null && (type === 'object' || type === 'function');
	  }
	
	  function isFunction(x) {
	    return typeof x === 'function';
	  }
	
	  var _isArray = undefined;
	  if (Array.isArray) {
	    _isArray = Array.isArray;
	  } else {
	    _isArray = function _isArray(x) {
	      return Object.prototype.toString.call(x) === '[object Array]';
	    };
	  }
	
	  var isArray = _isArray;
	
	  var len = 0;
	  var vertxNext = undefined;
	  var customSchedulerFn = undefined;
	
	  var asap = function asap(callback, arg) {
	    queue[len] = callback;
	    queue[len + 1] = arg;
	    len += 2;
	    if (len === 2) {
	      // If len is 2, that means that we need to schedule an async flush.
	      // If additional callbacks are queued before the queue is flushed, they
	      // will be processed by this flush that we are scheduling.
	      if (customSchedulerFn) {
	        customSchedulerFn(flush);
	      } else {
	        scheduleFlush();
	      }
	    }
	  };
	
	  function setScheduler(scheduleFn) {
	    customSchedulerFn = scheduleFn;
	  }
	
	  function setAsap(asapFn) {
	    asap = asapFn;
	  }
	
	  var browserWindow = typeof window !== 'undefined' ? window : undefined;
	  var browserGlobal = browserWindow || {};
	  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	  // test for web worker but not in IE10
	  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	  // node
	  function useNextTick() {
	    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	    // see https://github.com/cujojs/when/issues/410 for details
	    return function () {
	      return process.nextTick(flush);
	    };
	  }
	
	  // vertx
	  function useVertxTimer() {
	    if (typeof vertxNext !== 'undefined') {
	      return function () {
	        vertxNext(flush);
	      };
	    }
	
	    return useSetTimeout();
	  }
	
	  function useMutationObserver() {
	    var iterations = 0;
	    var observer = new BrowserMutationObserver(flush);
	    var node = document.createTextNode('');
	    observer.observe(node, { characterData: true });
	
	    return function () {
	      node.data = iterations = ++iterations % 2;
	    };
	  }
	
	  // web worker
	  function useMessageChannel() {
	    var channel = new MessageChannel();
	    channel.port1.onmessage = flush;
	    return function () {
	      return channel.port2.postMessage(0);
	    };
	  }
	
	  function useSetTimeout() {
	    // Store setTimeout reference so es6-promise will be unaffected by
	    // other code modifying setTimeout (like sinon.useFakeTimers())
	    var globalSetTimeout = setTimeout;
	    return function () {
	      return globalSetTimeout(flush, 1);
	    };
	  }
	
	  var queue = new Array(1000);
	  function flush() {
	    for (var i = 0; i < len; i += 2) {
	      var callback = queue[i];
	      var arg = queue[i + 1];
	
	      callback(arg);
	
	      queue[i] = undefined;
	      queue[i + 1] = undefined;
	    }
	
	    len = 0;
	  }
	
	  function attemptVertx() {
	    try {
	      var r = require;
	      var vertx = __webpack_require__(41);
	      vertxNext = vertx.runOnLoop || vertx.runOnContext;
	      return useVertxTimer();
	    } catch (e) {
	      return useSetTimeout();
	    }
	  }
	
	  var scheduleFlush = undefined;
	  // Decide what async method to use to triggering processing of queued callbacks:
	  if (isNode) {
	    scheduleFlush = useNextTick();
	  } else if (BrowserMutationObserver) {
	    scheduleFlush = useMutationObserver();
	  } else if (isWorker) {
	    scheduleFlush = useMessageChannel();
	  } else if (browserWindow === undefined && "function" === 'function') {
	    scheduleFlush = attemptVertx();
	  } else {
	    scheduleFlush = useSetTimeout();
	  }
	
	  function then(onFulfillment, onRejection) {
	    var _arguments = arguments;
	
	    var parent = this;
	
	    var child = new this.constructor(noop);
	
	    if (child[PROMISE_ID] === undefined) {
	      makePromise(child);
	    }
	
	    var _state = parent._state;
	
	    if (_state) {
	      (function () {
	        var callback = _arguments[_state - 1];
	        asap(function () {
	          return invokeCallback(_state, child, callback, parent._result);
	        });
	      })();
	    } else {
	      subscribe(parent, child, onFulfillment, onRejection);
	    }
	
	    return child;
	  }
	
	  /**
	    `Promise.resolve` returns a promise that will become resolved with the
	    passed `value`. It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      resolve(1);
	    });
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.resolve(1);
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    @method resolve
	    @static
	    @param {Any} value value that the returned promise will be resolved with
	    Useful for tooling.
	    @return {Promise} a promise that will become fulfilled with the given
	    `value`
	  */
	  function resolve$1(object) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
	      return object;
	    }
	
	    var promise = new Constructor(noop);
	    resolve(promise, object);
	    return promise;
	  }
	
	  var PROMISE_ID = Math.random().toString(36).substring(16);
	
	  function noop() {}
	
	  var PENDING = void 0;
	  var FULFILLED = 1;
	  var REJECTED = 2;
	
	  var GET_THEN_ERROR = new ErrorObject();
	
	  function selfFulfillment() {
	    return new TypeError("You cannot resolve a promise with itself");
	  }
	
	  function cannotReturnOwn() {
	    return new TypeError('A promises callback cannot return that same promise.');
	  }
	
	  function getThen(promise) {
	    try {
	      return promise.then;
	    } catch (error) {
	      GET_THEN_ERROR.error = error;
	      return GET_THEN_ERROR;
	    }
	  }
	
	  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
	    try {
	      then$$1.call(value, fulfillmentHandler, rejectionHandler);
	    } catch (e) {
	      return e;
	    }
	  }
	
	  function handleForeignThenable(promise, thenable, then$$1) {
	    asap(function (promise) {
	      var sealed = false;
	      var error = tryThen(then$$1, thenable, function (value) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	        if (thenable !== value) {
	          resolve(promise, value);
	        } else {
	          fulfill(promise, value);
	        }
	      }, function (reason) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	
	        reject(promise, reason);
	      }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	      if (!sealed && error) {
	        sealed = true;
	        reject(promise, error);
	      }
	    }, promise);
	  }
	
	  function handleOwnThenable(promise, thenable) {
	    if (thenable._state === FULFILLED) {
	      fulfill(promise, thenable._result);
	    } else if (thenable._state === REJECTED) {
	      reject(promise, thenable._result);
	    } else {
	      subscribe(thenable, undefined, function (value) {
	        return resolve(promise, value);
	      }, function (reason) {
	        return reject(promise, reason);
	      });
	    }
	  }
	
	  function handleMaybeThenable(promise, maybeThenable, then$$1) {
	    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
	      handleOwnThenable(promise, maybeThenable);
	    } else {
	      if (then$$1 === GET_THEN_ERROR) {
	        reject(promise, GET_THEN_ERROR.error);
	        GET_THEN_ERROR.error = null;
	      } else if (then$$1 === undefined) {
	        fulfill(promise, maybeThenable);
	      } else if (isFunction(then$$1)) {
	        handleForeignThenable(promise, maybeThenable, then$$1);
	      } else {
	        fulfill(promise, maybeThenable);
	      }
	    }
	  }
	
	  function resolve(promise, value) {
	    if (promise === value) {
	      reject(promise, selfFulfillment());
	    } else if (objectOrFunction(value)) {
	      handleMaybeThenable(promise, value, getThen(value));
	    } else {
	      fulfill(promise, value);
	    }
	  }
	
	  function publishRejection(promise) {
	    if (promise._onerror) {
	      promise._onerror(promise._result);
	    }
	
	    publish(promise);
	  }
	
	  function fulfill(promise, value) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	
	    promise._result = value;
	    promise._state = FULFILLED;
	
	    if (promise._subscribers.length !== 0) {
	      asap(publish, promise);
	    }
	  }
	
	  function reject(promise, reason) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	    promise._state = REJECTED;
	    promise._result = reason;
	
	    asap(publishRejection, promise);
	  }
	
	  function subscribe(parent, child, onFulfillment, onRejection) {
	    var _subscribers = parent._subscribers;
	    var length = _subscribers.length;
	
	    parent._onerror = null;
	
	    _subscribers[length] = child;
	    _subscribers[length + FULFILLED] = onFulfillment;
	    _subscribers[length + REJECTED] = onRejection;
	
	    if (length === 0 && parent._state) {
	      asap(publish, parent);
	    }
	  }
	
	  function publish(promise) {
	    var subscribers = promise._subscribers;
	    var settled = promise._state;
	
	    if (subscribers.length === 0) {
	      return;
	    }
	
	    var child = undefined,
	        callback = undefined,
	        detail = promise._result;
	
	    for (var i = 0; i < subscribers.length; i += 3) {
	      child = subscribers[i];
	      callback = subscribers[i + settled];
	
	      if (child) {
	        invokeCallback(settled, child, callback, detail);
	      } else {
	        callback(detail);
	      }
	    }
	
	    promise._subscribers.length = 0;
	  }
	
	  function ErrorObject() {
	    this.error = null;
	  }
	
	  var TRY_CATCH_ERROR = new ErrorObject();
	
	  function tryCatch(callback, detail) {
	    try {
	      return callback(detail);
	    } catch (e) {
	      TRY_CATCH_ERROR.error = e;
	      return TRY_CATCH_ERROR;
	    }
	  }
	
	  function invokeCallback(settled, promise, callback, detail) {
	    var hasCallback = isFunction(callback),
	        value = undefined,
	        error = undefined,
	        succeeded = undefined,
	        failed = undefined;
	
	    if (hasCallback) {
	      value = tryCatch(callback, detail);
	
	      if (value === TRY_CATCH_ERROR) {
	        failed = true;
	        error = value.error;
	        value.error = null;
	      } else {
	        succeeded = true;
	      }
	
	      if (promise === value) {
	        reject(promise, cannotReturnOwn());
	        return;
	      }
	    } else {
	      value = detail;
	      succeeded = true;
	    }
	
	    if (promise._state !== PENDING) {
	      // noop
	    } else if (hasCallback && succeeded) {
	      resolve(promise, value);
	    } else if (failed) {
	      reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      reject(promise, value);
	    }
	  }
	
	  function initializePromise(promise, resolver) {
	    try {
	      resolver(function resolvePromise(value) {
	        resolve(promise, value);
	      }, function rejectPromise(reason) {
	        reject(promise, reason);
	      });
	    } catch (e) {
	      reject(promise, e);
	    }
	  }
	
	  var id = 0;
	  function nextId() {
	    return id++;
	  }
	
	  function makePromise(promise) {
	    promise[PROMISE_ID] = id++;
	    promise._state = undefined;
	    promise._result = undefined;
	    promise._subscribers = [];
	  }
	
	  function Enumerator$1(Constructor, input) {
	    this._instanceConstructor = Constructor;
	    this.promise = new Constructor(noop);
	
	    if (!this.promise[PROMISE_ID]) {
	      makePromise(this.promise);
	    }
	
	    if (isArray(input)) {
	      this.length = input.length;
	      this._remaining = input.length;
	
	      this._result = new Array(this.length);
	
	      if (this.length === 0) {
	        fulfill(this.promise, this._result);
	      } else {
	        this.length = this.length || 0;
	        this._enumerate(input);
	        if (this._remaining === 0) {
	          fulfill(this.promise, this._result);
	        }
	      }
	    } else {
	      reject(this.promise, validationError());
	    }
	  }
	
	  function validationError() {
	    return new Error('Array Methods must be provided an Array');
	  }
	
	  Enumerator$1.prototype._enumerate = function (input) {
	    for (var i = 0; this._state === PENDING && i < input.length; i++) {
	      this._eachEntry(input[i], i);
	    }
	  };
	
	  Enumerator$1.prototype._eachEntry = function (entry, i) {
	    var c = this._instanceConstructor;
	    var resolve$$1 = c.resolve;
	
	    if (resolve$$1 === resolve$1) {
	      var _then = getThen(entry);
	
	      if (_then === then && entry._state !== PENDING) {
	        this._settledAt(entry._state, i, entry._result);
	      } else if (typeof _then !== 'function') {
	        this._remaining--;
	        this._result[i] = entry;
	      } else if (c === Promise$2) {
	        var promise = new c(noop);
	        handleMaybeThenable(promise, entry, _then);
	        this._willSettleAt(promise, i);
	      } else {
	        this._willSettleAt(new c(function (resolve$$1) {
	          return resolve$$1(entry);
	        }), i);
	      }
	    } else {
	      this._willSettleAt(resolve$$1(entry), i);
	    }
	  };
	
	  Enumerator$1.prototype._settledAt = function (state, i, value) {
	    var promise = this.promise;
	
	    if (promise._state === PENDING) {
	      this._remaining--;
	
	      if (state === REJECTED) {
	        reject(promise, value);
	      } else {
	        this._result[i] = value;
	      }
	    }
	
	    if (this._remaining === 0) {
	      fulfill(promise, this._result);
	    }
	  };
	
	  Enumerator$1.prototype._willSettleAt = function (promise, i) {
	    var enumerator = this;
	
	    subscribe(promise, undefined, function (value) {
	      return enumerator._settledAt(FULFILLED, i, value);
	    }, function (reason) {
	      return enumerator._settledAt(REJECTED, i, reason);
	    });
	  };
	
	  /**
	    `Promise.all` accepts an array of promises, and returns a new promise which
	    is fulfilled with an array of fulfillment values for the passed promises, or
	    rejected with the reason of the first passed promise to be rejected. It casts all
	    elements of the passed iterable to promises as it runs this algorithm.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = resolve(2);
	    let promise3 = resolve(3);
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // The array here would be [ 1, 2, 3 ];
	    });
	    ```
	  
	    If any of the `promises` given to `all` are rejected, the first promise
	    that is rejected will be given as an argument to the returned promises's
	    rejection handler. For example:
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = reject(new Error("2"));
	    let promise3 = reject(new Error("3"));
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // Code here never runs because there are rejected promises!
	    }, function(error) {
	      // error.message === "2"
	    });
	    ```
	  
	    @method all
	    @static
	    @param {Array} entries array of promises
	    @param {String} label optional string for labeling the promise.
	    Useful for tooling.
	    @return {Promise} promise that is fulfilled when all `promises` have been
	    fulfilled, or rejected if any of them become rejected.
	    @static
	  */
	  function all$1(entries) {
	    return new Enumerator$1(this, entries).promise;
	  }
	
	  /**
	    `Promise.race` returns a new promise which is settled in the same way as the
	    first passed promise to settle.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 2');
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // result === 'promise 2' because it was resolved before promise1
	      // was resolved.
	    });
	    ```
	  
	    `Promise.race` is deterministic in that only the state of the first
	    settled promise matters. For example, even if other promises given to the
	    `promises` array argument are resolved, but the first settled promise has
	    become rejected before the other promises became fulfilled, the returned
	    promise will become rejected:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        reject(new Error('promise 2'));
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // Code here never runs
	    }, function(reason){
	      // reason.message === 'promise 2' because promise 2 became rejected before
	      // promise 1 became fulfilled
	    });
	    ```
	  
	    An example real-world use case is implementing timeouts:
	  
	    ```javascript
	    Promise.race([ajax('foo.json'), timeout(5000)])
	    ```
	  
	    @method race
	    @static
	    @param {Array} promises array of promises to observe
	    Useful for tooling.
	    @return {Promise} a promise which settles in the same way as the first passed
	    promise to settle.
	  */
	  function race$1(entries) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (!isArray(entries)) {
	      return new Constructor(function (_, reject) {
	        return reject(new TypeError('You must pass an array to race.'));
	      });
	    } else {
	      return new Constructor(function (resolve, reject) {
	        var length = entries.length;
	        for (var i = 0; i < length; i++) {
	          Constructor.resolve(entries[i]).then(resolve, reject);
	        }
	      });
	    }
	  }
	
	  /**
	    `Promise.reject` returns a promise rejected with the passed `reason`.
	    It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      reject(new Error('WHOOPS'));
	    });
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.reject(new Error('WHOOPS'));
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    @method reject
	    @static
	    @param {Any} reason value that the returned promise will be rejected with.
	    Useful for tooling.
	    @return {Promise} a promise rejected with the given `reason`.
	  */
	  function reject$1(reason) {
	    /*jshint validthis:true */
	    var Constructor = this;
	    var promise = new Constructor(noop);
	    reject(promise, reason);
	    return promise;
	  }
	
	  function needsResolver() {
	    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	  }
	
	  function needsNew() {
	    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	  }
	
	  /**
	    Promise objects represent the eventual result of an asynchronous operation. The
	    primary way of interacting with a promise is through its `then` method, which
	    registers callbacks to receive either a promise's eventual value or the reason
	    why the promise cannot be fulfilled.
	  
	    Terminology
	    -----------
	  
	    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	    - `thenable` is an object or function that defines a `then` method.
	    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	    - `exception` is a value that is thrown using the throw statement.
	    - `reason` is a value that indicates why a promise was rejected.
	    - `settled` the final resting state of a promise, fulfilled or rejected.
	  
	    A promise can be in one of three states: pending, fulfilled, or rejected.
	  
	    Promises that are fulfilled have a fulfillment value and are in the fulfilled
	    state.  Promises that are rejected have a rejection reason and are in the
	    rejected state.  A fulfillment value is never a thenable.
	  
	    Promises can also be said to *resolve* a value.  If this value is also a
	    promise, then the original promise's settled state will match the value's
	    settled state.  So a promise that *resolves* a promise that rejects will
	    itself reject, and a promise that *resolves* a promise that fulfills will
	    itself fulfill.
	  
	  
	    Basic Usage:
	    ------------
	  
	    ```js
	    let promise = new Promise(function(resolve, reject) {
	      // on success
	      resolve(value);
	  
	      // on failure
	      reject(reason);
	    });
	  
	    promise.then(function(value) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Advanced Usage:
	    ---------------
	  
	    Promises shine when abstracting away asynchronous interactions such as
	    `XMLHttpRequest`s.
	  
	    ```js
	    function getJSON(url) {
	      return new Promise(function(resolve, reject){
	        let xhr = new XMLHttpRequest();
	  
	        xhr.open('GET', url);
	        xhr.onreadystatechange = handler;
	        xhr.responseType = 'json';
	        xhr.setRequestHeader('Accept', 'application/json');
	        xhr.send();
	  
	        function handler() {
	          if (this.readyState === this.DONE) {
	            if (this.status === 200) {
	              resolve(this.response);
	            } else {
	              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	            }
	          }
	        };
	      });
	    }
	  
	    getJSON('/posts.json').then(function(json) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Unlike callbacks, promises are great composable primitives.
	  
	    ```js
	    Promise.all([
	      getJSON('/posts'),
	      getJSON('/comments')
	    ]).then(function(values){
	      values[0] // => postsJSON
	      values[1] // => commentsJSON
	  
	      return values;
	    });
	    ```
	  
	    @class Promise
	    @param {function} resolver
	    Useful for tooling.
	    @constructor
	  */
	  function Promise$2(resolver) {
	    this[PROMISE_ID] = nextId();
	    this._result = this._state = undefined;
	    this._subscribers = [];
	
	    if (noop !== resolver) {
	      typeof resolver !== 'function' && needsResolver();
	      this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
	    }
	  }
	
	  Promise$2.all = all$1;
	  Promise$2.race = race$1;
	  Promise$2.resolve = resolve$1;
	  Promise$2.reject = reject$1;
	  Promise$2._setScheduler = setScheduler;
	  Promise$2._setAsap = setAsap;
	  Promise$2._asap = asap;
	
	  Promise$2.prototype = {
	    constructor: Promise$2,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	    
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	    
	      Chaining
	      --------
	    
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	    
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	    
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	    
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	    
	      Assimilation
	      ------------
	    
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	    
	      If the assimliated promise rejects, then the downstream promise will also reject.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	    
	      Simple Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let result;
	    
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	    
	      Advanced Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let author, books;
	    
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	    
	      function foundBooks(books) {
	    
	      }
	    
	      function failure(reason) {
	    
	      }
	    
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	    then: then,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	    
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	    
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	    
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	    'catch': function _catch(onRejection) {
	      return this.then(null, onRejection);
	    }
	  };
	
	  /*global self*/
	  function polyfill$1() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	      local = global;
	    } else if (typeof self !== 'undefined') {
	      local = self;
	    } else {
	      try {
	        local = Function('return this')();
	      } catch (e) {
	        throw new Error('polyfill failed because global object is unavailable in this environment');
	      }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	      var promiseToString = null;
	      try {
	        promiseToString = Object.prototype.toString.call(P.resolve());
	      } catch (e) {
	        // silently ignored
	      }
	
	      if (promiseToString === '[object Promise]' && !P.cast) {
	        return;
	      }
	    }
	
	    local.Promise = Promise$2;
	  }
	
	  // Strange compat..
	  Promise$2.polyfill = polyfill$1;
	  Promise$2.Promise = Promise$2;
	
	  return Promise$2;
	});
	
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = inlineHeaders;
	
	var encode = __webpack_require__(43);
	
	function inlineHeaders(url, headers) {
	  if (/\?/.test(url)) {
	    url += '&';
	  } else {
	    url += '?';
	  }
	
	  return url + encode(headers);
	}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return map(objectKeys(obj), function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (isArray(obj[k])) {
	        return map(obj[k], function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};
	
	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	function map(xs, f) {
	  if (xs.map) return xs.map(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    res.push(f(xs[i], i));
	  }
	  return res;
	}
	
	var objectKeys = Object.keys || function (obj) {
	  var res = [];
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
	  }
	  return res;
	};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = jsonpRequest;
	
	var errors = __webpack_require__(19);
	
	var JSONPCounter = 0;
	
	function jsonpRequest(url, opts, cb) {
	  if (opts.method !== 'GET') {
	    cb(new Error('Method ' + opts.method + ' ' + url + ' is not supported by JSONP.'));
	    return;
	  }
	
	  opts.debug('JSONP: start');
	
	  var cbCalled = false;
	  var timedOut = false;
	
	  JSONPCounter += 1;
	  var head = document.getElementsByTagName('head')[0];
	  var script = document.createElement('script');
	  var cbName = 'algoliaJSONP_' + JSONPCounter;
	  var done = false;
	
	  window[cbName] = function (data) {
	    removeGlobals();
	
	    if (timedOut) {
	      opts.debug('JSONP: Late answer, ignoring');
	      return;
	    }
	
	    cbCalled = true;
	
	    clean();
	
	    cb(null, {
	      body: data /* ,
	                 // We do not send the statusCode, there's no statusCode in JSONP, it will be
	                 // computed using data.status && data.message like with XDR
	                 statusCode*/
	    });
	  };
	
	  // add callback by hand
	  url += '&callback=' + cbName;
	
	  // add body params manually
	  if (opts.jsonBody && opts.jsonBody.params) {
	    url += '&' + opts.jsonBody.params;
	  }
	
	  var ontimeout = setTimeout(timeout, opts.timeouts.complete);
	
	  // script onreadystatechange needed only for
	  // <= IE8
	  // https://github.com/angular/angular.js/issues/4523
	  script.onreadystatechange = readystatechange;
	  script.onload = success;
	  script.onerror = error;
	
	  script.async = true;
	  script.defer = true;
	  script.src = url;
	  head.appendChild(script);
	
	  function success() {
	    opts.debug('JSONP: success');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    done = true;
	
	    // script loaded but did not call the fn => script loading error
	    if (!cbCalled) {
	      opts.debug('JSONP: Fail. Script loaded but did not call the callback');
	      clean();
	      cb(new errors.JSONPScriptFail());
	    }
	  }
	
	  function readystatechange() {
	    if (this.readyState === 'loaded' || this.readyState === 'complete') {
	      success();
	    }
	  }
	
	  function clean() {
	    clearTimeout(ontimeout);
	    script.onload = null;
	    script.onreadystatechange = null;
	    script.onerror = null;
	    head.removeChild(script);
	  }
	
	  function removeGlobals() {
	    try {
	      delete window[cbName];
	      delete window[cbName + '_loaded'];
	    } catch (e) {
	      window[cbName] = window[cbName + '_loaded'] = undefined;
	    }
	  }
	
	  function timeout() {
	    opts.debug('JSONP: Script timeout');
	    timedOut = true;
	    clean();
	    cb(new errors.RequestTimeout());
	  }
	
	  function error() {
	    opts.debug('JSONP: Script error');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    clean();
	    cb(new errors.JSONPScriptError());
	  }
	}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = createPlacesClient;
	
	var buildSearchMethod = __webpack_require__(18);
	
	function createPlacesClient(algoliasearch) {
	  return function places(appID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    opts = opts && cloneDeep(opts) || {};
	    opts.hosts = opts.hosts || ['places-dsn.algolia.net', 'places-1.algolianet.com', 'places-2.algolianet.com', 'places-3.algolianet.com'];
	
	    // allow initPlaces() no arguments => community rate limited
	    if (arguments.length === 0 || (typeof appID === 'undefined' ? 'undefined' : _typeof(appID)) === 'object' || appID === undefined) {
	      appID = '';
	      apiKey = '';
	      opts._allowEmptyCredentials = true;
	    }
	
	    var client = algoliasearch(appID, apiKey, opts);
	    var index = client.initIndex('places');
	    index.search = buildSearchMethod('query', '/1/places/query');
	    index.getObject = function (objectID, callback) {
	      return this.as._jsonRequest({
	        method: 'GET',
	        url: '/1/places/' + encodeURIComponent(objectID),
	        hostType: 'read',
	        callback: callback
	      });
	    };
	    return index;
	  };
	}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = getDocumentProtocol;
	
	function getDocumentProtocol() {
	  var protocol = window.document.location.protocol;
	
	  // when in `file:` mode (local html file), default to `http:`
	  if (protocol !== 'http:' && protocol !== 'https:') {
	    protocol = 'http:';
	  }
	
	  return protocol;
	}

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = '3.24.3';

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTIwOWY0OTRlZjY4NjBlZDNjZDk/ZmRjYyoqIiwid2VicGFjazovLy8uL34vbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzP2RjZWIiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZXZlbnQtcGFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xL3EuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL2FwcC9wbHVnaW5zL2V4cGxhYWluLXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvYnVpbGRzL2FsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9BbGdvbGlhU2VhcmNoLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhDb3JlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnVpbGRTZWFyY2hNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3JlYWNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Nsb25lLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvb21pdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvbWFwLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZXhpdFByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleEJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaENvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2NyZWF0ZUFsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbG9iYWwvd2luZG93LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvaW5saW5lLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9qc29ucC1yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvcGxhY2VzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9nZXQtZG9jdW1lbnQtcHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy92ZXJzaW9uLmpzIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwiZGVmaW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwibG9nTWV0aG9kcyIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlYWxNZXRob2QiLCJjb25zb2xlIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJsb2dnZXJOYW1lIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJkZWJ1ZyIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIkxvZ2dlciIsIm5hbWUiLCJkZWZhdWx0TGV2ZWwiLCJmYWN0b3J5Iiwic2VsZiIsImN1cnJlbnRMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJ0b1VwcGVyQ2FzZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImlnbm9yZSIsImRvY3VtZW50IiwiY29va2llIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0UGVyc2lzdGVkTGV2ZWwiLCJzdG9yZWRMZXZlbCIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImxldmVscyIsImdldExldmVsIiwic2V0TGV2ZWwiLCJwZXJzaXN0IiwiU0lMRU5UIiwic2V0RGVmYXVsdExldmVsIiwiZW5hYmxlQWxsIiwiVFJBQ0UiLCJkaXNhYmxlQWxsIiwiaW5pdGlhbExldmVsIiwiZGVmYXVsdExvZ2dlciIsIl9sb2dnZXJzQnlOYW1lIiwiZ2V0TG9nZ2VyIiwiVHlwZUVycm9yIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJVc2VySURzIiwibGl2ZSIsIkplcmVteSIsIk1hdHQiLCJDYXJvbCIsIkhhcnJpZXQiLCJKb25ueSIsInN0YWdpbmciLCJsb2NhbCIsImRyaXZlIiwiQUNNRSIsIlVzZXJJRCIsIlBhZ2VSZXN1bHRzIiwiVXNlckNhcmRzIiwiTGFzdFJlZnJlc2giLCJhbGdvbGlhUGFyYW1zIiwiYXBwSUQiLCJhcGlLZXkiLCJpbmRleCIsInVzZSIsImNocm9tZSIsImJyb3dzZXJBY3Rpb24iLCJvbkNsaWNrZWQiLCJhZGRMaXN0ZW5lciIsInRhYiIsInRhYnMiLCJxdWVyeSIsImFjdGl2ZSIsImN1cnJlbnRXaW5kb3ciLCJzZW5kTWVzc2FnZSIsImlkIiwiYWN0aW9uIiwicmVzIiwiaW5mbyIsInJ1bnRpbWUiLCJvbk1lc3NhZ2UiLCJyZXF1ZXN0Iiwic2VuZGVyIiwic2VuZFJlc3BvbnNlIiwidXJsIiwiZ2V0Q3VycmVudFBhZ2VSZXN1bHRzIiwiZGF0YSIsInRoZW4iLCJ0cmFjZSIsImNoZWNrUmVmcmVzaCIsImdldFBhZ2VSZXN1bHRzIiwiYWRkVG9QYWdlUmVzdWx0cyIsImNhdGNoIiwiZXJyb3IiLCJnZXRBbGxVc2VyQ2FyZHMiLCJldmVudCIsInJlc3BvbnNlIiwiZCIsImRlZmVyIiwidGFiSUQiLCJnZXRDdXJyZW50VGFiIiwicmVzb2x2ZSIsImdldFBhZ2VEYXRhIiwicmVqZWN0IiwicHJvbWlzZSIsInBhZ2VEYXRhIiwic2VuZE1lc3NhZ2VUb1RhYiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicGFnZVRhYklEIiwiZmlsdGVyIiwibm93IiwiRGF0ZSIsInNlYXJjaENhcmRzIiwicmVzdWx0cyIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0IiwiX3RvU3RyaW5nIiwidG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwiU3RyaW5nIiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwiYiIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXkiLCJpc0FycmF5QiIsImV2ZXJ5Iiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwid2FybiIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm9wdGlvbnMiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwibWF0Y2giLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJjb25zdHJ1Y3RvciIsInB1c2giLCJoYW5kbGVFcnJvciIsImVyciIsImluQnJvd3NlciIsImhhc1Byb3RvIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwibmV4dFRpY2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwidGltZXJGdW5jIiwibmV4dFRpY2tIYW5kbGVyIiwiY29waWVzIiwiUHJvbWlzZSIsInAiLCJsb2dFcnJvciIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicXVldWVOZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ1aWQiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsInBvcCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsInBhcmVudCIsImNoaWxkIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJ0eXBlIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY2FwdHVyZSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImNoZWNrT3B0aW9uVHlwZSIsIm9wdGlvbiIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5Iiwic291cmNlIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJfY29udGV4dCIsImgiLCJjcmVhdGVFbGVtZW50IiwiaW5qZWN0aW9ucyIsImZ1bmN0aW9uYWxPcHRpb25zIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJzdGF0aWNSZW5kZXJGbnMiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwiY3VycmVudCIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImhvb2tzIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsIm1vZGVsUnMiLCJwYXJzZU1vZGVsIiwiaWR4IiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0Iiwic3Vic3RyaW5nIiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJkeW5hbWljVHlwZSIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJ0YXJnZXQkMSIsImFkZCQxIiwib2xkSGFuZGxlciIsImV2IiwicmVtb3ZlJDIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwiZW5kIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsIk51bWJlciIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwiaXNUZXh0SW5wdXRUeXBlIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJiaW5kaW5nIiwic2V0U2VsZWN0ZWQiLCJfdk9wdGlvbnMiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJzb21lIiwibyIsImlzTXVsdGlwbGUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsInNob3VsZERlY29kZSIsImNvbnRlbnQiLCJlbmNvZGVkIiwiZGl2IiwiaW5uZXJIVE1MIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsImxhc3RJbmRleCIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJtb2R1bGVzJDEiLCJodG1sIiwiZGlyZWN0aXZlcyQxIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYmFzZU9wdGlvbnMiLCJleHBlY3RIVE1MIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwic2luZ2xlQXR0cklkZW50aWZpZXIiLCJzaW5nbGVBdHRyQXNzaWduIiwic2luZ2xlQXR0clZhbHVlcyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5IiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJwYXJzZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImVsZW1lbnQiLCJjb21tZW50cyIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJzcGFjZSIsInVwIiwicmlnaHQiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsInNoaWZ0IiwiYWx0IiwibWV0YSIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJpZGVudFJFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImNyZWF0ZUZ1bmN0aW9uIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJyZWYkMSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsIkl0ZW0iLCJhcnJheSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJib290c3RyYXAiLCJzZXMiLCJvayIsIm1ha2VRIiwicHJldmlvdXNRIiwiUSIsImhhc1N0YWNrcyIsInFTdGFydGluZ0xpbmUiLCJjYXB0dXJlTGluZSIsInFGaWxlTmFtZSIsImhlYWQiLCJ0YXNrIiwidGFpbCIsInJlcXVlc3RUaWNrIiwiaXNOb2RlSlMiLCJsYXRlclF1ZXVlIiwiZmx1c2giLCJkb21haW4iLCJydW5TaW5nbGUiLCJleGl0Iiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJyZXF1ZXN0UG9ydFRpY2siLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwicnVuQWZ0ZXIiLCJ1bmN1cnJ5VGhpcyIsImFycmF5X3NsaWNlIiwiYXJyYXlfcmVkdWNlIiwiYmFzaXMiLCJhcnJheV9pbmRleE9mIiwiYXJyYXlfbWFwIiwidGhpc3AiLCJjb2xsZWN0Iiwib2JqZWN0X2NyZWF0ZSIsIlR5cGUiLCJvYmplY3RfZGVmaW5lUHJvcGVydHkiLCJkZXNjcmlwdG9yIiwib2JqZWN0X2hhc093blByb3BlcnR5Iiwib2JqZWN0X2tleXMiLCJvYmplY3QiLCJvYmplY3RfdG9TdHJpbmciLCJpc1N0b3BJdGVyYXRpb24iLCJleGNlcHRpb24iLCJRUmV0dXJuVmFsdWUiLCJSZXR1cm5WYWx1ZSIsIlNUQUNLX0pVTVBfU0VQQVJBVE9SIiwibWFrZVN0YWNrVHJhY2VMb25nIiwic3RhY2tzIiwiX19taW5pbXVtU3RhY2tDb3VudGVyX18iLCJzdGFja0NvdW50ZXIiLCJjb25jYXRlZFN0YWNrcyIsImZpbHRlclN0YWNrU3RyaW5nIiwic3RhY2tTdHJpbmciLCJsaW5lcyIsImRlc2lyZWRMaW5lcyIsImxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJpc05vZGVGcmFtZSIsInN0YWNrTGluZSIsImdldEZpbGVOYW1lQW5kTGluZU51bWJlciIsImF0dGVtcHQxIiwiYXR0ZW1wdDIiLCJhdHRlbXB0MyIsImZpbGVOYW1lQW5kTGluZU51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsInFFbmRpbmdMaW5lIiwiZmlyc3RMaW5lIiwiZGVwcmVjYXRlIiwiYWx0ZXJuYXRpdmUiLCJpc1Byb21pc2VBbGlrZSIsImNvZXJjZSIsImZ1bGZpbGwiLCJsb25nU3RhY2tTdXBwb3J0IiwibG9uZ1N0YWNrQ291bnRlciIsIlFfREVCVUciLCJtZXNzYWdlcyIsInByb2dyZXNzTGlzdGVuZXJzIiwicmVzb2x2ZWRQcm9taXNlIiwiZGVmZXJyZWQiLCJwcm9taXNlRGlzcGF0Y2giLCJvcCIsIm9wZXJhbmRzIiwidmFsdWVPZiIsIm5lYXJlclZhbHVlIiwibmVhcmVyIiwiaXNQcm9taXNlIiwiaW5zcGVjdCIsImJlY29tZSIsIm5ld1Byb21pc2UiLCJtZXNzYWdlIiwicHJvZ3Jlc3MiLCJwcm9ncmVzc0xpc3RlbmVyIiwibWFrZU5vZGVSZXNvbHZlciIsInJlc29sdmVyIiwicmFjZSIsInBhc3NCeUNvcHkiLCJ4IiwieSIsInRoYXQiLCJzcHJlYWQiLCJhbnN3ZXJQcyIsIm1ha2VQcm9taXNlIiwiaW5zcGVjdGVkIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwcm9ncmVzc2VkIiwiZG9uZSIsIl9mdWxmaWxsZWQiLCJfcmVqZWN0ZWQiLCJuZXdFeGNlcHRpb24iLCJfcHJvZ3Jlc3NlZCIsIm5ld1ZhbHVlIiwidGhyZXciLCJvbmVycm9yIiwidGFwIiwiZmNhbGwiLCJ0aGVuUmVzb2x2ZSIsIndoZW4iLCJ0aGVuUmVqZWN0IiwiaXNQZW5kaW5nIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwidW5oYW5kbGVkUmVhc29ucyIsInVuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXNldFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1JlamVjdGlvbiIsInVudHJhY2tSZWplY3Rpb24iLCJhdCIsImF0UmVwb3J0IiwiZ2V0VW5oYW5kbGVkUmVhc29ucyIsInN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyIsInJlamVjdGlvbiIsInJocyIsIm1hc3RlciIsImRpc3BhdGNoIiwiYXN5bmMiLCJtYWtlR2VuZXJhdG9yIiwiY29udGludWVyIiwidmVyYiIsIlN0b3BJdGVyYXRpb24iLCJnZW5lcmF0b3IiLCJlcnJiYWNrIiwic3Bhd24iLCJfcmV0dXJuIiwicHJvbWlzZWQiLCJtYXBwbHkiLCJwb3N0Iiwic2VuZCIsIm1jYWxsIiwiaW52b2tlIiwiZmFwcGx5IiwiZmJpbmQiLCJmYm91bmQiLCJwcm9taXNlcyIsInBlbmRpbmdDb3VudCIsInNuYXBzaG90IiwiYW55Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsImFsbFJlc29sdmVkIiwiYWxsU2V0dGxlZCIsInJlZ2FyZGxlc3MiLCJmYWlsIiwiZmluIiwib25VbmhhbmRsZWRFcnJvciIsIm1zIiwidGltZW91dElkIiwibmZhcHBseSIsIm5vZGVBcmdzIiwibmZjYWxsIiwibmZiaW5kIiwiZGVub2RlaWZ5IiwiYmFzZUFyZ3MiLCJuYmluZCIsImJvdW5kIiwibm1hcHBseSIsIm5wb3N0IiwibnNlbmQiLCJubWNhbGwiLCJuaW52b2tlIiwibm9kZWlmeSIsIm5vZGViYWNrIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJjbGVhckltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwid2VicGFja1BvbHlmaWxsIiwicGF0aHMiLCJlc2NhcGVSZWdFeHAiLCJTZWFyY2giLCJBbGdvbGlhQ2xpZW50IiwicHJvdG9jb2wiLCJBbGdvbGlhSW5kZXgiLCJpbml0SW5kZXgiLCJhZHZhbmNlZFNlYXJjaCIsInBhcmFtcyIsImNsZWFyQ2FjaGUiLCJzZWFyY2giLCJmZXRjaExpc3RJdGVtQ2FyZHMiLCJoaXRzIiwidXNlcklEIiwic2VhcmNoVGV4dCIsImhpdHNQZXJQYWdlIiwiY2FyZHMiLCJjYXJkIiwiY29ycmVjdENhcmQiLCJsaXN0Q2FyZHMiLCJsaXN0SXRlbXMiLCJnZXRDYXJkIiwib2JqZWN0SUQiLCJnZXRPYmplY3QiLCJkZXNjcmlwdGlvbiIsInNlbnRlbmNlIiwiY29tcG91bmRTZWFyY2giLCJtYXhMZW5ndGgiLCJzZWFyY2hUZXh0QXJyYXkiLCJtaW4iLCJjZWlsIiwidCIsInIiLCJyZW1vdmVEdXBsaWNhdGVzIiwib3JpZ2luYWxBcnJheSIsIm9iaktleSIsInRyaW1tZWRBcnJheSIsInZhbHVlcyIsImNoZWNrUGFnZUhpdCIsImJvcmluZ1dvcmRzIiwiY291bnQiLCJwYWdlVGV4dCIsImNoZWNrUGFnZVJlbWluZGVyIiwidXJsUm9vdCIsImJhc2VVcmwiLCJyZW1pbmRlcnMiLCJhbGxVc2VyQ2FyZHMiLCJwYWdlUmVzdWx0cyIsInBpbmdzIiwibWVtb3JpZXMiLCJnbWFpbEJvcmluZ1BocmFzZXMiLCJwaHJhc2UiLCJhbGxXb3JkcyIsInNjb3JlIiwiZW50aXR5IiwicmVnIiwicG9pbnRzIiwidHJpZ2dlclVSTCIsInBpbmciLCJoaWdobGlnaHQiLCJBbGdvbGlhU2VhcmNoIiwiY3JlYXRlQWxnb2xpYXNlYXJjaCIsIkluZGV4IiwiZGVwcmVjYXRlZE1lc3NhZ2UiLCJBbGdvbGlhU2VhcmNoQ29yZSIsImluaGVyaXRzIiwiZGVsZXRlSW5kZXgiLCJpbmRleE5hbWUiLCJfanNvblJlcXVlc3QiLCJob3N0VHlwZSIsIm1vdmVJbmRleCIsInNyY0luZGV4TmFtZSIsImRzdEluZGV4TmFtZSIsInBvc3RPYmoiLCJvcGVyYXRpb24iLCJkZXN0aW5hdGlvbiIsImNvcHlJbmRleCIsImdldExvZ3MiLCJvZmZzZXQiLCJfZ2V0U2VhcmNoUGFyYW1zIiwibGlzdEluZGV4ZXMiLCJwYWdlIiwibGlzdFVzZXJLZXlzIiwibGlzdEFwaUtleXMiLCJnZXRVc2VyS2V5QUNMIiwiZ2V0QXBpS2V5IiwiZGVsZXRlVXNlcktleSIsImRlbGV0ZUFwaUtleSIsImFkZFVzZXJLZXkiLCJhY2xzIiwiYWRkQXBpS2V5IiwidXNhZ2UiLCJhY2wiLCJ2YWxpZGl0eSIsIm1heFF1ZXJpZXNQZXJJUFBlckhvdXIiLCJtYXhIaXRzUGVyUXVlcnkiLCJpbmRleGVzIiwicXVlcnlQYXJhbWV0ZXJzIiwicmVmZXJlcnMiLCJhZGRVc2VyS2V5V2l0aFZhbGlkaXR5IiwidXBkYXRlVXNlcktleSIsInVwZGF0ZUFwaUtleSIsInB1dE9iaiIsInN0YXJ0UXVlcmllc0JhdGNoIiwic3RhcnRRdWVyaWVzQmF0Y2hEZXByZWNhdGVkIiwiX2JhdGNoIiwiYWRkUXVlcnlJbkJhdGNoIiwiYWRkUXVlcnlJbkJhdGNoRGVwcmVjYXRlZCIsInNlbmRRdWVyaWVzQmF0Y2giLCJzZW5kUXVlcmllc0JhdGNoRGVwcmVjYXRlZCIsImJhdGNoIiwib3BlcmF0aW9ucyIsInJlcXVlc3RzIiwibm90SW1wbGVtZW50ZWQiLCJlbmFibGVSYXRlTGltaXRGb3J3YXJkIiwiZGlzYWJsZVJhdGVMaW1pdEZvcndhcmQiLCJ1c2VTZWN1cmVkQVBJS2V5IiwiZGlzYWJsZVNlY3VyZWRBUElLZXkiLCJnZW5lcmF0ZVNlY3VyZWRBcGlLZXkiLCJBbGdvbGlhU2VhcmNoRXJyb3IiLCJJbmRleENvcmUiLCJleGl0UHJvbWlzZSIsImRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcyIsImFkZE9iamVjdCIsImluZGV4T2JqIiwiYXMiLCJhZGRPYmplY3RzIiwib2JqZWN0cyIsInBhcnRpYWxVcGRhdGVPYmplY3QiLCJwYXJ0aWFsT2JqZWN0IiwiY3JlYXRlSWZOb3RFeGlzdHMiLCJwYXJ0aWFsVXBkYXRlT2JqZWN0cyIsInNhdmVPYmplY3QiLCJzYXZlT2JqZWN0cyIsImRlbGV0ZU9iamVjdCIsIl9wcm9taXNlIiwiZGVsZXRlT2JqZWN0cyIsIm9iamVjdElEcyIsInByZXBhcmVSZXF1ZXN0IiwiZGVsZXRlQnlRdWVyeSIsImNsaWVudCIsImF0dHJpYnV0ZXNUb1JldHJpZXZlIiwiZGlzdGluY3QiLCJzdG9wT3JEZWxldGUiLCJzZWFyY2hDb250ZW50IiwibmJIaXRzIiwiZ2V0T2JqZWN0SUQiLCJ3YWl0VGFzayIsImRvRGVsZXRlQnlRdWVyeSIsImRlbGV0ZU9iamVjdHNDb250ZW50IiwidGFza0lEIiwic3VjY2VzcyIsImZhaWx1cmUiLCJfc2V0VGltZW91dCIsImJyb3dzZUFsbCIsIm1lcmdlIiwiSW5kZXhCcm93c2VyIiwiYnJvd3NlTG9vcCIsImN1cnNvciIsIl9zdG9wcGVkIiwiYnJvd3NlQ2FsbGJhY2siLCJfZXJyb3IiLCJfcmVzdWx0IiwiX2VuZCIsInR0QWRhcHRlciIsInN5bmNDYiIsImFzeW5jQ2IiLCJzZWFyY2hEb25lIiwiYmFzZURlbGF5IiwibWF4RGVsYXkiLCJyZXRyeUxvb3AiLCJzdGF0dXMiLCJzdWNjZXNzQ2IiLCJmYWlsdXJlQ2IiLCJjbGVhckluZGV4IiwiZ2V0U2V0dGluZ3MiLCJzZWFyY2hTeW5vbnltcyIsInNhdmVTeW5vbnltIiwic3lub255bSIsImZvcndhcmRUb1NsYXZlcyIsImZvcndhcmRUb1JlcGxpY2FzIiwiZ2V0U3lub255bSIsImRlbGV0ZVN5bm9ueW0iLCJjbGVhclN5bm9ueW1zIiwiYmF0Y2hTeW5vbnltcyIsInN5bm9ueW1zIiwicmVwbGFjZUV4aXN0aW5nU3lub255bXMiLCJzZWFyY2hSdWxlcyIsInNhdmVSdWxlIiwicnVsZSIsImdldFJ1bGUiLCJkZWxldGVSdWxlIiwiY2xlYXJSdWxlcyIsImJhdGNoUnVsZXMiLCJydWxlcyIsImNsZWFyRXhpc3RpbmdSdWxlcyIsInNldFNldHRpbmdzIiwic2V0dGluZ3MiLCJkZXByZWNhdGVkQWRkVXNlcktleVdpdGhWYWxpZGl0eSIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJUZW1wQ3RvciIsImJ1aWxkU2VhcmNoTWV0aG9kIiwiYWxnb2xpYXNlYXJjaCIsInR5cGVBaGVhZEFyZ3MiLCJ0eXBlQWhlYWRWYWx1ZU9wdGlvbiIsInNpbWlsYXJTZWFyY2giLCJicm93c2UiLCJicm93c2VGcm9tIiwic2VhcmNoRm9yRmFjZXRWYWx1ZXMiLCJvbWl0IiwiZmFjZXROYW1lIiwiZmFjZXRRdWVyeSIsImZpbHRlcmVkUGFyYW1zIiwia2V5TmFtZSIsInNlYXJjaFBhcmFtZXRlcnMiLCJzZWFyY2hGYWNldCIsIl9zZWFyY2giLCJhZGRpdGlvbmFsVUEiLCJnZXRPYmplY3RzIiwicXVlcnlQYXJhbSIsImV4dHJhUHJvcGVydGllcyIsImNhcHR1cmVTdGFja1RyYWNlIiwiYWRkVG9FcnJvck9iamVjdCIsImNyZWF0ZUN1c3RvbUVycm9yIiwiQWxnb2xpYVNlYXJjaEN1c3RvbUVycm9yIiwiVW5wYXJzYWJsZUpTT04iLCJSZXF1ZXN0VGltZW91dCIsIk5ldHdvcmsiLCJKU09OUFNjcmlwdEZhaWwiLCJKU09OUFNjcmlwdEVycm9yIiwiVW5rbm93biIsImsiLCJkZXByZWNhdGVkIiwicHJldmlvdXNVc2FnZSIsIm5ld1VzYWdlIiwiZ2l0aHViQW5jaG9yTGluayIsImZvcmVhY2giLCJzb3VyY2VzIiwiZmlsdGVyZWQiLCJkb0ZpbHRlciIsInRvU3RyIiwiaXNBcmdzIiwiaXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJoYXNEb250RW51bUJ1ZyIsImhhc1Byb3RvRW51bUJ1ZyIsImRvbnRFbnVtcyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhjbHVkZWRLZXlzIiwiJGNvbnNvbGUiLCIkZXh0ZXJuYWwiLCIkZnJhbWUiLCIkZnJhbWVFbGVtZW50IiwiJGZyYW1lcyIsIiRpbm5lckhlaWdodCIsIiRpbm5lcldpZHRoIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkc2Nyb2xsTGVmdCIsIiRzY3JvbGxUb3AiLCIkc2Nyb2xsWCIsIiRzY3JvbGxZIiwiJHNlbGYiLCIkd2Via2l0SW5kZXhlZERCIiwiJHdlYmtpdFN0b3JhZ2VJbmZvIiwiJHdpbmRvdyIsImhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSIsImtleXNTaGltIiwiaXNGdW5jdGlvbiIsImlzQXJndW1lbnRzIiwiaXNTdHJpbmciLCJ0aGVLZXlzIiwic2tpcFByb3RvIiwic2tpcENvbnN0cnVjdG9yIiwic2hpbSIsInNoaW1PYmplY3RLZXlzIiwia2V5c1dvcmtzV2l0aEFyZ3VtZW50cyIsIm9yaWdpbmFsS2V5cyIsImNhbGxlZSIsIm5ld0FyciIsIml0ZW1JbmRleCIsIkV2ZW50RW1pdHRlciIsIl9jbGVhbiIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiaXNOdW1iZXIiLCJlciIsImlzVW5kZWZpbmVkIiwibGlzdGVuZXIiLCJuZXdMaXN0ZW5lciIsImZpcmVkIiwicG9zaXRpb24iLCJsaXN0ZW5lckNvdW50IiwiZXZsaXN0ZW5lciIsImVtaXR0ZXIiLCJzdG9yZSIsIk1BWF9BUElfS0VZX0xFTkdUSCIsIlJFU0VUX0FQUF9EQVRBX1RJTUVSIiwiYXBwbGljYXRpb25JRCIsIl9hbGxvd0VtcHR5Q3JlZGVudGlhbHMiLCJob3N0cyIsInJlYWQiLCJ3cml0ZSIsIl90aW1lb3V0cyIsInRpbWVvdXRzIiwiY29ubmVjdCIsIl9jaGVja0FwcElkRGF0YSIsImRlZmF1bHRIb3N0cyIsIl9zaHVmZmxlUmVzdWx0IiwiaG9zdE51bWJlciIsInByZXBhcmVIb3N0IiwiZXh0cmFIZWFkZXJzIiwiX2NhY2hlIiwiX3VhIiwiX3VzZUNhY2hlIiwiX3VzZUZhbGxiYWNrIiwidXNlRmFsbGJhY2siLCJzZXRFeHRyYUhlYWRlciIsImdldEV4dHJhSGVhZGVyIiwidW5zZXRFeHRyYUhlYWRlciIsImFkZEFsZ29saWFBZ2VudCIsImFsZ29saWFBZ2VudCIsImluaXRpYWxPcHRzIiwicmVxdWVzdERlYnVnIiwidHJpZXMiLCJ1c2luZ0ZhbGxiYWNrIiwiaGFzRmFsbGJhY2siLCJfcmVxdWVzdCIsImhlYWRlcnMiLCJfY29tcHV0ZVJlcXVlc3RIZWFkZXJzIiwic2FmZUpTT05TdHJpbmdpZnkiLCJkZWJ1Z0RhdGEiLCJkb1JlcXVlc3QiLCJyZXF1ZXN0ZXIiLCJyZXFPcHRzIiwic3RhcnRUaW1lIiwiY2FjaGVJRCIsImpzb25Cb2R5IiwiX2dldFRpbWVvdXRzRm9yUmVxdWVzdCIsIl9zZXRIb3N0SW5kZXhCeVR5cGUiLCJjdXJyZW50SG9zdCIsIl9nZXRIb3N0QnlUeXBlIiwidHJ5RmFsbGJhY2siLCJodHRwUmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwiaHR0cFJlc3BvbnNlT2siLCJlbmRUaW1lIiwicmVtb3ZlQ3JlZGVudGlhbHMiLCJjb250ZW50TGVuZ3RoIiwicmVzcG9uc2VUZXh0Iiwic2hvdWxkUmV0cnkiLCJyZXRyeVJlcXVlc3QiLCJ1bnJlY292ZXJhYmxlRXJyb3IiLCJyZXRyeVJlcXVlc3RXaXRoSGlnaGVyVGltZW91dCIsIl9pbmNyZW1lbnRIb3N0SW5kZXgiLCJfaW5jcmVtZW50VGltZW91dE11bHRpcGxlciIsIm9rQ2IiLCJub29rQ2IiLCJ3aXRoQVBJS2V5IiwidWEiLCJyZXF1ZXN0SGVhZGVycyIsInVzZXJUb2tlbiIsInNlY3VyaXR5VGFncyIsImFkZFRvUmVxdWVzdEhlYWRlcnMiLCJxdWVyaWVzIiwiSlNPTlBQYXJhbXMiLCJwcmVwYXJlSlNPTlBQYXJhbXMiLCJyZXF1ZXN0SWQiLCJzdHJhdGVneSIsInNldFNlY3VyaXR5VGFncyIsInRhZ3MiLCJzdHJUYWdzIiwib3JlZFRhZ3MiLCJzZXRVc2VyVG9rZW4iLCJzZXRSZXF1ZXN0VGltZW91dCIsIm1pbGxpc2Vjb25kcyIsInNldFRpbWVvdXRzIiwiZ2V0VGltZW91dHMiLCJfZ2V0QXBwSWREYXRhIiwiX2NhY2hlQXBwSWREYXRhIiwiX3NldEFwcElkRGF0YSIsImxhc3RDaGFuZ2UiLCJnZXRUaW1lIiwiX3Jlc2V0SW5pdGlhbEFwcElkRGF0YSIsImhvc3RJbmRleGVzIiwidGltZW91dE11bHRpcGxpZXIiLCJzaHVmZmxlUmVzdWx0Iiwic2h1ZmZsZSIsIl9ob3N0SW5kZXhlcyIsIl90aW1lb3V0TXVsdGlwbGllciIsIl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlIiwiY3VycmVudERhdGEiLCJfZ2V0SG9zdEluZGV4QnlUeXBlIiwiX2dldFRpbWVvdXRNdWx0aXBsaWVyIiwiaG9zdEluZGV4IiwibmV3SG9zdEluZGV4ZXMiLCJjb21wbGV0ZSIsInByZXBhcmUiLCJob3N0IiwidG9KU09OIiwib3V0IiwiY3VycmVudEluZGV4IiwidGVtcG9yYXJ5VmFsdWUiLCJyYW5kb21JbmRleCIsIm5ld0hlYWRlcnMiLCJoZWFkZXJOYW1lIiwibG9jYWxTdG9yYWdlTmFtZXNwYWNlIiwibW9kdWxlU3RvcmUiLCJsb2NhbFN0b3JhZ2VTdG9yZSIsImxvY2FsU3RvcmFnZUZhaWx1cmUiLCJjbGVhbnVwIiwic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJnZXRPclNldCIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImNvbG9ycyIsIldlYmtpdEFwcGVhcmFuY2UiLCJmaXJlYnVnIiwidGFibGUiLCIkMSIsImZvcm1hdHRlcnMiLCJodW1hbml6ZSIsImRpZmYiLCJjb2xvciIsImxhc3RDIiwibmFtZXNwYWNlcyIsIkRFQlVHIiwiZW5hYmxlIiwiY3JlYXRlRGVidWciLCJkaXNhYmxlIiwiZW5hYmxlZCIsIm5hbWVzIiwic2tpcHMiLCJwcmV2VGltZSIsInNlbGVjdENvbG9yIiwiYWJzIiwiY3VyciIsImZvcm1hdCIsImZvcm1hdHRlciIsImxvZ0ZuIiwic3Vic3RyIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsInJvdW5kIiwicGx1cmFsIiwidWFTdWZmaXgiLCJpbmxpbmVIZWFkZXJzIiwianNvbnBSZXF1ZXN0IiwicGxhY2VzIiwiY2xvbmVEZWVwIiwiZ2V0RG9jdW1lbnRQcm90b2NvbCIsIkFsZ29saWFTZWFyY2hCcm93c2VyIiwiaW5pdFBsYWNlcyIsIl9fYWxnb2xpYSIsInN1cHBvcnQiLCJoYXNYTUxIdHRwUmVxdWVzdCIsImhhc1hEb21haW5SZXF1ZXN0IiwiY29ycyIsIlhNTEh0dHBSZXF1ZXN0Iiwid3JhcFJlcXVlc3QiLCJyZXEiLCJYRG9tYWluUmVxdWVzdCIsInJlcVRpbWVvdXQiLCJ0aW1lZE91dCIsImNvbm5lY3RlZCIsIm9ucHJvZ3Jlc3MiLCJvblJlYWR5U3RhdGVDaGFuZ2UiLCJvbmxvYWQiLCJvbkxvYWQiLCJvbkVycm9yIiwic2V0UmVxdWVzdEhlYWRlciIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsIm1vcmUiLCJhYm9ydCIsIm9uQ29ubmVjdCIsInJlYWR5U3RhdGUiLCJyZXF1ZXN0RmFsbGJhY2siLCJ3cmFwSnNvbnBSZXF1ZXN0IiwianNvbnBSZXF1ZXN0RG9uZSIsInJlamVjdFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZSIsImRlbGF5UHJvbWlzZSIsInJlc29sdmVPblRpbWVvdXQiLCJ3aW4iLCJFUzZQcm9taXNlIiwib2JqZWN0T3JGdW5jdGlvbiIsIl9pc0FycmF5IiwidmVydHhOZXh0IiwiY3VzdG9tU2NoZWR1bGVyRm4iLCJhc2FwIiwic2NoZWR1bGVGbHVzaCIsInNldFNjaGVkdWxlciIsInNjaGVkdWxlRm4iLCJzZXRBc2FwIiwiYXNhcEZuIiwiYnJvd3NlcldpbmRvdyIsImJyb3dzZXJHbG9iYWwiLCJCcm93c2VyTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJpc05vZGUiLCJpc1dvcmtlciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwidXNlTmV4dFRpY2siLCJ1c2VWZXJ0eFRpbWVyIiwidXNlU2V0VGltZW91dCIsInVzZU11dGF0aW9uT2JzZXJ2ZXIiLCJpdGVyYXRpb25zIiwidXNlTWVzc2FnZUNoYW5uZWwiLCJnbG9iYWxTZXRUaW1lb3V0IiwiYXR0ZW1wdFZlcnR4IiwidmVydHgiLCJydW5Pbkxvb3AiLCJydW5PbkNvbnRleHQiLCJvbkZ1bGZpbGxtZW50Iiwib25SZWplY3Rpb24iLCJfYXJndW1lbnRzIiwiUFJPTUlTRV9JRCIsIl9zdGF0ZSIsImludm9rZUNhbGxiYWNrIiwic3Vic2NyaWJlIiwicmVzb2x2ZSQxIiwiQ29uc3RydWN0b3IiLCJQRU5ESU5HIiwiRlVMRklMTEVEIiwiUkVKRUNURUQiLCJHRVRfVEhFTl9FUlJPUiIsIkVycm9yT2JqZWN0Iiwic2VsZkZ1bGZpbGxtZW50IiwiY2Fubm90UmV0dXJuT3duIiwiZ2V0VGhlbiIsInRyeVRoZW4iLCJ0aGVuJCQxIiwiZnVsZmlsbG1lbnRIYW5kbGVyIiwicmVqZWN0aW9uSGFuZGxlciIsImhhbmRsZUZvcmVpZ25UaGVuYWJsZSIsInRoZW5hYmxlIiwiX2xhYmVsIiwiaGFuZGxlT3duVGhlbmFibGUiLCJoYW5kbGVNYXliZVRoZW5hYmxlIiwibWF5YmVUaGVuYWJsZSIsInB1Ymxpc2hSZWplY3Rpb24iLCJfb25lcnJvciIsInB1Ymxpc2giLCJfc3Vic2NyaWJlcnMiLCJzdWJzY3JpYmVycyIsInNldHRsZWQiLCJkZXRhaWwiLCJUUllfQ0FUQ0hfRVJST1IiLCJ0cnlDYXRjaCIsImhhc0NhbGxiYWNrIiwic3VjY2VlZGVkIiwiZmFpbGVkIiwiaW5pdGlhbGl6ZVByb21pc2UiLCJuZXh0SWQiLCJFbnVtZXJhdG9yJDEiLCJpbnB1dCIsIl9pbnN0YW5jZUNvbnN0cnVjdG9yIiwiX3JlbWFpbmluZyIsIl9lbnVtZXJhdGUiLCJ2YWxpZGF0aW9uRXJyb3IiLCJfZWFjaEVudHJ5IiwiZW50cnkiLCJyZXNvbHZlJCQxIiwiX3RoZW4iLCJfc2V0dGxlZEF0IiwiUHJvbWlzZSQyIiwiX3dpbGxTZXR0bGVBdCIsImVudW1lcmF0b3IiLCJhbGwkMSIsImVudHJpZXMiLCJyYWNlJDEiLCJyZWplY3QkMSIsIm5lZWRzUmVzb2x2ZXIiLCJuZWVkc05ldyIsIl9zZXRTY2hlZHVsZXIiLCJfc2V0QXNhcCIsIl9hc2FwIiwiX2NhdGNoIiwicG9seWZpbGwkMSIsIlAiLCJwcm9taXNlVG9TdHJpbmciLCJjYXN0IiwicG9seWZpbGwiLCJlbmNvZGUiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJzZXAiLCJlcSIsIm9iamVjdEtleXMiLCJrcyIsInhzIiwiSlNPTlBDb3VudGVyIiwiY2JDYWxsZWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNiTmFtZSIsInJlbW92ZUdsb2JhbHMiLCJjbGVhbiIsIm9udGltZW91dCIsInJlYWR5c3RhdGVjaGFuZ2UiLCJjcmVhdGVQbGFjZXNDbGllbnQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7OztBQU1DLFlBQVVBLElBQVYsRUFBZ0JDLFVBQWhCLEVBQTRCO0FBQ3pCOztBQUNBLFNBQUksSUFBSixFQUFnRDtBQUM1Q0MsU0FBQSxvQ0FBT0QsVUFBUDtBQUNILE1BRkQsTUFFTyxJQUFJLFFBQU9FLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEJBLE9BQU9DLE9BQXpDLEVBQWtEO0FBQ3JERCxnQkFBT0MsT0FBUCxHQUFpQkgsWUFBakI7QUFDSCxNQUZNLE1BRUE7QUFDSEQsY0FBS0ssR0FBTCxHQUFXSixZQUFYO0FBQ0g7QUFDSixFQVRBLGFBU08sWUFBWTtBQUNoQjs7QUFFQTs7QUFDQSxTQUFJSyxPQUFPLFNBQVBBLElBQU8sR0FBVyxDQUFFLENBQXhCO0FBQ0EsU0FBSUMsZ0JBQWdCLFdBQXBCOztBQUVBLFNBQUlDLGFBQWEsQ0FDYixPQURhLEVBRWIsT0FGYSxFQUdiLE1BSGEsRUFJYixNQUphLEVBS2IsT0FMYSxDQUFqQjs7QUFRQTtBQUNBLGNBQVNDLFVBQVQsQ0FBb0JDLEdBQXBC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RDtBQStCRCxFOzs7Ozs7QUNwQ0Q7O0FBRUF2RixRQUFPQyxPQUFQLEdBQWlCdXlFLG1CQUFqQjs7QUFFQSxVQUFTQSxtQkFBVCxHQUErQjtBQUM3QixPQUFJM2MsV0FBV3J6RCxPQUFPRyxRQUFQLENBQWdCSyxRQUFoQixDQUF5QjZ5RCxRQUF4Qzs7QUFFQTtBQUNBLE9BQUlBLGFBQWEsT0FBYixJQUF3QkEsYUFBYSxRQUF6QyxFQUFtRDtBQUNqREEsZ0JBQVcsT0FBWDtBQUNEOztBQUVELFVBQU9BLFFBQVA7QUFDRCxFOzs7Ozs7QUNiRDs7QUFFQTcxRCxRQUFPQyxPQUFQLEdBQWlCLFFBQWpCLEMiLCJmaWxlIjoiZXZlbnQtcGFnZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDUyMDlmNDk0ZWY2ODYwZWQzY2Q5IiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnXG5pbXBvcnQgUSBmcm9tICdxJ1xuXG5pbXBvcnQgRXhwbGFhaW5TZWFyY2ggZnJvbSAnLi4vcGx1Z2lucy9leHBsYWFpbi1zZWFyY2guanMnO1xuXG5sb2cuc2V0TGV2ZWwoJ2RlYnVnJylcblxuY29uc3QgVXNlcklEcyA9IHtcbiAgbGl2ZToge1xuICAgIEplcmVteTogJzE2Mjc4ODg4MDA1NjkzMDknLFxuICAgIE1hdHQ6ICcxNDU1NzA3MjQ3ODUwMDY5JyxcbiAgICBDYXJvbDogJzE0NTkwNjg5OTA4NzgwNzcnLFxuICAgIEhhcnJpZXQ6ICcxNDc4Nzc2MjMyMTYxNDY4JyxcbiAgICBKb25ueTogJzE1MTM1NTQ0Mzg3Mjk3NTMnLFxuICB9LFxuICBzdGFnaW5nOiB7XG4gICAgSmVyZW15OiAnMTM2Njc0NjM3MDA4OTUyNycsXG4gICAgTWF0dDogJzE1MjgxMzQ5OTA1NjMyMDInLFxuICB9LFxuICBsb2NhbDoge1xuICAgIEplcmVteTogJzEzMDAxMjA4ODAxMTA3NzMnLFxuICAgIE1hdHQ6ICcxNDI4NDE5MTAwNTI4NDM4JyxcbiAgfSxcbiAgZHJpdmU6IHtcbiAgICBKZXJlbXk6ICcxMDQzODAxMTAyNzk2NTg5MjAxNzUnLFxuICAgIEFDTUU6ICcxMDExMTgzODczMDEyODYyMzIyMjInXG4gIH1cbn1cblxuY29uc3QgVXNlcklEID0gVXNlcklEcy5saXZlLkFDTUVcbnZhciBQYWdlUmVzdWx0cyA9IHt9XG52YXIgVXNlckNhcmRzID0gW11cbnZhciBMYXN0UmVmcmVzaCA9IDBcblxuY29uc3QgYWxnb2xpYVBhcmFtcyA9IHsgLy8gTmVlZCB0byBzZW5kIHRoZXNlIHRvIGFwcC52dWUgdG8gYXZvaWQgZHVwbGljYXRpb24hXG4gIGFwcElEOiAnSTJWS01OTkFYSScsXG4gIGFwaUtleTogJzJiODQwNmY4NGNkNGNjNTA3ZGExNzMwMzJjNDZlZTdiJyxcbiAgaW5kZXg6ICdGb3JnZXRNZU5vdF9Db250ZXh0X1Rlc3RfTG9jYWwnXG59XG5WdWUudXNlKEV4cGxhYWluU2VhcmNoLCBhbGdvbGlhUGFyYW1zKVxuXG5jaHJvbWUuYnJvd3NlckFjdGlvbi5vbkNsaWNrZWQuYWRkTGlzdGVuZXIoZnVuY3Rpb24odGFiKSB7XG4gIGNocm9tZS50YWJzLnF1ZXJ5KHthY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWV9LCBmdW5jdGlvbih0YWJzKXtcbiAgICBjaHJvbWUudGFicy5zZW5kTWVzc2FnZSh0YWJzWzBdLmlkLCB7YWN0aW9uOiAndG9nZ2xlRHJhd2VyJ30sIGZ1bmN0aW9uKHJlcykge1xuICAgICAgbG9nLmluZm8ocmVzKVxuICAgIH0pXG4gIH0pXG59KTtcblxuY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHJlcXVlc3QsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKChzZW5kZXIudGFiID8gXCJGcm9tIGEgY29udGVudCBzY3JpcHQ6IFwiICsgc2VuZGVyLnRhYi51cmwgOiBcIkZyb20gdGhlIGV4dGVuc2lvblwiKSwgcmVxdWVzdClcblxuICAgIGlmKHJlcXVlc3QuYWN0aW9uID09IFwiZ2V0UGFnZVJlc3VsdHNcIil7XG4gICAgICBnZXRDdXJyZW50UGFnZVJlc3VsdHMocmVxdWVzdC5kYXRhKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhyZXMpXG4gICAgICAgIHNlbmRSZXNwb25zZShyZXMpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LmFjdGlvbiA9PSBcImNoZWNrUGFnZVwiKSB7XG4gICAgICBsb2cudHJhY2UocmVxdWVzdC5kYXRhKTtcbiAgICAgIGNoZWNrUmVmcmVzaCgpXG4gICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEV4cGxhYWluU2VhcmNoLmdldFBhZ2VSZXN1bHRzKFVzZXJJRCwgcmVxdWVzdC5kYXRhLCBVc2VyQ2FyZHMpXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBhZGRUb1BhZ2VSZXN1bHRzKHNlbmRlci50YWIuaWQsIHJlcylcbiAgICAgICAgUGFnZVJlc3VsdHMgPSByZXM7XG4gICAgICAgIHNlbmRSZXNwb25zZShyZXMpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBsb2cuZXJyb3IoZSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYocmVxdWVzdC5hY3Rpb24gPT0gXCJnZXRVc2VyXCIpe1xuICAgICAgc2VuZFJlc3BvbnNlKFVzZXJJRCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYocmVxdWVzdC5hY3Rpb24gPT0gXCJyZWZyZXNoQ2FyZHNcIil7XG4gICAgICBnZXRBbGxVc2VyQ2FyZHMoKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmKHJlcXVlc3QuZXZlbnQgPT0gXCJwb3B1cE9wZW5lZFwiKXtcbiAgICAgIGNocm9tZS50YWJzLnF1ZXJ5KHthY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWV9LCBmdW5jdGlvbih0YWJzKXtcbiAgICAgICAgY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UodGFic1swXS5pZCwge2V2ZW50OiAncG9wdXBPcGVuZWQnfSwgZnVuY3Rpb24ocmVzcG9uc2UpIHt9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICBsb2cuZXJyb3IoZSlcbiAgfVxufSlcblxuY29uc3QgZ2V0Q3VycmVudFBhZ2VSZXN1bHRzID0gZnVuY3Rpb24oZGF0YSkge1xuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIHZhciB0YWJJRDtcbiAgbG9nLmRlYnVnKDEpXG4gIGNoZWNrUmVmcmVzaCgpXG4gIC50aGVuKGdldEN1cnJlbnRUYWIpXG4gIC50aGVuKGZ1bmN0aW9uKHRhYikge1xuICAgIGxvZy5kZWJ1Zyh0YWIuaWQpXG4gICAgdGFiSUQgPSB0YWIuaWRcbiAgICBsb2cuZGVidWcoUGFnZVJlc3VsdHMpXG4gICAgaWYgKFBhZ2VSZXN1bHRzW3RhYklEXSkge1xuICAgICAgZC5yZXNvbHZlKFBhZ2VSZXN1bHRzW3RhYklEXSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFkYXRhKSBkYXRhID0ge3RhYklEOiB0YWJJRH1cbiAgICAgIGxvZy5kZWJ1ZyhkYXRhKVxuICAgICAgZ2V0UGFnZURhdGEoZGF0YSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBsb2cuZGVidWcocmVzKVxuICAgICAgICByZXR1cm4gRXhwbGFhaW5TZWFyY2guZ2V0UGFnZVJlc3VsdHMoVXNlcklELCByZXMsIFVzZXJDYXJkcylcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhyZXMpXG4gICAgICAgIGFkZFRvUGFnZVJlc3VsdHModGFiSUQsIHJlcylcbiAgICAgICAgZC5yZXNvbHZlKHJlcylcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgIH0pXG4gICAgfVxuICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgZC5yZWplY3QoZSlcbiAgfSlcbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBnZXRDdXJyZW50VGFiID0gZnVuY3Rpb24oKSB7XG4gIC8vIE5lZWQgZXJyb3IgY2F0Y2hpbmcgaGVyZVxuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIGNocm9tZS50YWJzLnF1ZXJ5KHthY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWV9LCBmdW5jdGlvbih0YWJzKXtcbiAgICBkLnJlc29sdmUodGFic1swXSlcbiAgfSlcbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBnZXRQYWdlRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBpZiAoZGF0YS5wYWdlRGF0YSkge1xuICAgIGQucmVzb2x2ZShkYXRhLnBhZ2VEYXRhKVxuICB9IGVsc2UgaWYgKGRhdGEudGFiSUQpIHtcbiAgICBzZW5kTWVzc2FnZVRvVGFiKHRhYklELCB7YWN0aW9uOiAnZ2V0UGFnZURhdGEnfSlcbiAgICAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIGQucmVzb2x2ZShyZXMpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBkLnJlamVjdCgpXG4gIH1cbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBzZW5kTWVzc2FnZVRvVGFiID0gZnVuY3Rpb24odGFiSUQsIGRhdGEpIHtcbiAgLy8gTmVlZCBlcnJvciBjYXRjaGluZyBoZXJlXG4gIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UodGFiSUQsIGRhdGEsIGZ1bmN0aW9uKHJlcykge1xuICAgIGxvZy5kZWJ1ZyhyZXMpXG4gICAgZC5yZXNvbHZlKHJlcylcbiAgfSlcbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBhZGRUb1BhZ2VSZXN1bHRzID0gZnVuY3Rpb24odGFiSUQsIGRhdGEpIHtcbiAgUGFnZVJlc3VsdHNbdGFiSURdID0gZGF0YVxuICBjaHJvbWUudGFicy5xdWVyeSh7YWN0aXZlOiB0cnVlLCBjdXJyZW50V2luZG93OiB0cnVlfSwgZnVuY3Rpb24odGFicyl7XG4gICAgT2JqZWN0LmtleXMoUGFnZVJlc3VsdHMpLmZvckVhY2goZnVuY3Rpb24ocGFnZVRhYklEKSB7XG4gICAgICBpZiAoIHRhYnMuZmlsdGVyKGZ1bmN0aW9uKHRhYikge3JldHVybiB0YWIuaWQgPT0gcGFnZVRhYklEfSkubGVuZ3RoID09IDAgKVxuICAgICAgICBkZWxldGUgUGFnZVJlc3VsdHNbcGFnZVRhYklEXVxuICAgIH0pXG4gICAgbG9nLmRlYnVnKFBhZ2VSZXN1bHRzKVxuICB9KVxufVxuXG5jb25zdCBjaGVja1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGlmIChub3cgLSBMYXN0UmVmcmVzaCA+IDMwMDAwMCkge1xuICAgIGdldEFsbFVzZXJDYXJkcygpXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBkLnJlc29sdmUoKVxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIGxvZy5lcnJvcihlKVxuICAgICAgZC5yZWplY3QoZSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGQucmVzb2x2ZSgpXG4gIH1cbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBnZXRBbGxVc2VyQ2FyZHMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBMYXN0UmVmcmVzaCA9IG5ldyBEYXRlKClcbiAgRXhwbGFhaW5TZWFyY2guc2VhcmNoQ2FyZHMoVXNlcklELCAnJywgMTAwMClcbiAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIFVzZXJDYXJkcyA9IHJlc3VsdHM7XG4gICAgbG9nLmRlYnVnKFVzZXJDYXJkcyk7XG4gICAgZC5yZXNvbHZlKClcbiAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgIGxvZy5lcnJvcihlKVxuICAgIGQucmVqZWN0KGUpXG4gIH0pXG4gIHJldHVybiBkLnByb21pc2Vcbn1cbmdldEFsbFVzZXJDYXJkcygpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvc2NyaXB0cy9ldmVudC1wYWdlLmpzIiwiLyohXG4gKiBWdWUuanMgdjIuNC4yXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZml4IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuLmNhbGwodGhpcywgcGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMpIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSBpbmplY3RbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChjb21wLl9fZXNNb2R1bGUgJiYgY29tcC5kZWZhdWx0KSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBrZWVwaW5nIGEgZGV0YWNoZWQgRE9NIHRyZWUgaW4gbWVtb3J5ICgjNTg1MSlcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuc2VycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnM7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uVHlwZSAodm0sIG5hbWUpIHtcbiAgdmFyIG9wdGlvbiA9IHZtLiRvcHRpb25zW25hbWVdO1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0aW9uKSkge1xuICAgIHdhcm4oXG4gICAgICAoXCJjb21wb25lbnQgb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgc2hvdWxkIGJlIGFuIG9iamVjdC5cIiksXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSB8fCBjb25maWcuaXNSZXNlcnZlZEF0dHIoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ2NvbXB1dGVkJyk7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIgfHwgbm9vcCwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnbWV0aG9kcycpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ3dhdGNoJyk7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAga2V5T3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc291cmNlKSB7XG4gICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQob3VycywgZXhpc3RpbmcpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzLCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzLCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgVnVlLnByb3RvdHlwZS5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLWluaXQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKCgodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBjdXJyZW50LCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgaWYgKGNhY2hlZE5vZGUgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuNC4yJztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAobW9kZWxScy5leHApICsgXCIsIFwiICsgKG1vZGVsUnMuaWR4KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoZW5jb2RlZCkgPiAwXG59XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKGxhc3RUYWcsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14sXSopLChbXixdKikoPzosKFteLF0qKSk/XFwpLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9O1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhYXR0cnMubGVuZ3RoO1xuXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMl0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQpIHtcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFszXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW25hbWVdO1xuICAgIC8vICM1MzMwOiB3YXJuIGNsaWNrLnJpZ2h0LCBzaW5jZSByaWdodCBjbGlja3MgZG8gbm90IGFjdHVhbGx5IGZpcmUgY2xpY2sgZXZlbnRzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBuYW1lID09PSAnY2xpY2snICYmXG4gICAgICBoYW5kbGVyICYmIGhhbmRsZXIubW9kaWZpZXJzICYmIGhhbmRsZXIubW9kaWZpZXJzLnJpZ2h0XG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlVzZSBcXFwiY29udGV4dG1lbnVcXFwiIGluc3RlYWQgb2YgXFxcImNsaWNrLnJpZ2h0XFxcIiBzaW5jZSByaWdodCBjbGlja3MgXCIgK1xuICAgICAgICBcImRvIG5vdCBhY3R1YWxseSBmaXJlIFxcXCJjbGlja1xcXCIgZXZlbnRzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcikpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIHJldHVybiBpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgID8gaGFuZGxlci52YWx1ZVxuICAgICAgOiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwiKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIgYWxpYXMgPSBrZXlDb2Rlc1trZXldO1xuICByZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyAoYWxpYXMgPyAnLCcgKyBKU09OLnN0cmluZ2lmeShhbGlhcykgOiAnJykgKyBcIilcIilcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIChrZXkgPyAoXCIsXCIgKyBrZXkpIDogXCJcIikgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSlcbiAgfVxuICByZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn19XCJcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG4gICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxNyBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9ibG9iL3YxL0xJQ0VOU0VcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IFR5bGVyIENsb3NlXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDA5IFR5bGVyIENsb3NlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIFggbGljZW5zZSBmb3VuZFxuICogYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5odG1sXG4gKiBGb3JrZWQgYXQgcmVmX3NlbmQuanMgdmVyc2lvbjogMjAwOS0wNS0xMVxuICpcbiAqIFdpdGggcGFydHMgYnkgTWFyayBNaWxsZXJcbiAqIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFRoaXMgZmlsZSB3aWxsIGZ1bmN0aW9uIHByb3Blcmx5IGFzIGEgPHNjcmlwdD4gdGFnLCBvciBhIG1vZHVsZVxuICAgIC8vIHVzaW5nIENvbW1vbkpTIGFuZCBOb2RlSlMgb3IgUmVxdWlyZUpTIG1vZHVsZSBmb3JtYXRzLiAgSW5cbiAgICAvLyBDb21tb24vTm9kZS9SZXF1aXJlSlMsIHRoZSBtb2R1bGUgZXhwb3J0cyB0aGUgUSBBUEkgYW5kIHdoZW5cbiAgICAvLyBleGVjdXRlZCBhcyBhIHNpbXBsZSA8c2NyaXB0PiwgaXQgY3JlYXRlcyBhIFEgZ2xvYmFsIGluc3RlYWQuXG5cbiAgICAvLyBNb250YWdlIFJlcXVpcmVcbiAgICBpZiAodHlwZW9mIGJvb3RzdHJhcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGJvb3RzdHJhcChcInByb21pc2VcIiwgZGVmaW5pdGlvbik7XG5cbiAgICAvLyBDb21tb25KU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcblxuICAgIC8vIFJlcXVpcmVKU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuXG4gICAgLy8gU0VTIChTZWN1cmUgRWNtYVNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKCFzZXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VzLm1ha2VRID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuXG4gICAgLy8gPHNjcmlwdD5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gUHJlZmVyIHdpbmRvdyBvdmVyIHNlbGYgZm9yIGFkZC1vbiBzY3JpcHRzLiBVc2Ugc2VsZiBmb3JcbiAgICAgICAgLy8gbm9uLXdpbmRvd2VkIGNvbnRleHRzLlxuICAgICAgICB2YXIgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBgd2luZG93YCBvYmplY3QsIHNhdmUgdGhlIHByZXZpb3VzIFEgZ2xvYmFsXG4gICAgICAgIC8vIGFuZCBpbml0aWFsaXplIFEgYXMgYSBnbG9iYWwuXG4gICAgICAgIHZhciBwcmV2aW91c1EgPSBnbG9iYWwuUTtcbiAgICAgICAgZ2xvYmFsLlEgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAgICAgLy8gQWRkIGEgbm9Db25mbGljdCBmdW5jdGlvbiBzbyBRIGNhbiBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgIC8vIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIGdsb2JhbC5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnbG9iYWwuUSA9IHByZXZpb3VzUTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaXBhdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuICAgIC8vIHF1ZXVlIGZvciBsYXRlIHRhc2tzLCB1c2VkIGJ5IHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmdcbiAgICB2YXIgbGF0ZXJRdWV1ZSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgdGFzaywgZG9tYWluO1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pO1xuXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxhdGVyUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXNrID0gbGF0ZXJRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBydW5zIGEgc2luZ2xlIGZ1bmN0aW9uIGluIHRoZSBhc3luYyBxdWV1ZVxuICAgIGZ1bmN0aW9uIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHByb2Nlc3MudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgICAvLyBFbnN1cmUgUSBpcyBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudCwgd2l0aCBhIGBwcm9jZXNzLm5leHRUaWNrYC5cbiAgICAgICAgLy8gVG8gc2VlIHRocm91Z2ggZmFrZSBOb2RlIGVudmlyb25tZW50czpcbiAgICAgICAgLy8gKiBNb2NoYSB0ZXN0IHJ1bm5lciAtIGV4cG9zZXMgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgXG4gICAgICAgIC8vICogQnJvd3NlcmlmeSAtIGV4cG9zZXMgYSBgcHJvY2Vzcy5uZXhUaWNrYCBmdW5jdGlvbiB0aGF0IHVzZXNcbiAgICAgICAgLy8gICBgc2V0VGltZW91dGAuIEluIHRoaXMgY2FzZSBgc2V0SW1tZWRpYXRlYCBpcyBwcmVmZXJyZWQgYmVjYXVzZVxuICAgICAgICAvLyAgICBpdCBpcyBmYXN0ZXIuIEJyb3dzZXJpZnkncyBgcHJvY2Vzcy50b1N0cmluZygpYCB5aWVsZHNcbiAgICAgICAgLy8gICBcIltvYmplY3QgT2JqZWN0XVwiLCB3aGlsZSBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudFxuICAgICAgICAvLyAgIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkcyBcIltvYmplY3QgcHJvY2Vzc11cIi5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBydW5zIGEgdGFzayBhZnRlciBhbGwgb3RoZXIgdGFza3MgaGF2ZSBiZWVuIHJ1blxuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciB1bmhhbmRsZWQgcmVqZWN0aW9uIHRyYWNraW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgYWxsIGB0aGVuYGQgdGFza3MgaGF2ZSBiZWVuIHJ1bi5cbiAgICBuZXh0VGljay5ydW5BZnRlciA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGxhdGVyUXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5leHRUaWNrO1xufSkoKTtcblxuLy8gQXR0ZW1wdCB0byBtYWtlIGdlbmVyaWNzIHNhZmUgaW4gdGhlIGZhY2Ugb2YgZG93bnN0cmVhbVxuLy8gbW9kaWZpY2F0aW9ucy5cbi8vIFRoZXJlIGlzIG5vIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIG5lY2Vzc2FyeS5cbi8vIElmIHlvdSBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLCB0aGVzZSBwcmltb3JkaWFscyBuZWVkIHRvIGJlXG4vLyBkZWVwbHkgZnJvemVuIGFueXdheSwgYW5kIGlmIHlvdSBkb27igJl0IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsXG4vLyB0aGlzIGlzIGp1c3QgcGxhaW4gcGFyYW5vaWQuXG4vLyBIb3dldmVyLCB0aGlzICoqbWlnaHQqKiBoYXZlIHRoZSBuaWNlIHNpZGUtZWZmZWN0IG9mIHJlZHVjaW5nIHRoZSBzaXplIG9mXG4vLyB0aGUgbWluaWZpZWQgY29kZSBieSByZWR1Y2luZyB4LmNhbGwoKSB0byBtZXJlbHkgeCgpXG4vLyBTZWUgTWFyayBNaWxsZXLigJlzIGV4cGxhbmF0aW9uIG9mIHdoYXQgdGhpcyBkb2VzLlxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9Y29udmVudGlvbnM6c2FmZV9tZXRhX3Byb2dyYW1taW5nXG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLy8gVGhpcyBpcyBlcXVpdmFsZW50LCBidXQgc2xvd2VyOlxuLy8gdW5jdXJyeVRoaXMgPSBGdW5jdGlvbl9iaW5kLmJpbmQoRnVuY3Rpb25fYmluZC5jYWxsKTtcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VuY3Vycnl0aGlzXG5cbnZhciBhcnJheV9zbGljZSA9IHVuY3VycnlUaGlzKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbnZhciBhcnJheV9yZWR1Y2UgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzaXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBjb25jZXJuaW5nIHRoZSBpbml0aWFsIHZhbHVlLCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYXJyYXksIGFjY291bnRpbmdcbiAgICAgICAgICAgIC8vIGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCBpcyBpcyBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzID0gdGhpc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdWNlXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGFycmF5IGlzIHNwYXJzZVxuICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBiYXNpcyA9IGNhbGxiYWNrKGJhc2lzLCB0aGlzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNpcztcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfaW5kZXhPZiA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBub3QgYSB2ZXJ5IGdvb2Qgc2hpbSwgYnV0IGdvb2QgZW5vdWdoIGZvciBvdXIgb25lIHVzZSBvZiBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfbWFwID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbGxlY3QgPSBbXTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHNlbGYsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc3AsIHZhbHVlLCBpbmRleCwgc2VsZikpO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICByZXR1cm4gY29sbGVjdDtcbiAgICB9XG4pO1xuXG52YXIgb2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgIGZ1bmN0aW9uIFR5cGUoKSB7IH1cbiAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IFR5cGUoKTtcbn07XG5cbnZhciBvYmplY3RfZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgIG9ialtwcm9wXSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBvYmplY3RfaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxudmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0X2hhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgb2JqZWN0X3RvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBPYmplY3QodmFsdWUpO1xufVxuXG4vLyBnZW5lcmF0b3IgcmVsYXRlZCBzaGltc1xuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuZnVuY3Rpb24gaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICAgIG9iamVjdF90b1N0cmluZyhleGNlcHRpb24pID09PSBcIltvYmplY3QgU3RvcEl0ZXJhdGlvbl1cIiB8fFxuICAgICAgICBleGNlcHRpb24gaW5zdGFuY2VvZiBRUmV0dXJuVmFsdWVcbiAgICApO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaGVscGVyIGFuZCBRLnJldHVybiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpblxuLy8gU3BpZGVyTW9ua2V5LlxudmFyIFFSZXR1cm5WYWx1ZTtcbmlmICh0eXBlb2YgUmV0dXJuVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBSZXR1cm5WYWx1ZTtcbn0gZWxzZSB7XG4gICAgUVJldHVyblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xufVxuXG4vLyBsb25nIHN0YWNrIHRyYWNlc1xuXG52YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCI7XG5cbmZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFFcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBwcm9taXNlYC4gU2VlICM1Ny5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIHByb21pc2Uuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjayAmJiAoIWVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fIHx8IGVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fID4gcC5zdGFja0NvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0X2RlZmluZVByb3BlcnR5KGVycm9yLCBcIl9fbWluaW11bVN0YWNrQ291bnRlcl9fXCIsIHt2YWx1ZTogcC5zdGFja0NvdW50ZXIsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgICAgICBvYmplY3RfZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwic3RhY2tcIiwge3ZhbHVlOiBzdGFjaywgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGNvdW50ZXIgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHN0b3BwaW5nIHBvaW50IGZvciBidWlsZGluZ1xuICogbG9uZyBzdGFjayB0cmFjZXMuIEluIG1ha2VTdGFja1RyYWNlTG9uZyB3ZSB3YWxrIGJhY2t3YXJkcyB0aHJvdWdoXG4gKiB0aGUgbGlua2VkIGxpc3Qgb2YgcHJvbWlzZXMsIG9ubHkgc3RhY2tzIHdoaWNoIHdlcmUgY3JlYXRlZCBiZWZvcmVcbiAqIHRoZSByZWplY3Rpb24gYXJlIGNvbmNhdGVuYXRlZC5cbiAqL1xudmFyIGxvbmdTdGFja0NvdW50ZXIgPSAxO1xuXG4vLyBlbmFibGUgbG9uZyBzdGFja3MgaWYgUV9ERUJVRyBpcyBzZXRcbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LlFfREVCVUcpIHtcbiAgICBRLmxvbmdTdGFja1N1cHBvcnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSBvYmplY3QuXG4gKlxuICogYHJlc29sdmVgIGlzIGEgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggYSBtb3JlIHJlc29sdmVkIHZhbHVlIGZvciB0aGVcbiAqIHByb21pc2UuIFRvIGZ1bGZpbGwgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhbnkgdmFsdWUgdGhhdCBpc1xuICogbm90IGEgdGhlbmFibGUuIFRvIHJlamVjdCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGEgcmVqZWN0ZWRcbiAqIHRoZW5hYmxlLCBvciBpbnZva2UgYHJlamVjdGAgd2l0aCB0aGUgcmVhc29uIGRpcmVjdGx5LiBUbyByZXNvbHZlIHRoZVxuICogcHJvbWlzZSB0byBhbm90aGVyIHRoZW5hYmxlLCB0aHVzIHB1dHRpbmcgaXQgaW4gdGhlIHNhbWUgc3RhdGUsIGludm9rZVxuICogYHJlc29sdmVgIHdpdGggdGhhdCBvdGhlciB0aGVuYWJsZS5cbiAqL1xuUS5kZWZlciA9IGRlZmVyO1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgLy8gaWYgXCJtZXNzYWdlc1wiIGlzIGFuIFwiQXJyYXlcIiwgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvbWlzZSBoYXMgbm90IHlldFxuICAgIC8vIGJlZW4gcmVzb2x2ZWQuICBJZiBpdCBpcyBcInVuZGVmaW5lZFwiLCBpdCBoYXMgYmVlbiByZXNvbHZlZC4gIEVhY2hcbiAgICAvLyBlbGVtZW50IG9mIHRoZSBtZXNzYWdlcyBhcnJheSBpcyBpdHNlbGYgYW4gYXJyYXkgb2YgY29tcGxldGUgYXJndW1lbnRzIHRvXG4gICAgLy8gZm9yd2FyZCB0byB0aGUgcmVzb2x2ZWQgcHJvbWlzZS4gIFdlIGNvZXJjZSB0aGUgcmVzb2x1dGlvbiB2YWx1ZSB0byBhXG4gICAgLy8gcHJvbWlzZSB1c2luZyB0aGUgYHJlc29sdmVgIGZ1bmN0aW9uIGJlY2F1c2UgaXQgaGFuZGxlcyBib3RoIGZ1bGx5XG4gICAgLy8gbm9uLXRoZW5hYmxlIHZhbHVlcyBhbmQgb3RoZXIgdGhlbmFibGVzIGdyYWNlZnVsbHkuXG4gICAgdmFyIG1lc3NhZ2VzID0gW10sIHByb2dyZXNzTGlzdGVuZXJzID0gW10sIHJlc29sdmVkUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9IG9iamVjdF9jcmVhdGUoZGVmZXIucHJvdG90eXBlKTtcbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIG9wZXJhbmRzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBcIndoZW5cIiAmJiBvcGVyYW5kc1sxXSkgeyAvLyBwcm9ncmVzcyBvcGVyYW5kXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KHJlc29sdmVkUHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZFxuICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhcmVyVmFsdWUgPSBuZWFyZXIocmVzb2x2ZWRQcm9taXNlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShuZWFyZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5lYXJlclZhbHVlOyAvLyBzaG9ydGVuIGNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlclZhbHVlO1xuICAgIH07XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJwZW5kaW5nXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlLmluc3BlY3QoKTtcbiAgICB9O1xuXG4gICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBkb24ndCB0cnkgdG8gdXNlIGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAgb3IgdHJhbnNmZXIgdGhlXG4gICAgICAgICAgICAvLyBhY2Nlc3NvciBhcm91bmQ7IHRoYXQgY2F1c2VzIG1lbW9yeSBsZWFrcyBhcyBwZXIgR0gtMTExLiBKdXN0XG4gICAgICAgICAgICAvLyByZWlmeSB0aGUgc3RhY2sgdHJhY2UgYXMgYSBzdHJpbmcgQVNBUC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lOyBpdCdzIGFsd2F5cyBqdXN0XG4gICAgICAgICAgICAvLyBcIltvYmplY3QgUHJvbWlzZV1cXG5cIiwgYXMgcGVyIHRoZSBgdG9TdHJpbmdgLlxuICAgICAgICAgICAgcHJvbWlzZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZihcIlxcblwiKSArIDEpO1xuICAgICAgICAgICAgcHJvbWlzZS5zdGFja0NvdW50ZXIgPSBsb25nU3RhY2tDb3VudGVyKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcblxuICAgICAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICAgICAgLy8gT25seSBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBuZXcgcHJvbWlzZSBpZiBsb25nIHN0YWNrc1xuICAgICAgICAgICAgLy8gYXJlIGVuYWJsZWQgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZVxuICAgICAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG4gKiBwcm9taXNlLlxuICogQHJldHVybnMgYSBub2RlYmFja1xuICovXG5kZWZlci5wcm90b3R5cGUubWFrZU5vZGVSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZShhcnJheV9zbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVzb2x2ZXIge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub3RoaW5nIGFuZCBhY2NlcHRzXG4gKiB0aGUgcmVzb2x2ZSwgcmVqZWN0LCBhbmQgbm90aWZ5IGZ1bmN0aW9ucyBmb3IgYSBkZWZlcnJlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IG1heSBiZSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiByZXNvbHZlIGFuZCByZWplY3RcbiAqIGZ1bmN0aW9ucywgb3IgcmVqZWN0ZWQgYnkgYSB0aHJvd24gZXhjZXB0aW9uIGluIHJlc29sdmVyXG4gKi9cblEuUHJvbWlzZSA9IHByb21pc2U7IC8vIEVTNlxuUS5wcm9taXNlID0gcHJvbWlzZTtcbmZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbnByb21pc2UucmFjZSA9IHJhY2U7IC8vIEVTNlxucHJvbWlzZS5hbGwgPSBhbGw7IC8vIEVTNlxucHJvbWlzZS5yZWplY3QgPSByZWplY3Q7IC8vIEVTNlxucHJvbWlzZS5yZXNvbHZlID0gUTsgLy8gRVM2XG5cbi8vIFhYWCBleHBlcmltZW50YWwuICBUaGlzIG1ldGhvZCBpcyBhIHdheSB0byBkZW5vdGUgdGhhdCBhIGxvY2FsIHZhbHVlIGlzXG4vLyBzZXJpYWxpemFibGUgYW5kIHNob3VsZCBiZSBpbW1lZGlhdGVseSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIHVwb24gcmVxdWVzdCxcbi8vIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZS5cblEucGFzc0J5Q29weSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHR3byBwcm9taXNlcyBldmVudHVhbGx5IGZ1bGZpbGwgdG8gdGhlIHNhbWUgdmFsdWUsIHByb21pc2VzIHRoYXQgdmFsdWUsXG4gKiBidXQgb3RoZXJ3aXNlIHJlamVjdHMuXG4gKiBAcGFyYW0geCB7QW55Kn1cbiAqIEBwYXJhbSB5IHtBbnkqfVxuICogQHJldHVybnMge0FueSp9IGEgcHJvbWlzZSBmb3IgeCBhbmQgeSBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYnV0IGEgcmVqZWN0aW9uXG4gKiBvdGhlcndpc2UuXG4gKlxuICovXG5RLmpvaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBRKHgpLmpvaW4oeSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICByZXR1cm4gUShbdGhpcywgdGhhdF0pLnNwcmVhZChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIHNldHRsZWQuXG4gKiBAcGFyYW0gYW5zd2VycyB7QXJyYXlbQW55Kl19IHByb21pc2VzIHRvIHJhY2VcbiAqIEByZXR1cm5zIHtBbnkqfSB0aGUgZmlyc3QgcHJvbWlzZSB0byBiZSBzZXR0bGVkXG4gKi9cblEucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGFuc3dlclBzKSB7XG4gICAgcmV0dXJuIHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24gKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcnJheV9pbmRleE9mKHVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuaGFuZGxlZFJlamVjdGlvblwiLCByZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXRSZXBvcnQgPSBhcnJheV9pbmRleE9mKHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0UmVwb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJyZWplY3Rpb25IYW5kbGVkXCIsIHVuaGFuZGxlZFJlYXNvbnNbYXRdLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdFJlcG9ydCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoYXQsIDEpO1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnNwbGljZShhdCwgMSk7XG4gICAgfVxufVxuXG5RLnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucyA9IHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucztcblxuUS5nZXRVbmhhbmRsZWRSZWFzb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIHRoYXQgY29uc3VtZXJzIGNhbid0IGludGVyZmVyZSB3aXRoIG91ciBpbnRlcm5hbCBzdGF0ZS5cbiAgICByZXR1cm4gdW5oYW5kbGVkUmVhc29ucy5zbGljZSgpO1xufTtcblxuUS5zdG9wVW5oYW5kbGVkUmVqZWN0aW9uVHJhY2tpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gZmFsc2U7XG59O1xuXG5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcblxuLy8vLyBFTkQgVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWplY3RlZCBwcm9taXNlLlxuICogQHBhcmFtIHJlYXNvbiB2YWx1ZSBkZXNjcmliaW5nIHRoZSBmYWlsdXJlXG4gKi9cblEucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciByZWplY3Rpb24gPSBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoZSBlcnJvciBoYXMgYmVlbiBoYW5kbGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1bnRyYWNrUmVqZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQocmVhc29uKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGUgcmVhc29uIGhhcyBub3QgYmVlbiBoYW5kbGVkLlxuICAgIHRyYWNrUmVqZWN0aW9uKHJlamVjdGlvbiwgcmVhc29uKTtcblxuICAgIHJldHVybiByZWplY3Rpb247XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZ1bGZpbGxlZCBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2VcbiAqL1xuUS5mdWxmaWxsID0gZnVsZmlsbDtcbmZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0XCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwic2V0XCI6IGZ1bmN0aW9uIChuYW1lLCByaHMpIHtcbiAgICAgICAgICAgIHZhbHVlW25hbWVdID0gcmhzO1xuICAgICAgICB9LFxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInBvc3RcIjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgTWlsbGVyIHByb3Bvc2VzIHRoYXQgcG9zdCB3aXRoIG5vIG5hbWUgc2hvdWxkIGFwcGx5IGFcbiAgICAgICAgICAgIC8vIHByb21pc2VkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwgfHwgbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYXBwbHlcIjogZnVuY3Rpb24gKHRoaXNwLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpc3AsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBcImtleXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF9rZXlzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZW5hYmxlcyB0byBRIHByb21pc2VzLlxuICogQHBhcmFtIHByb21pc2UgdGhlbmFibGUgcHJvbWlzZVxuICogQHJldHVybnMgYSBRIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gY29lcmNlKHByb21pc2UpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEFubm90YXRlcyBhbiBvYmplY3Qgc3VjaCB0aGF0IGl0IHdpbGwgbmV2ZXIgYmVcbiAqIHRyYW5zZmVycmVkIGF3YXkgZnJvbSB0aGlzIHByb2Nlc3Mgb3ZlciBhbnkgcHJvbWlzZVxuICogY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgcHJvbWlzZSBhIHdyYXBwaW5nIG9mIHRoYXQgb2JqZWN0IHRoYXRcbiAqIGFkZGl0aW9uYWxseSByZXNwb25kcyB0byB0aGUgXCJpc0RlZlwiIG1lc3NhZ2VcbiAqIHdpdGhvdXQgYSByZWplY3Rpb24uXG4gKi9cblEubWFzdGVyID0gbWFzdGVyO1xuZnVuY3Rpb24gbWFzdGVyKG9iamVjdCkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJpc0RlZlwiOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKG9wLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBRKG9iamVjdCkuaW5zcGVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFNwcmVhZHMgdGhlIHZhbHVlcyBvZiBhIHByb21pc2VkIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZVxuICogZnVsZmlsbG1lbnQgY2FsbGJhY2suXG4gKiBAcGFyYW0gZnVsZmlsbGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdmFyaWFkaWMgYXJndW1lbnRzIGZyb20gdGhlXG4gKiBwcm9taXNlZCBhcnJheVxuICogQHBhcmFtIHJlamVjdGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgcHJvbWlzZVxuICogaXMgcmVqZWN0ZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb3IgdGhyb3duIGV4Y2VwdGlvbiBvZlxuICogZWl0aGVyIGNhbGxiYWNrLlxuICovXG5RLnNwcmVhZCA9IHNwcmVhZDtcbmZ1bmN0aW9uIHNwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRoZSBhc3luYyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciBmb3IgZ2VuZXJhdG9yIGZ1bmN0aW9ucywgdHVybmluZ1xuICogdGhlbSBpbnRvIGFzeW5jaHJvbm91cyBnZW5lcmF0b3JzLiAgQWx0aG91Z2ggZ2VuZXJhdG9ycyBhcmUgb25seSBwYXJ0XG4gKiBvZiB0aGUgbmV3ZXN0IEVDTUFTY3JpcHQgNiBkcmFmdHMsIHRoaXMgY29kZSBkb2VzIG5vdCBjYXVzZSBzeW50YXhcbiAqIGVycm9ycyBpbiBvbGRlciBlbmdpbmVzLiAgVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrIGFuZCB3aWxsXG4gKiBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiAtLWhhcm1vbnktZ2VuZXJhdG9ycyBydW50aW1lIGZsYWcgZW5hYmxlZC4gIFNwaWRlck1vbmtleSBoYXMgaGFkIHRoZW1cbiAqIGZvciBsb25nZXIsIGJ1dCB1bmRlciBhbiBvbGRlciBQeXRob24taW5zcGlyZWQgZm9ybS4gIFRoaXMgZnVuY3Rpb25cbiAqIHdvcmtzIG9uIGJvdGgga2luZHMgb2YgZ2VuZXJhdG9ycy5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IGFzeW5jO1xuZnVuY3Rpb24gYXN5bmMobWFrZUdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAvLyBVbnRpbCBWOCAzLjE5IC8gQ2hyb21pdW0gMjkgaXMgcmVsZWFzZWQsIFNwaWRlck1vbmtleSBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gZW5naW5lIHRoYXQgaGFzIGEgZGVwbG95ZWQgYmFzZSBvZiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIFNNJ3MgZ2VuZXJhdG9ycyB1c2UgdGhlIFB5dGhvbi1pbnNwaXJlZCBzZW1hbnRpY3Mgb2ZcbiAgICAgICAgICAgIC8vIG91dGRhdGVkIEVTNiBkcmFmdHMuICBXZSB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgRVM2LCBidXQgd2UnZCBhbHNvXG4gICAgICAgICAgICAvLyBsaWtlIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGdlbmVyYXRvcnMgaW4gZGVwbG95ZWQgYnJvd3NlcnMsIHNvXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIHN1cHBvcnQgUHl0aG9uLXN0eWxlIGdlbmVyYXRvcnMuICBBdCBzb21lIHBvaW50IHdlIGNhbiByZW1vdmVcbiAgICAgICAgICAgIC8vIHRoaXMgYmxvY2suXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3RvcEl0ZXJhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIEVTNiBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBRKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LnZhbHVlLCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTcGlkZXJNb25rZXkgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBjYXNlIHdoZW4gU00gZG9lcyBFUzYgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShleGNlcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBtYWtlR2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJuZXh0XCIpO1xuICAgICAgICB2YXIgZXJyYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJ0aHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc3Bhd24gZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBhc3luYyB0aGF0IGltbWVkaWF0ZWx5XG4gKiBjYWxscyB0aGUgZ2VuZXJhdG9yIGFuZCBhbHNvIGVuZHMgdGhlIHByb21pc2UgY2hhaW4sIHNvIHRoYXQgYW55XG4gKiB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW5zdGVhZCBvZiBmb3J3YXJkZWQgdG8gdGhlIGVycm9yXG4gKiBoYW5kbGVyLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0J3MgZXh0cmVtZWx5IGNvbW1vbiB0byBydW5cbiAqIGdlbmVyYXRvcnMgYXQgdGhlIHRvcC1sZXZlbCB0byB3b3JrIHdpdGggbGlicmFyaWVzLlxuICovXG5RLnNwYXduID0gc3Bhd247XG5mdW5jdGlvbiBzcGF3bihtYWtlR2VuZXJhdG9yKSB7XG4gICAgUS5kb25lKFEuYXN5bmMobWFrZUdlbmVyYXRvcikoKSk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbnRlcmZhY2Ugb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuLyoqXG4gKiBUaHJvd3MgYSBSZXR1cm5WYWx1ZSBleGNlcHRpb24gdG8gc3RvcCBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGEgc3RvcC1nYXAgbWVhc3VyZSB0byBzdXBwb3J0IGdlbmVyYXRvciByZXR1cm5cbiAqIHZhbHVlcyBpbiBvbGRlciBGaXJlZm94L1NwaWRlck1vbmtleS4gIEluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBFUzZcbiAqIGdlbmVyYXRvcnMgbGlrZSBDaHJvbWl1bSAyOSwganVzdCB1c2UgXCJyZXR1cm5cIiBpbiB5b3VyIGdlbmVyYXRvclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGUgc3Vycm91bmRpbmcgZ2VuZXJhdG9yXG4gKiBAdGhyb3dzIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzYgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24qICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgcmV0dXJuIGZvbyArIGJhcjtcbiAqIH0pXG4gKiAvLyBPbGRlciBTcGlkZXJNb25rZXkgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24gKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICBRLnJldHVybihmb28gKyBiYXIpO1xuICogfSlcbiAqL1xuUVtcInJldHVyblwiXSA9IF9yZXR1cm47XG5mdW5jdGlvbiBfcmV0dXJuKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFFSZXR1cm5WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIHByb21pc2VkIGZ1bmN0aW9uIGRlY29yYXRvciBlbnN1cmVzIHRoYXQgYW55IHByb21pc2UgYXJndW1lbnRzXG4gKiBhcmUgc2V0dGxlZCBhbmQgcGFzc2VkIGFzIHZhbHVlcyAoYHRoaXNgIGlzIGFsc28gc2V0dGxlZCBhbmQgcGFzc2VkXG4gKiBhcyBhIHZhbHVlKS4gIEl0IHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gaXNcbiAqIGFsd2F5cyBhIHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBRLnByb21pc2VkKGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgICAgcmV0dXJuIGEgKyBiO1xuICogfSk7XG4gKiBhZGQoUShhKSwgUShCKSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGRlY29yYXRlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQuXG4gKi9cblEucHJvbWlzZWQgPSBwcm9taXNlZDtcbmZ1bmN0aW9uIHByb21pc2VkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNwcmVhZChbdGhpcywgYWxsKGFyZ3VtZW50cyldLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHNlbmRzIGEgbWVzc2FnZSB0byBhIHZhbHVlIGluIGEgZnV0dXJlIHR1cm5cbiAqIEBwYXJhbSBvYmplY3QqIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBvcCB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBvcGVyYXRpb24sIGUuZy4sIFwid2hlblwiLFxuICogQHBhcmFtIGFyZ3MgZnVydGhlciBhcmd1bWVudHMgdG8gYmUgZm9yd2FyZGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHJlc3VsdCB7UHJvbWlzZX0gYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAqL1xuUS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuZnVuY3Rpb24gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2gob3AsIGFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChkZWZlcnJlZC5yZXNvbHZlLCBvcCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZ2V0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICovXG5RLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIG9iamVjdCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSAgICAgbmV3IHZhbHVlIG9mIHByb3BlcnR5XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZGVsZXRlXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5kZWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIHZhbHVlICAgICBhIHZhbHVlIHRvIHBvc3QsIHR5cGljYWxseSBhbiBhcnJheSBvZlxuICogICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uIGFyZ3VtZW50cyBmb3IgcHJvbWlzZXMgdGhhdFxuICogICAgICAgICAgICAgICAgICBhcmUgdWx0aW1hdGVseSBiYWNrZWQgd2l0aCBgcmVzb2x2ZWAgdmFsdWVzLFxuICogICAgICAgICAgICAgICAgICBhcyBvcHBvc2VkIHRvIHRob3NlIGJhY2tlZCB3aXRoIFVSTHNcbiAqICAgICAgICAgICAgICAgICAgd2hlcmVpbiB0aGUgcG9zdGVkIHZhbHVlIGNhbiBiZSBhbnlcbiAqICAgICAgICAgICAgICAgICAgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cbi8vIGJvdW5kIGxvY2FsbHkgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IG90aGVyIG1ldGhvZHNcblEubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgaW52b2NhdGlvbiBhcmd1bWVudHNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5Qcm9taXNlLnByb3RvdHlwZS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIGFyZ3MgICAgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYXBwbHkgPSBmdW5jdGlvbiAob2JqZWN0LCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUVtcInRyeVwiXSA9XG5RLmZjYWxsID0gZnVuY3Rpb24gKG9iamVjdCAvKiAuLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cyldKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uLCB0cmFuc2Zvcm1pbmcgcmV0dXJuIHZhbHVlcyBpbnRvIGEgZnVsZmlsbGVkXG4gKiBwcm9taXNlIGFuZCB0aHJvd24gZXJyb3JzIGludG8gYSByZWplY3RlZCBvbmUuXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZiaW5kID0gZnVuY3Rpb24gKG9iamVjdCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gUShvYmplY3QpO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblByb21pc2UucHJvdG90eXBlLmZiaW5kID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgbmFtZXMgb2YgdGhlIG93bmVkIHByb3BlcnRpZXMgb2YgYSBwcm9taXNlZFxuICogb2JqZWN0IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUga2V5cyBvZiB0aGUgZXZlbnR1YWxseSBzZXR0bGVkIG9iamVjdFxuICovXG5RLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkuICBJZiBhbnkgb2ZcbiAqIHRoZSBwcm9taXNlcyBnZXRzIHJlamVjdGVkLCB0aGUgd2hvbGUgYXJyYXkgaXMgcmVqZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqL1xuLy8gQnkgTWFyayBNaWxsZXJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmNvbmN1cnJlbmN5JnJldj0xMzA4Nzc2NTIxI2FsbGZ1bGZpbGxlZFxuUS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb21pc2UsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNQcm9taXNlKHByb21pc2UpICYmXG4gICAgICAgICAgICAgICAgKHNuYXBzaG90ID0gcHJvbWlzZS5pbnNwZWN0KCkpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSBzbmFwc2hvdC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytwZW5kaW5nQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hlbihcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHsgaW5kZXg6IGluZGV4LCB2YWx1ZTogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2Ugb2YgYW4gYXJyYXkuIFByaW9yIHJlamVjdGVkIHByb21pc2VzIGFyZVxuICogaWdub3JlZC4gIFJlamVjdHMgb25seSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIG9yIHByb21pc2VzIGZvciB2YWx1ZXNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2UsXG4gKiBvciBhIHJlamVjdGVkIHByb21pc2UgaWYgYWxsIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqL1xuUS5hbnkgPSBhbnk7XG5cbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFEucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZlcnJlZCA9IFEuZGVmZXIoKTtcbiAgICB2YXIgcGVuZGluZ0NvdW50ID0gMDtcbiAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VzW2luZGV4XTtcblxuICAgICAgICBwZW5kaW5nQ291bnQrKztcblxuICAgICAgICB3aGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcbiAgICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZWplY3RlZChlcnIpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gKFwiUSBjYW4ndCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgZnJvbSBhbnkgcHJvbWlzZSwgYWxsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwcm9taXNlcyB3ZXJlIHJlamVjdGVkLiBMYXN0IGVycm9yIG1lc3NhZ2U6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9ncmVzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB1bmRlZmluZWQpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrLmFwcGx5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCBhcHBseSBmaW5hbGx5IGNhbGxiYWNrXCIpO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgYXQgdGhlIGVuZCBvZiBhIGNoYWluIG9mIHByb21pc2VzXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cblEuZG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kb25lKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBmb3J3YXJkIHRvIGEgZnV0dXJlIHR1cm4gc28gdGhhdCBgYHdoZW5gYFxuICAgICAgICAvLyBkb2VzIG5vdCBjYXRjaCBpdCBhbmQgdHVybiBpdCBpbnRvIGEgcmVqZWN0aW9uLlxuICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge0FueSp9IGN1c3RvbSBlcnJvciBtZXNzYWdlIG9yIEVycm9yIG9iamVjdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIChvYmplY3QsIG1zLCBlcnJvcikge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgZXJyb3IpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgZXJyb3IpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlcnJvciB8fCBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yIHx8IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgbXMgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSwgbXMpO1xuXG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGdpdmVuIHZhbHVlIChvciBwcm9taXNlZCB2YWx1ZSksIHNvbWVcbiAqIG1pbGxpc2Vjb25kcyBhZnRlciBpdCByZXNvbHZlZC4gUGFzc2VzIHJlamVjdGlvbnMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgYWZ0ZXIgbWlsbGlzZWNvbmRzXG4gKiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlLlxuICogSWYgdGhlIGdpdmVuIHByb21pc2UgcmVqZWN0cywgdGhhdCBpcyBwYXNzZWQgaW1tZWRpYXRlbHkuXG4gKi9cblEuZGVsYXkgPSBmdW5jdGlvbiAob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBhcyBhbiBhcnJheSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqICAgICAgUS5uZmFwcGx5KEZTLnJlYWRGaWxlLCBbX19maWxlbmFtZV0pXG4gKiAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiAgICAgIH0pXG4gKlxuICovXG5RLm5mYXBwbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGluZGl2aWR1YWxseSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZjYWxsKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKVxuICogLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqIH0pXG4gKlxuICovXG5RLm5mY2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBOb2RlSlMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZiaW5kKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKShcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5uZmJpbmQgPVxuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRIGNhbid0IHdyYXAgYW4gdW5kZWZpbmVkIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBRKGNhbGxiYWNrKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLmRlbm9kZWlmeS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuUS5uYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3AgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5iaW5kID0gZnVuY3Rpb24gKC8qdGhpc3AsIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEubmJpbmQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjayB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5ucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5wb3N0KG5hbWUsIGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5ucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyB8fCBbXSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrLCBmb3J3YXJkaW5nIHRoZSBnaXZlbiB2YXJpYWRpYyBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZFxuICogY2FsbGJhY2sgYXJndW1lbnQuXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0gLi4uYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2sgd2lsbFxuICogYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5RLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblEubmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUHJvbWlzZS5wcm90b3R5cGUubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUHJvbWlzZS5wcm90b3R5cGUubmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIElmIGEgZnVuY3Rpb24gd291bGQgbGlrZSB0byBzdXBwb3J0IGJvdGggTm9kZSBjb250aW51YXRpb24tcGFzc2luZy1zdHlsZSBhbmRcbiAqIHByb21pc2UtcmV0dXJuaW5nLXN0eWxlLCBpdCBjYW4gZW5kIGl0cyBpbnRlcm5hbCBwcm9taXNlIGNoYWluIHdpdGhcbiAqIGBub2RlaWZ5KG5vZGViYWNrKWAsIGZvcndhcmRpbmcgdGhlIG9wdGlvbmFsIG5vZGViYWNrIGFyZ3VtZW50LiAgSWYgdGhlIHVzZXJcbiAqIGVsZWN0cyB0byB1c2UgYSBub2RlYmFjaywgdGhlIHJlc3VsdCB3aWxsIGJlIHNlbnQgdGhlcmUuICBJZiB0aGV5IGRvIG5vdFxuICogcGFzcyBhIG5vZGViYWNrLCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IHByb21pc2UuXG4gKiBAcGFyYW0gb2JqZWN0IGEgcmVzdWx0IChvciBhIHByb21pc2UgZm9yIGEgcmVzdWx0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbm9kZWJhY2sgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyBlaXRoZXIgdGhlIHByb21pc2Ugb3Igbm90aGluZ1xuICovXG5RLm5vZGVpZnkgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShvYmplY3QsIG5vZGViYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ub2RlaWZ5KG5vZGViYWNrKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaykge1xuICAgIGlmIChub2RlYmFjaykge1xuICAgICAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuUS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUS5ub0NvbmZsaWN0IG9ubHkgd29ya3Mgd2hlbiBRIGlzIHVzZWQgYXMgYSBnbG9iYWxcIik7XG59O1xuXG4vLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxudmFyIHFFbmRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcblxucmV0dXJuIFE7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9xL3EuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IFEgZnJvbSAncSc7XG5pbXBvcnQgQWxnb2xpYSBmcm9tICdhbGdvbGlhc2VhcmNoJztcblxubG9nLnNldExldmVsKCdkZWJ1ZycpXG5cbmNvbnN0IGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuY29uc3QgU2VhcmNoID0ge1xuICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgIGxvZy50cmFjZShvcHRpb25zKTtcbiAgICBjb25zdCBBbGdvbGlhQ2xpZW50ID0gQWxnb2xpYShvcHRpb25zLmFwcElELCBvcHRpb25zLmFwaUtleSwge1xuICAgICAgcHJvdG9jb2w6ICdodHRwczonXG4gICAgfSlcbiAgICBjb25zdCBBbGdvbGlhSW5kZXggPSBBbGdvbGlhQ2xpZW50LmluaXRJbmRleChvcHRpb25zLmluZGV4KTtcblxuXG4gICAgY29uc3QgYWR2YW5jZWRTZWFyY2ggPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIEFsZ29saWFJbmRleC5jbGVhckNhY2hlKClcbiAgICAgIEFsZ29saWFJbmRleC5zZWFyY2gocGFyYW1zLCBmdW5jdGlvbihlLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgbG9nLnRyYWNlKGUpO1xuICAgICAgICAgIGQucmVqZWN0KGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hMaXN0SXRlbUNhcmRzKGNvbnRlbnQuaGl0cylcbiAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQucmVzb2x2ZShjb250ZW50LmhpdHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3Qgc2VhcmNoQ2FyZHMgPSBmdW5jdGlvbih1c2VySUQsIHNlYXJjaFRleHQsIGhpdHNQZXJQYWdlKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIHF1ZXJ5OiBzZWFyY2hUZXh0LFxuICAgICAgICBmaWx0ZXJzOiB1c2VySUQubGVuZ3RoID8gJ3VzZXJJRDogJyArIHVzZXJJRCA6ICcnLFxuICAgICAgICBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UgfHwgbnVsbFxuICAgICAgfTtcbiAgICAgIGxvZy50cmFjZShwYXJhbXMpO1xuICAgICAgYWR2YW5jZWRTZWFyY2gocGFyYW1zKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oaGl0cykge1xuICAgICAgICBsb2cudHJhY2UoaGl0cyk7XG4gICAgICAgIGQucmVzb2x2ZShoaXRzKVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBkLnJlamVjdChlKTtcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZmV0Y2hMaXN0SXRlbUNhcmRzID0gZnVuY3Rpb24oY2FyZHMpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdXG4gICAgICBjYXJkcy5mb3JFYWNoKGZ1bmN0aW9uKGNhcmQpIHtcbiAgICAgICAgY2FyZCA9IGNvcnJlY3RDYXJkKGNhcmQpXG4gICAgICAgIGNhcmQuY29udGVudC5saXN0Q2FyZHMgPSBbXVxuICAgICAgICBpZiAoIWNhcmQuY29udGVudC5saXN0SXRlbXMpIGNhcmQuY29udGVudC5saXN0SXRlbXMgPSBbXVxuICAgICAgICBjYXJkLmNvbnRlbnQubGlzdEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgY29uc3QgcCA9IFEuZGVmZXIoKVxuICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0Q2FyZChrZXkpKSAvLyBEbyB3ZSBuZWVkIHRvIG5vdGlmeSB0aGUgY2FyZCBvciBwcm92aWRlIGNhbGxiYWNrcyBldGMgaGVyZT9cbiAgICAgICAgICAvLyBwcm9taXNlcy5wdXNoKHAucHJvbWlzZSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBsb2cudHJhY2UocHJvbWlzZXMpO1xuICAgICAgUS5hbGxTZXR0bGVkKHByb21pc2VzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICBkLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGxvZy50cmFjZShlKTtcbiAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q2FyZCA9IGZ1bmN0aW9uKG9iamVjdElEKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBBbGdvbGlhSW5kZXguZ2V0T2JqZWN0KG9iamVjdElELCBmdW5jdGlvbihlLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgbG9nLnRyYWNlKGUpO1xuICAgICAgICAgIGQucmVqZWN0KGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZC5yZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGNvcnJlY3RDYXJkID0gZnVuY3Rpb24oY2FyZCkge1xuICAgICAgaWYgKCFjYXJkLmNvbnRlbnQpIGNhcmQuY29udGVudCA9IHtcbiAgICAgICAgZGVzY3JpcHRpb246IGNhcmQuZGVzY3JpcHRpb24gfHwgY2FyZC5zZW50ZW5jZSB8fCBjYXJkLnRleHQsXG4gICAgICAgIGxpc3RJdGVtczogY2FyZC5saXN0SXRlbXMgfHwgW10sXG4gICAgICB9XG4gICAgICBjYXJkLnNlbnRlbmNlID0gY2FyZC5jb250ZW50LmRlc2NyaXB0aW9uXG4gICAgICBjYXJkLmRlc2NyaXB0aW9uID0gY2FyZC5jb250ZW50LmRlc2NyaXB0aW9uXG4gICAgICAvLyBpZiAoY2FyZC5zZW50ZW5jZSkgZGVsZXRlIGNhcmQuc2VudGVuY2VcbiAgICAgIC8vIGlmIChjYXJkLnRleHQpIGRlbGV0ZSBjYXJkLnRleHRcbiAgICAgIC8vIGlmIChjYXJkLmRlc2NyaXB0aW9uKSBkZWxldGUgY2FyZC5kZXNjcmlwdGlvblxuICAgICAgaWYgKGNhcmQub2JqZWN0SUQgPT0gXCI2MjQzOTEwMDJcIikgY29uc29sZS5sb2coaGl0KTtcbiAgICAgIHJldHVybiBjYXJkXG4gICAgfVxuXG4gICAgY29uc3QgY29tcG91bmRTZWFyY2ggPSBmdW5jdGlvbih1c2VySUQsIHNlYXJjaFRleHQpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIGNvbnN0IG1heExlbmd0aCA9IDQwMDtcbiAgICAgIGNvbnN0IHNlYXJjaFRleHRBcnJheSA9IFtdO1xuICAgICAgY29uc3QgaGl0c1BlclBhZ2UgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmNlaWwoMTAgLyAoc2VhcmNoVGV4dC5sZW5ndGggLyBtYXhMZW5ndGgpKSwgMyksIDEyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VhcmNoVGV4dC5sZW5ndGg7IGkgKz0gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHNlYXJjaFRleHRBcnJheS5wdXNoKHNlYXJjaFRleHQuc3Vic3RyaW5nKGksIGkrbWF4TGVuZ3RoKSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb21pc2VzID0gc2VhcmNoVGV4dEFycmF5Lm1hcChmdW5jdGlvbih0LCBqKSB7XG4gICAgICAgIHJldHVybiBzZWFyY2hDYXJkcyh1c2VySUQsIHQsIGhpdHNQZXJQYWdlKTtcbiAgICAgIH0pO1xuICAgICAgUS5hbGxTZXR0bGVkKHByb21pc2VzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0cy5tYXAoZnVuY3Rpb24ocikge3JldHVybiByLnZhbHVlfSkpO1xuICAgICAgICByZXN1bHRzID0gcmVtb3ZlRHVwbGljYXRlcyhyZXN1bHRzLCAnb2JqZWN0SUQnKVxuICAgICAgICBsb2cudHJhY2UocmVzdWx0cyk7XG4gICAgICAgIGQucmVzb2x2ZShyZXN1bHRzKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGxvZy50cmFjZShlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbihvcmlnaW5hbEFycmF5LCBvYmpLZXkpIHtcbiAgICAgIHZhciB0cmltbWVkQXJyYXkgPSBbXSwgdmFsdWVzID0gW10sIHZhbHVlO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9yaWdpbmFsQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvcmlnaW5hbEFycmF5W2ldW29iaktleV07XG4gICAgICAgIGlmKHZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICB0cmltbWVkQXJyYXkucHVzaChvcmlnaW5hbEFycmF5W2ldKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmltbWVkQXJyYXk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tQYWdlSGl0ID0gZnVuY3Rpb24ocGFnZURhdGEsIHJlc3VsdHMpIHtcbiAgICAgIC8vTm90IHlldCBhY2NvdW50aW5nIGZvciBjYXBpdGFsc1xuICAgICAgY29uc3QgYm9yaW5nV29yZHMgPSBbXG4gICAgICAgICdmYXZvdXJpdGUnLFxuICAgICAgICAnd29ybGQnLFxuICAgICAgICAnbmFtZScsXG4gICAgICAgICd0aGlzJyxcbiAgICAgICAgJ3BsYW4nLFxuICAgICAgICAnbmVlZCcsXG4gICAgICAgICdiZXN0JyxcbiAgICAgICAgJ2xpa2UnLFxuICAgICAgICAndGhlJyxcbiAgICAgICAgJ2FyZScsXG4gICAgICAgICdpcycsXG4gICAgICAgICdteScsXG4gICAgICAgICdteScsXG4gICAgICBdXG4gICAgICBjb25zdCBoaXRzID0gW107XG4gICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0LCBpKSB7XG4gICAgICAgIGxvZy50cmFjZSgnLS0tJyk7XG4gICAgICAgIGxvZy50cmFjZShpKTtcbiAgICAgICAgdmFyIGNvdW50ID0gW107XG4gICAgICAgIHJlc3VsdC5jb250ZXh0LmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgIGlmIChwYWdlRGF0YS5wYWdlVGV4dC5pbmRleE9mKGMudmFsdWUpID4gLTFcbiAgICAgICAgICAmJiBoaXRzLmluZGV4T2YocmVzdWx0Lm9iamVjdElEKSA9PSAtMVxuICAgICAgICAgICYmIGMudmFsdWUgJiYgYy52YWx1ZS5sZW5ndGggPiAzXG4gICAgICAgICAgJiYgYm9yaW5nV29yZHMuaW5kZXhPZihjLnZhbHVlKSA9PSAtMVxuICAgICAgICAgICYmIGNvdW50LmluZGV4T2YoYy52YWx1ZSkgPT0gLTEpIHtcbiAgICAgICAgICAgIGxvZy50cmFjZShjLnZhbHVlKTtcbiAgICAgICAgICAgIGNvdW50LnB1c2goYy52YWx1ZSk7XG4gICAgICAgICAgICAoYy52YWx1ZS5tYXRjaCgvIC9nKSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY291bnQucHVzaChjLnZhbHVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBpZiAoY291bnQubGVuZ3RoID4gMikge1xuICAgICAgICAgIGxvZy50cmFjZShyZXN1bHQuc2VudGVuY2UpO1xuICAgICAgICAgIGhpdHMucHVzaChyZXN1bHQpXG4gICAgICAgIH1cbiAgICAgICAgbG9nLnRyYWNlKCctLS0nKTtcbiAgICAgIH0pXG5cbiAgICAgIC8vIHJldHVybiBoaXRzO1xuICAgICAgLy9Gb3JjZSBubyBoaXRzXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tQYWdlUmVtaW5kZXIgPSBmdW5jdGlvbih1c2VySUQsIHBhZ2VEYXRhKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBsb2cudHJhY2UocGFnZURhdGEpO1xuICAgICAgY29uc3QgdXJsUm9vdCA9IHBhZ2VEYXRhLmJhc2VVcmwucmVwbGFjZSgnLmNvbScsJycpLnJlcGxhY2UoJy5jby51aycsJycpLnJlcGxhY2UoJy5vcmcnLCcnKVxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBxdWVyeTogJycsXG4gICAgICAgIGZpbHRlcnM6ICd1c2VySUQ6ICcgKyB1c2VySUQgKyAnIEFORCAodHJpZ2dlclVybDogJyArIHVybFJvb3QgKyAnIE9SIHRyaWdnZXJVcmw6ICcgKyB1cmxSb290ICsgJy5jb20gT1IgdHJpZ2dlclVybDogJyArIHVybFJvb3QgKyAnLmNvLnVrIE9SIHRyaWdnZXJVcmw6ICcgKyB1cmxSb290ICsgJy5vcmcgT1IgdHJpZ2dlclVSTDogJyArIHVybFJvb3QgKyAnIE9SIHRyaWdnZXJVUkw6ICcgKyB1cmxSb290ICsgJy5jb20gT1IgdHJpZ2dlclVSTDogJyArIHVybFJvb3QgKyAnLmNvLnVrIE9SIHRyaWdnZXJVUkw6ICcgKyB1cmxSb290ICsgJy5vcmcpJ1xuICAgICAgfTtcbiAgICAgIGxvZy50cmFjZSgncGFyYW1zJyk7XG4gICAgICBsb2cudHJhY2UocGFyYW1zKTtcbiAgICAgIGFkdmFuY2VkU2VhcmNoKHBhcmFtcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlbWluZGVycykge1xuICAgICAgICBsb2cudHJhY2UoJ3JlbWluZGVycycpO1xuICAgICAgICBsb2cudHJhY2UocmVtaW5kZXJzKTtcbiAgICAgICAgZC5yZXNvbHZlKHJlbWluZGVycylcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZ2V0UGFnZVJlc3VsdHMgPSBmdW5jdGlvbih1c2VySUQsIHBhZ2VEYXRhLCBhbGxVc2VyQ2FyZHMpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIC8vIEdldHMgYWxsIHJlc3VsdHNcbiAgICAgIGNvbnN0IHBhZ2VSZXN1bHRzID0ge1xuICAgICAgICBoaXRzOiBbXSxcbiAgICAgICAgcmVtaW5kZXJzOiBbXSxcbiAgICAgICAgcGluZ3M6IFtdLFxuICAgICAgICBtZW1vcmllczogW10sXG4gICAgICB9O1xuICAgICAgbG9nLnRyYWNlKHVzZXJJRCwgcGFnZURhdGEpO1xuICAgICAgY29uc3QgZ21haWxCb3JpbmdQaHJhc2VzID0gW1xuICAgICAgICAnU2tpcCB0byBjb250ZW50JyxcbiAgICAgICAgJ1VzaW5nJyxcbiAgICAgICAgJ3dpdGggc2NyZWVuIHJlYWRlcnMnLFxuICAgICAgICAnU2VhcmNoJyxcbiAgICAgICAgJ01haWwnLFxuICAgICAgICAnQ09NUE9TRScsXG4gICAgICAgICdMYWJlbHMnLFxuICAgICAgICAnSW5ib3gnLFxuICAgICAgICAnU3RhcnJlZCcsXG4gICAgICAgICdTZW50IE1haWwnLFxuICAgICAgICAnRHJhZnRzJyxcbiAgICAgICAgJ01vcmUnLFxuICAgICAgICAnLS0tLS0tLS0tLSBGb3J3YXJkZWQgbWVzc2FnZSAtLS0tLS0tLS0tJyxcbiAgICAgICAgJ0Zyb206ICcsXG4gICAgICAgICdEYXRlOiAnLFxuICAgICAgICAnU3ViamVjdDogJyxcbiAgICAgICAgJ1RvOiAnLFxuICAgICAgICAnQ2xpY2sgaGVyZSB0byBSZXBseSBvciBGb3J3YXJkJyxcbiAgICAgICAgJ0dCJyxcbiAgICAgICAgJ0dCIHVzZWQnLFxuICAgICAgICAnTWFuYWdlJyxcbiAgICAgICAgJ1Byb2dyYW0gUG9saWNpZXMnLFxuICAgICAgICAnUG93ZXJlZCBieSBHb29nbGUnLFxuICAgICAgICAnTGFzdCBhY2NvdW50IGFjdGl2aXR5OicsXG4gICAgICAgICdob3VyIGFnbycsXG4gICAgICAgICdob3VycyBhZ28nLFxuICAgICAgICAnRGV0YWlscycsXG4gICAgICBdXG4gICAgICBnbWFpbEJvcmluZ1BocmFzZXMuZm9yRWFjaChmdW5jdGlvbihwaHJhc2UpIHtcbiAgICAgICAgcGFnZURhdGEucGFnZVRleHQgPSBwYWdlRGF0YS5wYWdlVGV4dC5yZXBsYWNlKHBocmFzZSwgJycpXG4gICAgICB9KVxuICAgICAgY29uc3QgYm9yaW5nV29yZHMgPSBbXG4gICAgICAgIFwiaVwiLFxuICAgICAgICBcImFcIixcbiAgICAgICAgXCJvZlwiLFxuICAgICAgICBcIm1lXCIsXG4gICAgICAgIFwibXlcIixcbiAgICAgICAgXCJpc1wiLFxuICAgICAgICBcImltXCIsXG4gICAgICAgIFwic29cIixcbiAgICAgICAgXCJhbGxcIixcbiAgICAgICAgXCJnZXRcIixcbiAgICAgICAgXCJob3dcIixcbiAgICAgICAgXCJuZXdcIixcbiAgICAgICAgXCJvdXRcIixcbiAgICAgICAgXCJ0aGVcIixcbiAgICAgICAgXCJ1c2VcIixcbiAgICAgICAgXCJiZXN0XCIsXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcIm5leHRcIixcbiAgICAgICAgXCJ0YWtlXCIsXG4gICAgICAgIFwid2hhdFwiLFxuICAgICAgICBcImltYWdlXCIsXG4gICAgICAgIFwic29tZXRoaW5nXCIsXG4gICAgICBdXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFsbFdvcmRzID0gW11cbiAgICAgICAgYWxsVXNlckNhcmRzLmZvckVhY2goZnVuY3Rpb24oY2FyZCkge1xuICAgICAgICAgIHZhciBzY29yZSA9IDBcbiAgICAgICAgICBjYXJkLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbihlbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IFN0cmluZyhlbnRpdHkudmFsdWUpXG4gICAgICAgICAgICBpZiAoYm9yaW5nV29yZHMuaW5kZXhPZih2YWwudG9Mb3dlckNhc2UoKSkgPT0gLTEgJiYgdmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodmFsKSwgXCJnaVwiKTtcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gKHBhZ2VEYXRhLnBhZ2VUZXh0Lm1hdGNoKHJlZykgfHwgW10pLmxlbmd0aCAqIHZhbC5sZW5ndGhcbiAgICAgICAgICAgICAgc2NvcmUgKz0gcG9pbnRzXG4gICAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsV29yZHMuaW5kZXhPZih2YWwpID09IC0xKSBhbGxXb3Jkcy5wdXNoKHZhbClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKHNjb3JlID4gMTAwKSB7XG4gICAgICAgICAgICBwYWdlUmVzdWx0cy5oaXRzLnB1c2goY2FyZClcbiAgICAgICAgICB9IGVsc2UgaWYgKHNjb3JlID4gMCkge1xuICAgICAgICAgICAgcGFnZVJlc3VsdHMubWVtb3JpZXMucHVzaChjYXJkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgbG9nLmRlYnVnKGFsbFdvcmRzKVxuXG4gICAgICAgIHBhZ2VSZXN1bHRzLnJlbWluZGVycyA9IGFsbFVzZXJDYXJkcy5maWx0ZXIoZnVuY3Rpb24oY2FyZCkge1xuICAgICAgICAgIGNvbnN0IHVybFJvb3QgPSBwYWdlRGF0YS5iYXNlVXJsLnJlcGxhY2UoJy5jb20nLCcnKS5yZXBsYWNlKCcuY28udWsnLCcnKS5yZXBsYWNlKCcub3JnJywnJylcbiAgICAgICAgICBsb2cuaW5mbyhjYXJkLnRyaWdnZXJVUkwpXG4gICAgICAgICAgcmV0dXJuIGNhcmQudHJpZ2dlclVSTCAmJiAoY2FyZC50cmlnZ2VyVVJMLmluZGV4T2YodXJsUm9vdCkgPiAtMSB8fCBjYXJkLnRyaWdnZXJVUkwuaW5kZXhPZih1cmxSb290KSA+IC0xKVxuICAgICAgICB9KVxuICAgICAgICBwYWdlUmVzdWx0cy5waW5ncyA9IHBhZ2VSZXN1bHRzLnJlbWluZGVycyAvLy5jb25jYXQocGFnZVJlc3VsdHMuaGl0cylcbiAgICAgICAgcGFnZVJlc3VsdHMucGluZ3MuZm9yRWFjaChmdW5jdGlvbihwaW5nKSB7IHBpbmcuaGlnaGxpZ2h0ID0gdHJ1ZSB9KVxuICAgICAgICAvLyBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHBhZ2VSZXN1bHRzLnBpbmdzLmNvbmNhdChwYWdlUmVzdWx0cy5tZW1vcmllcylcbiAgICAgICAgcGFnZVJlc3VsdHMubWVtb3JpZXMgPSByZW1vdmVEdXBsaWNhdGVzKHBhZ2VSZXN1bHRzLm1lbW9yaWVzLCAnb2JqZWN0SUQnKVxuICAgICAgICBsb2cuZGVidWcocGFnZVJlc3VsdHMpO1xuICAgICAgICBkLnJlc29sdmUocGFnZVJlc3VsdHMpXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbG9nLmVycm9yKGUpXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBvdW5kU2VhcmNoKHVzZXJJRCwgcGFnZURhdGEucGFnZVRleHQpXG4gICAgICAvLyAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAvLyAgIGxvZy50cmFjZSgxKTtcbiAgICAgIC8vICAgbG9nLnRyYWNlKHJlc3VsdHMpO1xuICAgICAgLy8gICBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHJlc3VsdHM7XG4gICAgICAvLyAgIC8vIENoZWNrcyB3aGV0aGVyIGEgcGluZyBpcyByZXF1aXJlZFxuICAgICAgLy8gICBwYWdlUmVzdWx0cy5oaXRzID0gY2hlY2tQYWdlSGl0KHBhZ2VEYXRhLCByZXN1bHRzKTtcbiAgICAgIC8vICAgbG9nLnRyYWNlKDIpO1xuICAgICAgLy8gICBsb2cudHJhY2UocGFnZVJlc3VsdHMuaGl0cyk7XG4gICAgICAvLyAgIHJldHVybiBjaGVja1BhZ2VSZW1pbmRlcih1c2VySUQsIHBhZ2VEYXRhKVxuICAgICAgLy8gfSkudGhlbihmdW5jdGlvbihyZW1pbmRlcnMpIHtcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMucmVtaW5kZXJzID0gcmVtaW5kZXJzO1xuICAgICAgLy8gICBsb2cudHJhY2UoMyk7XG4gICAgICAvLyAgIGxvZy50cmFjZShwYWdlUmVzdWx0cy5yZW1pbmRlcnMpO1xuICAgICAgLy8gICAvLyBSZXR1cm5zIHJlc3VsdHMgcGx1cyBwaW5nXG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLnBpbmdzID0gcGFnZVJlc3VsdHMucmVtaW5kZXJzLmNvbmNhdChwYWdlUmVzdWx0cy5oaXRzKVxuICAgICAgLy8gICBwYWdlUmVzdWx0cy5waW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHBpbmcpIHtcbiAgICAgIC8vICAgICBsb2cudHJhY2UocGluZy5vYmplY3RJRCk7XG4gICAgICAvLyAgICAgcGluZy5oaWdobGlnaHQgPSB0cnVlO1xuICAgICAgLy8gICB9KVxuICAgICAgLy8gICBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHBhZ2VSZXN1bHRzLnBpbmdzLmNvbmNhdChwYWdlUmVzdWx0cy5tZW1vcmllcylcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMubWVtb3JpZXMgPSByZW1vdmVEdXBsaWNhdGVzKHBhZ2VSZXN1bHRzLm1lbW9yaWVzLCAnb2JqZWN0SUQnKVxuICAgICAgLy8gICBsb2cudHJhY2UocGFnZVJlc3VsdHMpO1xuICAgICAgLy8gICBkLnJlc29sdmUocGFnZVJlc3VsdHMpXG4gICAgICAvLyB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAvLyAgIGxvZy50cmFjZShlKTtcbiAgICAgIC8vICAgZC5yZWplY3QoZSlcbiAgICAgIC8vIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgdGhpcy5hZHZhbmNlZFNlYXJjaCA9IGFkdmFuY2VkU2VhcmNoO1xuICAgIHRoaXMuc2VhcmNoQ2FyZHMgPSBzZWFyY2hDYXJkcztcbiAgICB0aGlzLmNvbXBvdW5kU2VhcmNoID0gY29tcG91bmRTZWFyY2g7XG4gICAgdGhpcy5nZXRQYWdlUmVzdWx0cyA9IGdldFBhZ2VSZXN1bHRzO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VhcmNoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL3BsdWdpbnMvZXhwbGFhaW4tc2VhcmNoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWxnb2xpYVNlYXJjaCA9IHJlcXVpcmUoJy4uLy4uL0FsZ29saWFTZWFyY2guanMnKTtcbnZhciBjcmVhdGVBbGdvbGlhc2VhcmNoID0gcmVxdWlyZSgnLi4vY3JlYXRlQWxnb2xpYXNlYXJjaC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFsZ29saWFzZWFyY2goQWxnb2xpYVNlYXJjaCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvYnVpbGRzL2FsZ29saWFzZWFyY2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IEFsZ29saWFTZWFyY2g7XG5cbnZhciBJbmRleCA9IHJlcXVpcmUoJy4vSW5kZXguanMnKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZS5qcycpO1xudmFyIGRlcHJlY2F0ZWRNZXNzYWdlID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkTWVzc2FnZS5qcycpO1xudmFyIEFsZ29saWFTZWFyY2hDb3JlID0gcmVxdWlyZSgnLi9BbGdvbGlhU2VhcmNoQ29yZS5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5mdW5jdGlvbiBBbGdvbGlhU2VhcmNoKCkge1xuICBBbGdvbGlhU2VhcmNoQ29yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0cyhBbGdvbGlhU2VhcmNoLCBBbGdvbGlhU2VhcmNoQ29yZSk7XG5cbi8qXG4gKiBEZWxldGUgYW4gaW5kZXhcbiAqXG4gKiBAcGFyYW0gaW5kZXhOYW1lIHRoZSBuYW1lIG9mIGluZGV4IHRvIGRlbGV0ZVxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSB0YXNrIElEXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRlbGV0ZUluZGV4ID0gZnVuY3Rpb24oaW5kZXhOYW1lLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4TmFtZSksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBNb3ZlIGFuIGV4aXN0aW5nIGluZGV4LlxuICogQHBhcmFtIHNyY0luZGV4TmFtZSB0aGUgbmFtZSBvZiBpbmRleCB0byBjb3B5LlxuICogQHBhcmFtIGRzdEluZGV4TmFtZSB0aGUgbmV3IGluZGV4IG5hbWUgdGhhdCB3aWxsIGNvbnRhaW5zIGEgY29weSBvZlxuICogc3JjSW5kZXhOYW1lIChkZXN0aW5hdGlvbiB3aWxsIGJlIG92ZXJyaXRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0KS5cbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgdGFzayBJRFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5tb3ZlSW5kZXggPSBmdW5jdGlvbihzcmNJbmRleE5hbWUsIGRzdEluZGV4TmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgb3BlcmF0aW9uOiAnbW92ZScsIGRlc3RpbmF0aW9uOiBkc3RJbmRleE5hbWVcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjSW5kZXhOYW1lKSArICcvb3BlcmF0aW9uJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29weSBhbiBleGlzdGluZyBpbmRleC5cbiAqIEBwYXJhbSBzcmNJbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXggdG8gY29weS5cbiAqIEBwYXJhbSBkc3RJbmRleE5hbWUgdGhlIG5ldyBpbmRleCBuYW1lIHRoYXQgd2lsbCBjb250YWlucyBhIGNvcHlcbiAqIG9mIHNyY0luZGV4TmFtZSAoZGVzdGluYXRpb24gd2lsbCBiZSBvdmVycml0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdCkuXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuY29weUluZGV4ID0gZnVuY3Rpb24oc3JjSW5kZXhOYW1lLCBkc3RJbmRleE5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBwb3N0T2JqID0ge1xuICAgIG9wZXJhdGlvbjogJ2NvcHknLCBkZXN0aW5hdGlvbjogZHN0SW5kZXhOYW1lXG4gIH07XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHNyY0luZGV4TmFtZSkgKyAnL29wZXJhdGlvbicsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBsYXN0IGxvZyBlbnRyaWVzLlxuICogQHBhcmFtIG9mZnNldCBTcGVjaWZ5IHRoZSBmaXJzdCBlbnRyeSB0byByZXRyaWV2ZSAoMC1iYXNlZCwgMCBpcyB0aGUgbW9zdCByZWNlbnQgbG9nIGVudHJ5KS5cbiAqIEBwYXJhbSBsZW5ndGggU3BlY2lmeSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyB0byByZXRyaWV2ZSBzdGFydGluZ1xuICogYXQgb2Zmc2V0LiBNYXhpbXVtIGFsbG93ZWQgdmFsdWU6IDEwMDAuXG4gKiBAcGFyYW0gdHlwZSBTcGVjaWZ5IHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIHJldHJpZXZlIHN0YXJ0aW5nXG4gKiBhdCBvZmZzZXQuIE1heGltdW0gYWxsb3dlZCB2YWx1ZTogMTAwMC5cbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgdGFzayBJRFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5nZXRMb2dzID0gZnVuY3Rpb24ob2Zmc2V0LCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKTtcbiAgdmFyIHBhcmFtcyA9IHt9O1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBnZXRMb2dzKHBhcmFtcylcbiAgICBwYXJhbXMgPSBjbG9uZShvZmZzZXQpO1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGdldExvZ3MoW2NiXSlcbiAgICBjYWxsYmFjayA9IG9mZnNldDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBnZXRMb2dzKDEsIFtjYildXG4gICAgY2FsbGJhY2sgPSBsZW5ndGg7XG4gICAgcGFyYW1zLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBnZXRMb2dzKDEsIDIsIFtjYl0pXG4gICAgcGFyYW1zLm9mZnNldCA9IG9mZnNldDtcbiAgICBwYXJhbXMubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5vZmZzZXQgPT09IHVuZGVmaW5lZCkgcGFyYW1zLm9mZnNldCA9IDA7XG4gIGlmIChwYXJhbXMubGVuZ3RoID09PSB1bmRlZmluZWQpIHBhcmFtcy5sZW5ndGggPSAxMDtcblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvbG9ncz8nICsgdGhpcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcywgJycpLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiAqIExpc3QgYWxsIGV4aXN0aW5nIGluZGV4ZXMgKHBhZ2luYXRlZClcbiAqXG4gKiBAcGFyYW0gcGFnZSBUaGUgcGFnZSB0byByZXRyaWV2ZSwgc3RhcnRpbmcgYXQgMC5cbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCBpbmRleCBsaXN0XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmxpc3RJbmRleGVzID0gZnVuY3Rpb24ocGFnZSwgY2FsbGJhY2spIHtcbiAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gIGlmIChwYWdlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHBhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhZ2U7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zID0gJz9wYWdlPScgKyBwYWdlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMnICsgcGFyYW1zLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiAqIEdldCB0aGUgaW5kZXggb2JqZWN0IGluaXRpYWxpemVkXG4gKlxuICogQHBhcmFtIGluZGV4TmFtZSB0aGUgbmFtZSBvZiBpbmRleFxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgd2l0aCBvbmUgYXJndW1lbnQgKHRoZSBJbmRleCBpbnN0YW5jZSlcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuaW5pdEluZGV4ID0gZnVuY3Rpb24oaW5kZXhOYW1lKSB7XG4gIHJldHVybiBuZXcgSW5kZXgodGhpcywgaW5kZXhOYW1lKTtcbn07XG5cbi8qXG4gKiBAZGVwcmVjYXRlZCB1c2UgY2xpZW50Lmxpc3RBcGlLZXlzXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmxpc3RVc2VyS2V5cyA9IGRlcHJlY2F0ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5saXN0QXBpS2V5cyhjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50Lmxpc3RVc2VyS2V5cygpJywgJ2NsaWVudC5saXN0QXBpS2V5cygpJykpO1xuXG4vKlxuICogTGlzdCBhbGwgZXhpc3RpbmcgYXBpIGtleXMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIEFDTHNcbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggYXBpIGtleXMgbGlzdFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5saXN0QXBpS2V5cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9rZXlzJyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gKiBAZGVwcmVjYXRlZCBzZWUgY2xpZW50LmdldEFwaUtleVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5nZXRVc2VyS2V5QUNMID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZ2V0QXBpS2V5KGtleSwgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5nZXRVc2VyS2V5QUNMKCknLCAnY2xpZW50LmdldEFwaUtleSgpJykpO1xuXG4vKlxuICogR2V0IGFuIEFQSSBrZXlcbiAqXG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIHJpZ2h0IEFQSSBrZXlcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZ2V0QXBpS2V5ID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEva2V5cy8nICsga2V5LFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiAqIEBkZXByZWNhdGVkIHNlZSBjbGllbnQuZGVsZXRlQXBpS2V5XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRlbGV0ZVVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5kZWxldGVBcGlLZXkoa2V5LCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmRlbGV0ZVVzZXJLZXkoKScsICdjbGllbnQuZGVsZXRlQXBpS2V5KCknKSk7XG5cbi8qXG4gKiBEZWxldGUgYW4gZXhpc3RpbmcgQVBJIGtleVxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBkYXRlIG9mIGRlbGV0aW9uXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRlbGV0ZUFwaUtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2tleXMvJyArIGtleSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBjbGllbnQuYWRkQXBpS2V5XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmFkZFVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hZGRBcGlLZXkoYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmFkZFVzZXJLZXkoKScsICdjbGllbnQuYWRkQXBpS2V5KCknKSk7XG5cbi8qXG4gKiBBZGQgYSBuZXcgZ2xvYmFsIEFQSSBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2xzIC0gVGhlIGxpc3Qgb2YgQUNMIGZvciB0aGlzIGtleS4gRGVmaW5lZCBieSBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXRcbiAqICAgY2FuIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICogICAgIC0gc2VhcmNoOiBhbGxvdyB0byBzZWFyY2ggKGh0dHBzIGFuZCBodHRwKVxuICogICAgIC0gYWRkT2JqZWN0OiBhbGxvd3MgdG8gYWRkL3VwZGF0ZSBhbiBvYmplY3QgaW4gdGhlIGluZGV4IChodHRwcyBvbmx5KVxuICogICAgIC0gZGVsZXRlT2JqZWN0IDogYWxsb3dzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBvYmplY3QgKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBkZWxldGVJbmRleCA6IGFsbG93cyB0byBkZWxldGUgaW5kZXggY29udGVudCAoaHR0cHMgb25seSlcbiAqICAgICAtIHNldHRpbmdzIDogYWxsb3dzIHRvIGdldCBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAqICAgICAtIGVkaXRTZXR0aW5ncyA6IGFsbG93cyB0byBjaGFuZ2UgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25uYWwgcGFyYW1ldGVycyB0byBzZXQgZm9yIHRoZSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsaWRpdHkgLSBOdW1iZXIgb2Ygc2Vjb25kcyBhZnRlciB3aGljaCB0aGUga2V5IHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkICgwIG1lYW5zIG5vIHRpbWUgbGltaXQgZm9yIHRoaXMga2V5KVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyIC0gTnVtYmVyIG9mIEFQSSBjYWxscyBhbGxvd2VkIGZyb20gYW4gSVAgYWRkcmVzcyBwZXIgaG91clxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnkgLSBOdW1iZXIgb2YgaGl0cyB0aGlzIEFQSSBrZXkgY2FuIHJldHJpZXZlIGluIG9uZSBjYWxsXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuaW5kZXhlcyAtIEFsbG93ZWQgdGFyZ2V0ZWQgaW5kZXhlcyBmb3IgdGhpcyBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIGZvciB5b3VyIGtleVxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJlZmVyZXJzIC0gQSBsaXN0IG9mIGF1dGhvcml6ZWQgcmVmZXJlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucXVlcnlQYXJhbWV0ZXJzIC0gRm9yY2UgdGhlIGtleSB0byB1c2Ugc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBhZGRlZCBBUEkga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiAqIEBleGFtcGxlXG4gKiBjbGllbnQuYWRkVXNlcktleShbJ3NlYXJjaCddLCB7XG4gKiAgIHZhbGlkaXR5OiAzMDAsXG4gKiAgIG1heFF1ZXJpZXNQZXJJUFBlckhvdXI6IDIwMDAsXG4gKiAgIG1heEhpdHNQZXJRdWVyeTogMyxcbiAqICAgaW5kZXhlczogWydmcnVpdHMnXSxcbiAqICAgZGVzY3JpcHRpb246ICdFYXQgdGhyZWUgZnJ1aXRzJyxcbiAqICAgcmVmZXJlcnM6IFsnKi5hbGdvbGlhLmNvbSddLFxuICogICBxdWVyeVBhcmFtZXRlcnM6IHtcbiAqICAgICB0YWdGaWx0ZXJzOiBbJ3B1YmxpYyddLFxuICogICB9XG4gKiB9KVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0FkZEtleXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmFkZEFwaUtleSA9IGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LmFkZEFwaUtleShhcnJheU9mQWNsc1ssIHBhcmFtcywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KGFjbHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgYWNsOiBhY2xzXG4gIH07XG5cbiAgaWYgKHBhcmFtcykge1xuICAgIHBvc3RPYmoudmFsaWRpdHkgPSBwYXJhbXMudmFsaWRpdHk7XG4gICAgcG9zdE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgcG9zdE9iai5tYXhIaXRzUGVyUXVlcnkgPSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5O1xuICAgIHBvc3RPYmouaW5kZXhlcyA9IHBhcmFtcy5pbmRleGVzO1xuICAgIHBvc3RPYmouZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb247XG5cbiAgICBpZiAocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgcG9zdE9iai5xdWVyeVBhcmFtZXRlcnMgPSB0aGlzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycywgJycpO1xuICAgIH1cblxuICAgIHBvc3RPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2tleXMnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGNsaWVudC5hZGRBcGlLZXkoKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYWRkQXBpS2V5KGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5KCknLCAnY2xpZW50LmFkZEFwaUtleSgpJykpO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgY2xpZW50LnVwZGF0ZUFwaUtleSgpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLnVwZGF0ZVVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnVwZGF0ZUFwaUtleShrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC51cGRhdGVVc2VyS2V5KCknLCAnY2xpZW50LnVwZGF0ZUFwaUtleSgpJykpO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBBUEkga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjbHMgLSBUaGUgbGlzdCBvZiBBQ0wgZm9yIHRoaXMga2V5LiBEZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdFxuICogICBjYW4gY29udGFpbnMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKiAgICAgLSBzZWFyY2g6IGFsbG93IHRvIHNlYXJjaCAoaHR0cHMgYW5kIGh0dHApXG4gKiAgICAgLSBhZGRPYmplY3Q6IGFsbG93cyB0byBhZGQvdXBkYXRlIGFuIG9iamVjdCBpbiB0aGUgaW5kZXggKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBkZWxldGVPYmplY3QgOiBhbGxvd3MgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIG9iamVjdCAoaHR0cHMgb25seSlcbiAqICAgICAtIGRlbGV0ZUluZGV4IDogYWxsb3dzIHRvIGRlbGV0ZSBpbmRleCBjb250ZW50IChodHRwcyBvbmx5KVxuICogICAgIC0gc2V0dGluZ3MgOiBhbGxvd3MgdG8gZ2V0IGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICogICAgIC0gZWRpdFNldHRpbmdzIDogYWxsb3dzIHRvIGNoYW5nZSBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbm5hbCBwYXJhbWV0ZXJzIHRvIHNldCBmb3IgdGhlIGtleVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWxpZGl0eSAtIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBrZXkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgKDAgbWVhbnMgbm8gdGltZSBsaW1pdCBmb3IgdGhpcyBrZXkpXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5pbmRleGVzIC0gQWxsb3dlZCB0YXJnZXRlZCBpbmRleGVzIGZvciB0aGlzIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucmVmZXJlcnMgLSBBIGxpc3Qgb2YgYXV0aG9yaXplZCByZWZlcmVyc1xuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIG1vZGlmaWVkIEFQSSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICogQGV4YW1wbGVcbiAqIGNsaWVudC51cGRhdGVBcGlLZXkoJ0FQSUtFWScsIFsnc2VhcmNoJ10sIHtcbiAqICAgdmFsaWRpdHk6IDMwMCxcbiAqICAgbWF4UXVlcmllc1BlcklQUGVySG91cjogMjAwMCxcbiAqICAgbWF4SGl0c1BlclF1ZXJ5OiAzLFxuICogICBpbmRleGVzOiBbJ2ZydWl0cyddLFxuICogICBkZXNjcmlwdGlvbjogJ0VhdCB0aHJlZSBmcnVpdHMnLFxuICogICByZWZlcmVyczogWycqLmFsZ29saWEuY29tJ10sXG4gKiAgIHF1ZXJ5UGFyYW1ldGVyczoge1xuICogICAgIHRhZ0ZpbHRlcnM6IFsncHVibGljJ10sXG4gKiAgIH1cbiAqIH0pXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjVXBkYXRlSW5kZXhLZXl8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS51cGRhdGVBcGlLZXkgPSBmdW5jdGlvbihrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LnVwZGF0ZUFwaUtleShrZXksIGFycmF5T2ZBY2xzWywgcGFyYW1zLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkoYWNscykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IG51bGw7XG4gIH1cblxuICB2YXIgcHV0T2JqID0ge1xuICAgIGFjbDogYWNsc1xuICB9O1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBwdXRPYmoudmFsaWRpdHkgPSBwYXJhbXMudmFsaWRpdHk7XG4gICAgcHV0T2JqLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgPSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91cjtcbiAgICBwdXRPYmoubWF4SGl0c1BlclF1ZXJ5ID0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeTtcbiAgICBwdXRPYmouaW5kZXhlcyA9IHBhcmFtcy5pbmRleGVzO1xuICAgIHB1dE9iai5kZXNjcmlwdGlvbiA9IHBhcmFtcy5kZXNjcmlwdGlvbjtcblxuICAgIGlmIChwYXJhbXMucXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICBwdXRPYmoucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMsICcnKTtcbiAgICB9XG5cbiAgICBwdXRPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEva2V5cy8nICsga2V5LFxuICAgIGJvZHk6IHB1dE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYmF0Y2ggb2Ygc2VhcmNoIHF1ZXJpZXNcbiAqIEBkZXByZWNhdGVkIHVzZSBjbGllbnQuc2VhcmNoKClcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuc3RhcnRRdWVyaWVzQmF0Y2ggPSBkZXByZWNhdGUoZnVuY3Rpb24gc3RhcnRRdWVyaWVzQmF0Y2hEZXByZWNhdGVkKCkge1xuICB0aGlzLl9iYXRjaCA9IFtdO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5zdGFydFF1ZXJpZXNCYXRjaCgpJywgJ2NsaWVudC5zZWFyY2goKScpKTtcblxuLyoqXG4gKiBBZGQgYSBzZWFyY2ggcXVlcnkgaW4gdGhlIGJhdGNoXG4gKiBAZGVwcmVjYXRlZCB1c2UgY2xpZW50LnNlYXJjaCgpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmFkZFF1ZXJ5SW5CYXRjaCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBhZGRRdWVyeUluQmF0Y2hEZXByZWNhdGVkKGluZGV4TmFtZSwgcXVlcnksIGFyZ3MpIHtcbiAgdGhpcy5fYmF0Y2gucHVzaCh7XG4gICAgaW5kZXhOYW1lOiBpbmRleE5hbWUsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHBhcmFtczogYXJnc1xuICB9KTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuYWRkUXVlcnlJbkJhdGNoKCknLCAnY2xpZW50LnNlYXJjaCgpJykpO1xuXG4vKipcbiAqIExhdW5jaCB0aGUgYmF0Y2ggb2YgcXVlcmllcyB1c2luZyBYTUxIdHRwUmVxdWVzdC5cbiAqIEBkZXByZWNhdGVkIHVzZSBjbGllbnQuc2VhcmNoKClcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuc2VuZFF1ZXJpZXNCYXRjaCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBzZW5kUXVlcmllc0JhdGNoRGVwcmVjYXRlZChjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5zZWFyY2godGhpcy5fYmF0Y2gsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuc2VuZFF1ZXJpZXNCYXRjaCgpJywgJ2NsaWVudC5zZWFyY2goKScpKTtcblxuLyoqXG4gKiBQZXJmb3JtIHdyaXRlIG9wZXJhdGlvbnMgYWNjcm9zcyBtdWx0aXBsZSBpbmRleGVzLlxuICpcbiAqIFRvIHJlZHVjZSB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgb24gbmV0d29yayByb3VuZCB0cmlwcyxcbiAqIHlvdSBjYW4gY3JlYXRlLCB1cGRhdGUsIG9yIGRlbGV0ZSBzZXZlcmFsIG9iamVjdHMgaW4gb25lIGNhbGwsXG4gKiB1c2luZyB0aGUgYmF0Y2ggZW5kcG9pbnQgKGFsbCBvcGVyYXRpb25zIGFyZSBkb25lIGluIHRoZSBnaXZlbiBvcmRlcikuXG4gKlxuICogQXZhaWxhYmxlIGFjdGlvbnM6XG4gKiAgIC0gYWRkT2JqZWN0XG4gKiAgIC0gdXBkYXRlT2JqZWN0XG4gKiAgIC0gcGFydGlhbFVwZGF0ZU9iamVjdFxuICogICAtIHBhcnRpYWxVcGRhdGVPYmplY3ROb0NyZWF0ZVxuICogICAtIGRlbGV0ZU9iamVjdFxuICpcbiAqIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNJbmRleGVzXG4gKiBAcGFyYW0gIHtPYmplY3RbXX0gb3BlcmF0aW9ucyBBbiBhcnJheSBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICogQGV4YW1wbGVcbiAqIGNsaWVudC5iYXRjaChbe1xuICogICBhY3Rpb246ICdhZGRPYmplY3QnLFxuICogICBpbmRleE5hbWU6ICdjbGllbnRzJyxcbiAqICAgYm9keToge1xuICogICAgIG5hbWU6ICdCaWxsJ1xuICogICB9XG4gKiB9LCB7XG4gKiAgIGFjdGlvbjogJ3VkcGF0ZU9iamVjdCcsXG4gKiAgIGluZGV4TmFtZTogJ2ZydWl0cycsXG4gKiAgIGJvZHk6IHtcbiAqICAgICBvYmplY3RJRDogJzI5MTM4JyxcbiAqICAgICBuYW1lOiAnYmFuYW5hJ1xuICogICB9XG4gKiB9XSwgY2IpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24ob3BlcmF0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LmJhdGNoKG9wZXJhdGlvbnNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob3BlcmF0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLyovYmF0Y2gnLFxuICAgIGJvZHk6IHtcbiAgICAgIHJlcXVlc3RzOiBvcGVyYXRpb25zXG4gICAgfSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vLyBlbnZpcm9ubWVudCBzcGVjaWZpYyBtZXRob2RzXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kZXN0cm95ID0gbm90SW1wbGVtZW50ZWQ7XG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5lbmFibGVSYXRlTGltaXRGb3J3YXJkID0gbm90SW1wbGVtZW50ZWQ7XG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kaXNhYmxlUmF0ZUxpbWl0Rm9yd2FyZCA9IG5vdEltcGxlbWVudGVkO1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUudXNlU2VjdXJlZEFQSUtleSA9IG5vdEltcGxlbWVudGVkO1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZGlzYWJsZVNlY3VyZWRBUElLZXkgPSBub3RJbXBsZW1lbnRlZDtcbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmdlbmVyYXRlU2VjdXJlZEFwaUtleSA9IG5vdEltcGxlbWVudGVkO1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcbiAgdmFyIG1lc3NhZ2UgPSAnTm90IGltcGxlbWVudGVkIGluIHRoaXMgZW52aXJvbm1lbnQuXFxuJyArXG4gICAgJ0lmIHlvdSBmZWVsIHRoaXMgaXMgYSBtaXN0YWtlLCB3cml0ZSB0byBzdXBwb3J0QGFsZ29saWEuY29tJztcblxuICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihtZXNzYWdlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaC5qcyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgSW5kZXhDb3JlID0gcmVxdWlyZSgnLi9JbmRleENvcmUuanMnKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZS5qcycpO1xudmFyIGRlcHJlY2F0ZWRNZXNzYWdlID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkTWVzc2FnZS5qcycpO1xudmFyIGV4aXRQcm9taXNlID0gcmVxdWlyZSgnLi9leGl0UHJvbWlzZS5qcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbnZhciBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMgPSBkZXByZWNhdGUoXG4gIGZ1bmN0aW9uKCkge30sXG4gIGRlcHJlY2F0ZWRNZXNzYWdlKCdmb3J3YXJkVG9TbGF2ZXMnLCAnZm9yd2FyZFRvUmVwbGljYXMnKVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleDtcblxuZnVuY3Rpb24gSW5kZXgoKSB7XG4gIEluZGV4Q29yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0cyhJbmRleCwgSW5kZXhDb3JlKTtcblxuLypcbiogQWRkIGFuIG9iamVjdCBpbiB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBjb250ZW50IGNvbnRhaW5zIHRoZSBqYXZhc2NyaXB0IG9iamVjdCB0byBhZGQgaW5zaWRlIHRoZSBpbmRleFxuKiBAcGFyYW0gb2JqZWN0SUQgKG9wdGlvbmFsKSBhbiBvYmplY3RJRCB5b3Ugd2FudCB0byBhdHRyaWJ1dGUgdG8gdGhpcyBvYmplY3RcbiogKGlmIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdCB0aGUgb2xkIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0ZSlcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyAzIGVsZW1lbnRzOiBjcmVhdGVBdCwgdGFza0lkIGFuZCBvYmplY3RJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5hZGRPYmplY3QgPSBmdW5jdGlvbihjb250ZW50LCBvYmplY3RJRCwgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2Ygb2JqZWN0SUQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9iamVjdElEO1xuICAgIG9iamVjdElEID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6IG9iamVjdElEICE9PSB1bmRlZmluZWQgP1xuICAgICdQVVQnIDogLy8gdXBkYXRlIG9yIGNyZWF0ZVxuICAgICdQT1NUJywgLy8gY3JlYXRlIChBUEkgZ2VuZXJhdGVzIGFuIG9iamVjdElEKVxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgLy8gY3JlYXRlXG4gICAgKG9iamVjdElEICE9PSB1bmRlZmluZWQgPyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpIDogJycpLCAvLyB1cGRhdGUgb3IgY3JlYXRlXG4gICAgYm9keTogY29udGVudCxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBBZGQgc2V2ZXJhbCBvYmplY3RzXG4qXG4qIEBwYXJhbSBvYmplY3RzIGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdHMgdG8gYWRkXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgdXBkYXRlQXQgYW5kIHRhc2tJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5hZGRPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguYWRkT2JqZWN0cyhhcnJheU9mT2JqZWN0c1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvYmplY3RzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgcG9zdE9iaiA9IHtcbiAgICByZXF1ZXN0czogW11cbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICBhY3Rpb246ICdhZGRPYmplY3QnLFxuICAgICAgYm9keTogb2JqZWN0c1tpXVxuICAgIH07XG4gICAgcG9zdE9iai5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICB9XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIFVwZGF0ZSBwYXJ0aWFsbHkgYW4gb2JqZWN0IChvbmx5IHVwZGF0ZSBhdHRyaWJ1dGVzIHBhc3NlZCBpbiBhcmd1bWVudClcbipcbiogQHBhcmFtIHBhcnRpYWxPYmplY3QgY29udGFpbnMgdGhlIGphdmFzY3JpcHQgYXR0cmlidXRlcyB0byBvdmVycmlkZSwgdGhlXG4qICBvYmplY3QgbXVzdCBjb250YWlucyBhbiBvYmplY3RJRCBhdHRyaWJ1dGVcbiogQHBhcmFtIGNyZWF0ZUlmTm90RXhpc3RzIChvcHRpb25hbCkgaWYgZmFsc2UsIGF2b2lkIGFuIGF1dG9tYXRpYyBjcmVhdGlvbiBvZiB0aGUgb2JqZWN0XG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiovXG5JbmRleC5wcm90b3R5cGUucGFydGlhbFVwZGF0ZU9iamVjdCA9IGZ1bmN0aW9uKHBhcnRpYWxPYmplY3QsIGNyZWF0ZUlmTm90RXhpc3RzLCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgY3JlYXRlSWZOb3RFeGlzdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUlmTm90RXhpc3RzO1xuICAgIGNyZWF0ZUlmTm90RXhpc3RzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHVybCA9ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJ0aWFsT2JqZWN0Lm9iamVjdElEKSArICcvcGFydGlhbCc7XG4gIGlmIChjcmVhdGVJZk5vdEV4aXN0cyA9PT0gZmFsc2UpIHtcbiAgICB1cmwgKz0gJz9jcmVhdGVJZk5vdEV4aXN0cz1mYWxzZSc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdXJsLFxuICAgIGJvZHk6IHBhcnRpYWxPYmplY3QsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogUGFydGlhbGx5IE92ZXJyaWRlIHRoZSBjb250ZW50IG9mIHNldmVyYWwgb2JqZWN0c1xuKlxuKiBAcGFyYW0gb2JqZWN0cyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIHVwZGF0ZSAoZWFjaCBvYmplY3QgbXVzdCBjb250YWlucyBhIG9iamVjdElEIGF0dHJpYnV0ZSlcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4qL1xuSW5kZXgucHJvdG90eXBlLnBhcnRpYWxVcGRhdGVPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0cywgY3JlYXRlSWZOb3RFeGlzdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBjcmVhdGVJZk5vdEV4aXN0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gY3JlYXRlSWZOb3RFeGlzdHM7XG4gICAgY3JlYXRlSWZOb3RFeGlzdHMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXgucGFydGlhbFVwZGF0ZU9iamVjdHMoYXJyYXlPZk9iamVjdHNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob2JqZWN0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IFtdXG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgYWN0aW9uOiBjcmVhdGVJZk5vdEV4aXN0cyA9PT0gdHJ1ZSA/ICdwYXJ0aWFsVXBkYXRlT2JqZWN0JyA6ICdwYXJ0aWFsVXBkYXRlT2JqZWN0Tm9DcmVhdGUnLFxuICAgICAgb2JqZWN0SUQ6IG9iamVjdHNbaV0ub2JqZWN0SUQsXG4gICAgICBib2R5OiBvYmplY3RzW2ldXG4gICAgfTtcbiAgICBwb3N0T2JqLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvYmF0Y2gnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogT3ZlcnJpZGUgdGhlIGNvbnRlbnQgb2Ygb2JqZWN0XG4qXG4qIEBwYXJhbSBvYmplY3QgY29udGFpbnMgdGhlIGphdmFzY3JpcHQgb2JqZWN0IHRvIHNhdmUsIHRoZSBvYmplY3QgbXVzdCBjb250YWlucyBhbiBvYmplY3RJRCBhdHRyaWJ1dGVcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4qL1xuSW5kZXgucHJvdG90eXBlLnNhdmVPYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3Qub2JqZWN0SUQpLFxuICAgIGJvZHk6IG9iamVjdCxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59XG5cbi8qXG4qIE92ZXJyaWRlIHRoZSBjb250ZW50IG9mIHNldmVyYWwgb2JqZWN0c1xuKlxuKiBAcGFyYW0gb2JqZWN0cyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIHVwZGF0ZSAoZWFjaCBvYmplY3QgbXVzdCBjb250YWlucyBhIG9iamVjdElEIGF0dHJpYnV0ZSlcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4qL1xuSW5kZXgucHJvdG90eXBlLnNhdmVPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguc2F2ZU9iamVjdHMoYXJyYXlPZk9iamVjdHNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob2JqZWN0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IFtdXG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgYWN0aW9uOiAndXBkYXRlT2JqZWN0JyxcbiAgICAgIG9iamVjdElEOiBvYmplY3RzW2ldLm9iamVjdElELFxuICAgICAgYm9keTogb2JqZWN0c1tpXVxuICAgIH07XG4gICAgcG9zdE9iai5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICB9XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIERlbGV0ZSBhbiBvYmplY3QgZnJvbSB0aGUgaW5kZXhcbipcbiogQHBhcmFtIG9iamVjdElEIHRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBvYmplY3QgdG8gZGVsZXRlXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0SUQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iamVjdElEICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb2JqZWN0SUQgIT09ICdudW1iZXInKSB7XG4gICAgdmFyIGVyciA9IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdDYW5ub3QgZGVsZXRlIGFuIG9iamVjdCB3aXRob3V0IGFuIG9iamVjdElEJyk7XG4gICAgY2FsbGJhY2sgPSBvYmplY3RJRDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcy5fcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogRGVsZXRlIHNldmVyYWwgb2JqZWN0cyBmcm9tIGFuIGluZGV4XG4qXG4qIEBwYXJhbSBvYmplY3RJRHMgY29udGFpbnMgYW4gYXJyYXkgb2Ygb2JqZWN0SUQgdG8gZGVsZXRlXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlT2JqZWN0cyA9IGZ1bmN0aW9uKG9iamVjdElEcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguZGVsZXRlT2JqZWN0cyhhcnJheU9mT2JqZWN0SURzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9iamVjdElEcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IG1hcChvYmplY3RJRHMsIGZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KG9iamVjdElEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb246ICdkZWxldGVPYmplY3QnLFxuICAgICAgICBvYmplY3RJRDogb2JqZWN0SUQsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBvYmplY3RJRDogb2JqZWN0SURcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICB9O1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIERlbGV0ZSBhbGwgb2JqZWN0cyBtYXRjaGluZyBhIHF1ZXJ5XG4qXG4qIEBwYXJhbSBxdWVyeSB0aGUgcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSBwYXJhbXMgdGhlIG9wdGlvbmFsIHF1ZXJ5IHBhcmFtZXRlcnNcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnRcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlQnlRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKTtcbiAgdmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwLmpzJyk7XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIGNsaWVudCA9IGluZGV4T2JqLmFzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMgPSBjbG9uZShwYXJhbXMpO1xuICB9XG5cbiAgcGFyYW1zLmF0dHJpYnV0ZXNUb1JldHJpZXZlID0gJ29iamVjdElEJztcbiAgcGFyYW1zLmhpdHNQZXJQYWdlID0gMTAwMDtcbiAgcGFyYW1zLmRpc3RpbmN0ID0gZmFsc2U7XG5cbiAgLy8gd2hlbiBkZWxldGluZywgd2Ugc2hvdWxkIG5ldmVyIHVzZSBjYWNoZSB0byBnZXQgdGhlXG4gIC8vIHNlYXJjaCByZXN1bHRzXG4gIHRoaXMuY2xlYXJDYWNoZSgpO1xuXG4gIC8vIHRoZXJlJ3MgYSBwcm9ibGVtIGluIGhvdyB3ZSB1c2UgdGhlIHByb21pc2UgY2hhaW4sXG4gIC8vIHNlZSBob3cgd2FpdFRhc2sgaXMgZG9uZVxuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgLnNlYXJjaChxdWVyeSwgcGFyYW1zKVxuICAudGhlbihzdG9wT3JEZWxldGUpO1xuXG4gIGZ1bmN0aW9uIHN0b3BPckRlbGV0ZShzZWFyY2hDb250ZW50KSB7XG4gICAgLy8gc3RvcCBoZXJlXG4gICAgaWYgKHNlYXJjaENvbnRlbnQubmJIaXRzID09PSAwKSB7XG4gICAgICAvLyByZXR1cm4gaW5kZXhPYmouYXMuX3JlcXVlc3QucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIHNlYXJjaENvbnRlbnQ7XG4gICAgfVxuXG4gICAgLy8gY29udGludWUgYW5kIGRvIGEgcmVjdXJzaXZlIGNhbGxcbiAgICB2YXIgb2JqZWN0SURzID0gbWFwKHNlYXJjaENvbnRlbnQuaGl0cywgZnVuY3Rpb24gZ2V0T2JqZWN0SUQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0Lm9iamVjdElEO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluZGV4T2JqXG4gICAgLmRlbGV0ZU9iamVjdHMob2JqZWN0SURzKVxuICAgIC50aGVuKHdhaXRUYXNrKVxuICAgIC50aGVuKGRvRGVsZXRlQnlRdWVyeSk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0VGFzayhkZWxldGVPYmplY3RzQ29udGVudCkge1xuICAgIHJldHVybiBpbmRleE9iai53YWl0VGFzayhkZWxldGVPYmplY3RzQ29udGVudC50YXNrSUQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9EZWxldGVCeVF1ZXJ5KCkge1xuICAgIHJldHVybiBpbmRleE9iai5kZWxldGVCeVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpO1xuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJvbWlzZS50aGVuKHN1Y2Nlc3MsIGZhaWx1cmUpO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWx1cmUoZXJyKSB7XG4gICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSwgY2xpZW50Ll9zZXRUaW1lb3V0IHx8IHNldFRpbWVvdXQpO1xuICB9XG59O1xuXG4vKlxuKiBCcm93c2UgYWxsIGNvbnRlbnQgZnJvbSBhbiBpbmRleCB1c2luZyBldmVudHMuIEJhc2ljYWxseSB0aGlzIHdpbGwgZG9cbiogLmJyb3dzZSgpIC0+IC5icm93c2VGcm9tIC0+IC5icm93c2VGcm9tIC0+IC4uIHVudGlsIGFsbCB0aGUgcmVzdWx0cyBhcmUgcmV0dXJuZWRcbipcbiogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGZ1bGwgdGV4dCBxdWVyeVxuKiBAcGFyYW0ge09iamVjdH0gW3F1ZXJ5UGFyYW1ldGVyc10gLSBBbnkgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlclxuKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9XG4qIEBleGFtcGxlXG4qIHZhciBicm93c2VyID0gaW5kZXguYnJvd3NlQWxsKCdjb29sIHNvbmdzJywge1xuKiAgIHRhZ0ZpbHRlcnM6ICdwdWJsaWMsY29tbWVudHMnLFxuKiAgIGhpdHNQZXJQYWdlOiA1MDBcbiogfSk7XG4qXG4qIGJyb3dzZXIub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uIHJlc3VsdENhbGxiYWNrKGNvbnRlbnQpIHtcbiogICBjb25zb2xlLmxvZyhjb250ZW50LmhpdHMpO1xuKiB9KTtcbipcbiogLy8gaWYgYW55IGVycm9yIG9jY3VycywgeW91IGdldCBpdFxuKiBicm93c2VyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuKiAgIHRocm93IGVycjtcbiogfSk7XG4qXG4qIC8vIHdoZW4geW91IGhhdmUgYnJvd3NlZCB0aGUgd2hvbGUgaW5kZXgsIHlvdSBnZXQgdGhpcyBldmVudFxuKiBicm93c2VyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiogICBjb25zb2xlLmxvZygnZmluaXNoZWQnKTtcbiogfSk7XG4qXG4qIC8vIGF0IGFueSBwb2ludCBpZiB5b3Ugd2FudCB0byBzdG9wIHRoZSBicm93c2luZyBwcm9jZXNzLCB5b3UgY2FuIHN0b3AgaXQgbWFudWFsbHlcbiogLy8gb3RoZXJ3aXNlIGl0IHdpbGwgZ28gb24gYW5kIG9uXG4qIGJyb3dzZXIuc3RvcCgpO1xuKlxuKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleC5wcm90b3R5cGUuYnJvd3NlQWxsID0gZnVuY3Rpb24ocXVlcnksIHF1ZXJ5UGFyYW1ldGVycykge1xuICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHF1ZXJ5O1xuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIG1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZS5qcycpO1xuXG4gIHZhciBJbmRleEJyb3dzZXIgPSByZXF1aXJlKCcuL0luZGV4QnJvd3NlcicpO1xuXG4gIHZhciBicm93c2VyID0gbmV3IEluZGV4QnJvd3NlcigpO1xuICB2YXIgY2xpZW50ID0gdGhpcy5hcztcbiAgdmFyIGluZGV4ID0gdGhpcztcbiAgdmFyIHBhcmFtcyA9IGNsaWVudC5fZ2V0U2VhcmNoUGFyYW1zKFxuICAgIG1lcmdlKHt9LCBxdWVyeVBhcmFtZXRlcnMgfHwge30sIHtcbiAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgIH0pLCAnJ1xuICApO1xuXG4gIC8vIHN0YXJ0IGJyb3dzaW5nXG4gIGJyb3dzZUxvb3AoKTtcblxuICBmdW5jdGlvbiBicm93c2VMb29wKGN1cnNvcikge1xuICAgIGlmIChicm93c2VyLl9zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJvZHkgPSB7XG4gICAgICAgIGN1cnNvcjogY3Vyc29yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0ge1xuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGllbnQuX2pzb25SZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4LmluZGV4TmFtZSkgKyAnL2Jyb3dzZScsXG4gICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGNhbGxiYWNrOiBicm93c2VDYWxsYmFja1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnJvd3NlQ2FsbGJhY2soZXJyLCBjb250ZW50KSB7XG4gICAgaWYgKGJyb3dzZXIuX3N0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBicm93c2VyLl9lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyb3dzZXIuX3Jlc3VsdChjb250ZW50KTtcblxuICAgIC8vIG5vIGN1cnNvciBtZWFucyB3ZSBhcmUgZmluaXNoZWQgYnJvd3NpbmdcbiAgICBpZiAoY29udGVudC5jdXJzb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnJvd3Nlci5fZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJvd3NlTG9vcChjb250ZW50LmN1cnNvcik7XG4gIH1cblxuICByZXR1cm4gYnJvd3Nlcjtcbn07XG5cbi8qXG4qIEdldCBhIFR5cGVhaGVhZC5qcyBhZGFwdGVyXG4qIEBwYXJhbSBzZWFyY2hQYXJhbXMgY29udGFpbnMgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycyAoc2VlIHNlYXJjaCBmb3IgZGV0YWlscylcbiovXG5JbmRleC5wcm90b3R5cGUudHRBZGFwdGVyID0gZGVwcmVjYXRlKGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiB0dEFkYXB0ZXIocXVlcnksIHN5bmNDYiwgYXN5bmNDYikge1xuICAgIHZhciBjYjtcblxuICAgIGlmICh0eXBlb2YgYXN5bmNDYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gdHlwZWFoZWFkIDAuMTFcbiAgICAgIGNiID0gYXN5bmNDYjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJlIHR5cGVhaGVhZCAwLjExXG4gICAgICBjYiA9IHN5bmNDYjtcbiAgICB9XG5cbiAgICBzZWxmLnNlYXJjaChxdWVyeSwgcGFyYW1zLCBmdW5jdGlvbiBzZWFyY2hEb25lKGVyciwgY29udGVudCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNiKGNvbnRlbnQuaGl0cyk7XG4gICAgfSk7XG4gIH07XG59LFxuJ3R0QWRhcHRlciBpcyBub3QgbmVjZXNzYXJ5IGFueW1vcmUgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB2ZXJzaW9uLFxcbicgK1xuJ2hhdmUgYSBsb29rIGF0IGF1dG9jb21wbGV0ZS5qcyAoaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYXV0b2NvbXBsZXRlLmpzKScpO1xuXG4vKlxuKiBXYWl0IHRoZSBwdWJsaWNhdGlvbiBvZiBhIHRhc2sgb24gdGhlIHNlcnZlci5cbiogQWxsIHNlcnZlciB0YXNrIGFyZSBhc3luY2hyb25vdXMgYW5kIHlvdSBjYW4gY2hlY2sgd2l0aCB0aGlzIG1ldGhvZCB0aGF0IHRoZSB0YXNrIGlzIHB1Ymxpc2hlZC5cbipcbiogQHBhcmFtIHRhc2tJRCB0aGUgaWQgb2YgdGhlIHRhc2sgcmV0dXJuZWQgYnkgc2VydmVyXG4qIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIHdpdGggd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiByZXN1bHRzXG4qL1xuSW5kZXgucHJvdG90eXBlLndhaXRUYXNrID0gZnVuY3Rpb24odGFza0lELCBjYWxsYmFjaykge1xuICAvLyB3YWl0IG1pbmltdW0gMTAwbXMgYmVmb3JlIHJldHJ5aW5nXG4gIHZhciBiYXNlRGVsYXkgPSAxMDA7XG4gIC8vIHdhaXQgbWF4aW11bSA1cyBiZWZvcmUgcmV0cnlpbmdcbiAgdmFyIG1heERlbGF5ID0gNTAwMDtcbiAgdmFyIGxvb3AgPSAwO1xuXG4gIC8vIHdhaXRUYXNrKCkgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IGZyb20gb3RoZXIgbWV0aG9kcyxcbiAgLy8gaXQncyBhIHJlY3Vyc2l2ZSBtZXRob2QgdXNpbmcgYSB0aW1lb3V0XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciBjbGllbnQgPSBpbmRleE9iai5hcztcblxuICB2YXIgcHJvbWlzZSA9IHJldHJ5TG9vcCgpO1xuXG4gIGZ1bmN0aW9uIHJldHJ5TG9vcCgpIHtcbiAgICByZXR1cm4gY2xpZW50Ll9qc29uUmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy90YXNrLycgKyB0YXNrSURcbiAgICB9KS50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3MoY29udGVudCkge1xuICAgICAgbG9vcCsrO1xuICAgICAgdmFyIGRlbGF5ID0gYmFzZURlbGF5ICogbG9vcCAqIGxvb3A7XG4gICAgICBpZiAoZGVsYXkgPiBtYXhEZWxheSkge1xuICAgICAgICBkZWxheSA9IG1heERlbGF5O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudC5zdGF0dXMgIT09ICdwdWJsaXNoZWQnKSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UuZGVsYXkoZGVsYXkpLnRoZW4ocmV0cnlMb29wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NiLCBmYWlsdXJlQ2IpO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3NDYihjb250ZW50KSB7XG4gICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRlbnQpO1xuICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWx1cmVDYihlcnIpIHtcbiAgICBleGl0UHJvbWlzZShmdW5jdGlvbiBleGl0KCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gIH1cbn07XG5cbi8qXG4qIFRoaXMgZnVuY3Rpb24gZGVsZXRlcyB0aGUgaW5kZXggY29udGVudC4gU2V0dGluZ3MgYW5kIGluZGV4IHNwZWNpZmljIEFQSSBrZXlzIGFyZSBrZXB0IHVudG91Y2hlZC5cbipcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2V0dGluZ3Mgb2JqZWN0IG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXgucHJvdG90eXBlLmNsZWFySW5kZXggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9jbGVhcicsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogR2V0IHNldHRpbmdzIG9mIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2V0dGluZ3Mgb2JqZWN0IG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXgucHJvdG90eXBlLmdldFNldHRpbmdzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9zZXR0aW5ncz9nZXRWZXJzaW9uPTInLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLnNlYXJjaFN5bm9ueW1zID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IHt9O1xuICB9IGVsc2UgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zL3NlYXJjaCcsXG4gICAgYm9keTogcGFyYW1zLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLnNhdmVTeW5vbnltID0gZnVuY3Rpb24oc3lub255bSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBpZiAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgIT09IHVuZGVmaW5lZCkgZGVwcmVjYXRlRm9yd2FyZFRvU2xhdmVzKCk7XG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IChvcHRzLmZvcndhcmRUb1NsYXZlcyB8fCBvcHRzLmZvcndhcmRUb1JlcGxpY2FzKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zLycgKyBlbmNvZGVVUklDb21wb25lbnQoc3lub255bS5vYmplY3RJRCkgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgYm9keTogc3lub255bSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZ2V0U3lub255bSA9IGZ1bmN0aW9uKG9iamVjdElELCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlU3lub255bSA9IGZ1bmN0aW9uKG9iamVjdElELCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCkgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmNsZWFyU3lub255bXMgPSBmdW5jdGlvbihvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zL2NsZWFyJyArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuYmF0Y2hTeW5vbnltcyA9IGZ1bmN0aW9uKHN5bm9ueW1zLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zL2JhdGNoJyArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyArXG4gICAgICAnJnJlcGxhY2VFeGlzdGluZ1N5bm9ueW1zPScgKyAob3B0cy5yZXBsYWNlRXhpc3RpbmdTeW5vbnltcyA/ICd0cnVlJyA6ICdmYWxzZScpLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGJvZHk6IHN5bm9ueW1zLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5zZWFyY2hSdWxlcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSB7fTtcbiAgfSBlbHNlIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy9zZWFyY2gnLFxuICAgIGJvZHk6IHBhcmFtcyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5zYXZlUnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gb3B0cy5mb3J3YXJkVG9SZXBsaWNhcyA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQocnVsZS5vYmplY3RJRCkgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgYm9keTogcnVsZSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZ2V0UnVsZSA9IGZ1bmN0aW9uKG9iamVjdElELCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcnVsZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGZ1bmN0aW9uKG9iamVjdElELCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuY2xlYXJSdWxlcyA9IGZ1bmN0aW9uKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gb3B0cy5mb3J3YXJkVG9SZXBsaWNhcyA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy9jbGVhcicgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmJhdGNoUnVsZXMgPSBmdW5jdGlvbihydWxlcywgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSBvcHRzLmZvcndhcmRUb1JlcGxpY2FzID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzL2JhdGNoJyArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyArXG4gICAgICAnJmNsZWFyRXhpc3RpbmdSdWxlcz0nICsgKG9wdHMuY2xlYXJFeGlzdGluZ1J1bGVzID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJyksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgYm9keTogcnVsZXMsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogU2V0IHNldHRpbmdzIGZvciB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBzZXR0aWducyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHRoYXQgY2FuIGNvbnRhaW5zIDpcbiogLSBtaW5Xb3JkU2l6ZWZvcjFUeXBvOiAoaW50ZWdlcikgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gYWNjZXB0IG9uZSB0eXBvIChkZWZhdWx0ID0gMykuXG4qIC0gbWluV29yZFNpemVmb3IyVHlwb3M6IChpbnRlZ2VyKSB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBhY2NlcHQgdHdvIHR5cG9zIChkZWZhdWx0ID0gNykuXG4qIC0gaGl0c1BlclBhZ2U6IChpbnRlZ2VyKSB0aGUgbnVtYmVyIG9mIGhpdHMgcGVyIHBhZ2UgKGRlZmF1bHQgPSAxMCkuXG4qIC0gYXR0cmlidXRlc1RvUmV0cmlldmU6IChhcnJheSBvZiBzdHJpbmdzKSBkZWZhdWx0IGxpc3Qgb2YgYXR0cmlidXRlcyB0byByZXRyaWV2ZSBpbiBvYmplY3RzLlxuKiAgIElmIHNldCB0byBudWxsLCBhbGwgYXR0cmlidXRlcyBhcmUgcmV0cmlldmVkLlxuKiAtIGF0dHJpYnV0ZXNUb0hpZ2hsaWdodDogKGFycmF5IG9mIHN0cmluZ3MpIGRlZmF1bHQgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGhpZ2hsaWdodC5cbiogICBJZiBzZXQgdG8gbnVsbCwgYWxsIGluZGV4ZWQgYXR0cmlidXRlcyBhcmUgaGlnaGxpZ2h0ZWQuXG4qIC0gYXR0cmlidXRlc1RvU25pcHBldCoqOiAoYXJyYXkgb2Ygc3RyaW5ncykgZGVmYXVsdCBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gc25pcHBldCBhbG9uZ3NpZGUgdGhlIG51bWJlclxuKiBvZiB3b3JkcyB0byByZXR1cm4gKHN5bnRheCBpcyBhdHRyaWJ1dGVOYW1lOm5iV29yZHMpLlxuKiAgIEJ5IGRlZmF1bHQgbm8gc25pcHBldCBpcyBjb21wdXRlZC4gSWYgc2V0IHRvIG51bGwsIG5vIHNuaXBwZXQgaXMgY29tcHV0ZWQuXG4qIC0gYXR0cmlidXRlc1RvSW5kZXg6IChhcnJheSBvZiBzdHJpbmdzKSB0aGUgbGlzdCBvZiBmaWVsZHMgeW91IHdhbnQgdG8gaW5kZXguXG4qICAgSWYgc2V0IHRvIG51bGwsIGFsbCB0ZXh0dWFsIGFuZCBudW1lcmljYWwgYXR0cmlidXRlcyBvZiB5b3VyIG9iamVjdHMgYXJlIGluZGV4ZWQsXG4qICAgYnV0IHlvdSBzaG91bGQgdXBkYXRlIGl0IHRvIGdldCBvcHRpbWFsIHJlc3VsdHMuXG4qICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHR3byBpbXBvcnRhbnQgdXNlczpcbiogICAgIC0gTGltaXQgdGhlIGF0dHJpYnV0ZXMgdG8gaW5kZXg6IEZvciBleGFtcGxlIGlmIHlvdSBzdG9yZSBhIGJpbmFyeSBpbWFnZSBpbiBiYXNlNjQsXG4qICAgICB5b3Ugd2FudCB0byBzdG9yZSBpdCBhbmQgYmUgYWJsZSB0b1xuKiAgICAgICByZXRyaWV2ZSBpdCBidXQgeW91IGRvbid0IHdhbnQgdG8gc2VhcmNoIGluIHRoZSBiYXNlNjQgc3RyaW5nLlxuKiAgICAgLSBDb250cm9sIHBhcnQgb2YgdGhlIHJhbmtpbmcqOiAoc2VlIHRoZSByYW5raW5nIHBhcmFtZXRlciBmb3IgZnVsbCBleHBsYW5hdGlvbilcbiogICAgIE1hdGNoZXMgaW4gYXR0cmlidXRlcyBhdCB0aGUgYmVnaW5uaW5nIG9mXG4qICAgICAgIHRoZSBsaXN0IHdpbGwgYmUgY29uc2lkZXJlZCBtb3JlIGltcG9ydGFudCB0aGFuIG1hdGNoZXMgaW4gYXR0cmlidXRlcyBmdXJ0aGVyIGRvd24gdGhlIGxpc3QuXG4qICAgICAgIEluIG9uZSBhdHRyaWJ1dGUsIG1hdGNoaW5nIHRleHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXR0cmlidXRlIHdpbGwgYmVcbiogICAgICAgY29uc2lkZXJlZCBtb3JlIGltcG9ydGFudCB0aGFuIHRleHQgYWZ0ZXIsIHlvdSBjYW4gZGlzYWJsZVxuKiAgICAgICB0aGlzIGJlaGF2aW9yIGlmIHlvdSBhZGQgeW91ciBhdHRyaWJ1dGUgaW5zaWRlIGB1bm9yZGVyZWQoQXR0cmlidXRlTmFtZSlgLFxuKiAgICAgICBmb3IgZXhhbXBsZSBhdHRyaWJ1dGVzVG9JbmRleDogW1widGl0bGVcIiwgXCJ1bm9yZGVyZWQodGV4dClcIl0uXG4qIC0gYXR0cmlidXRlc0ZvckZhY2V0aW5nOiAoYXJyYXkgb2Ygc3RyaW5ncykgVGhlIGxpc3Qgb2YgZmllbGRzIHlvdSB3YW50IHRvIHVzZSBmb3IgZmFjZXRpbmcuXG4qICAgQWxsIHN0cmluZ3MgaW4gdGhlIGF0dHJpYnV0ZSBzZWxlY3RlZCBmb3IgZmFjZXRpbmcgYXJlIGV4dHJhY3RlZCBhbmQgYWRkZWQgYXMgYSBmYWNldC5cbiogICBJZiBzZXQgdG8gbnVsbCwgbm8gYXR0cmlidXRlIGlzIHVzZWQgZm9yIGZhY2V0aW5nLlxuKiAtIGF0dHJpYnV0ZUZvckRpc3RpbmN0OiAoc3RyaW5nKSBUaGUgYXR0cmlidXRlIG5hbWUgdXNlZCBmb3IgdGhlIERpc3RpbmN0IGZlYXR1cmUuXG4qIFRoaXMgZmVhdHVyZSBpcyBzaW1pbGFyIHRvIHRoZSBTUUwgXCJkaXN0aW5jdFwiIGtleXdvcmQ6IHdoZW4gZW5hYmxlZFxuKiAgIGluIHF1ZXJ5IHdpdGggdGhlIGRpc3RpbmN0PTEgcGFyYW1ldGVyLCBhbGwgaGl0cyBjb250YWluaW5nIGEgZHVwbGljYXRlXG4qICAgdmFsdWUgZm9yIHRoaXMgYXR0cmlidXRlIGFyZSByZW1vdmVkIGZyb20gcmVzdWx0cy5cbiogICBGb3IgZXhhbXBsZSwgaWYgdGhlIGNob3NlbiBhdHRyaWJ1dGUgaXMgc2hvd19uYW1lIGFuZCBzZXZlcmFsIGhpdHMgaGF2ZVxuKiAgIHRoZSBzYW1lIHZhbHVlIGZvciBzaG93X25hbWUsIHRoZW4gb25seSB0aGUgYmVzdCBvbmUgaXMga2VwdCBhbmQgb3RoZXJzIGFyZSByZW1vdmVkLlxuKiAtIHJhbmtpbmc6IChhcnJheSBvZiBzdHJpbmdzKSBjb250cm9scyB0aGUgd2F5IHJlc3VsdHMgYXJlIHNvcnRlZC5cbiogICBXZSBoYXZlIHNpeCBhdmFpbGFibGUgY3JpdGVyaWE6XG4qICAgIC0gdHlwbzogc29ydCBhY2NvcmRpbmcgdG8gbnVtYmVyIG9mIHR5cG9zLFxuKiAgICAtIGdlbzogc29ydCBhY2NvcmRpbmcgdG8gZGVjcmVhc3NpbmcgZGlzdGFuY2Ugd2hlbiBwZXJmb3JtaW5nIGEgZ2VvLWxvY2F0aW9uIGJhc2VkIHNlYXJjaCxcbiogICAgLSBwcm94aW1pdHk6IHNvcnQgYWNjb3JkaW5nIHRvIHRoZSBwcm94aW1pdHkgb2YgcXVlcnkgd29yZHMgaW4gaGl0cyxcbiogICAgLSBhdHRyaWJ1dGU6IHNvcnQgYWNjb3JkaW5nIHRvIHRoZSBvcmRlciBvZiBhdHRyaWJ1dGVzIGRlZmluZWQgYnkgYXR0cmlidXRlc1RvSW5kZXgsXG4qICAgIC0gZXhhY3Q6XG4qICAgICAgICAtIGlmIHRoZSB1c2VyIHF1ZXJ5IGNvbnRhaW5zIG9uZSB3b3JkOiBzb3J0IG9iamVjdHMgaGF2aW5nIGFuIGF0dHJpYnV0ZVxuKiAgICAgICAgdGhhdCBpcyBleGFjdGx5IHRoZSBxdWVyeSB3b3JkIGJlZm9yZSBvdGhlcnMuXG4qICAgICAgICAgIEZvciBleGFtcGxlIGlmIHlvdSBzZWFyY2ggZm9yIHRoZSBcIlZcIiBUViBzaG93LCB5b3Ugd2FudCB0byBmaW5kIGl0XG4qICAgICAgICAgIHdpdGggdGhlIFwiVlwiIHF1ZXJ5IGFuZCBhdm9pZCB0byBoYXZlIGFsbCBwb3B1bGFyIFRWXG4qICAgICAgICAgIHNob3cgc3RhcnRpbmcgYnkgdGhlIHYgbGV0dGVyIGJlZm9yZSBpdC5cbiogICAgICAgIC0gaWYgdGhlIHVzZXIgcXVlcnkgY29udGFpbnMgbXVsdGlwbGUgd29yZHM6IHNvcnQgYWNjb3JkaW5nIHRvIHRoZVxuKiAgICAgICAgbnVtYmVyIG9mIHdvcmRzIHRoYXQgbWF0Y2hlZCBleGFjdGx5IChhbmQgbm90IGFzIGEgcHJlZml4KS5cbiogICAgLSBjdXN0b206IHNvcnQgYWNjb3JkaW5nIHRvIGEgdXNlciBkZWZpbmVkIGZvcm11bGEgc2V0IGluICoqY3VzdG9tUmFua2luZyoqIGF0dHJpYnV0ZS5cbiogICBUaGUgc3RhbmRhcmQgb3JkZXIgaXMgW1widHlwb1wiLCBcImdlb1wiLCBcInByb3hpbWl0eVwiLCBcImF0dHJpYnV0ZVwiLCBcImV4YWN0XCIsIFwiY3VzdG9tXCJdXG4qIC0gY3VzdG9tUmFua2luZzogKGFycmF5IG9mIHN0cmluZ3MpIGxldHMgeW91IHNwZWNpZnkgcGFydCBvZiB0aGUgcmFua2luZy5cbiogICBUaGUgc3ludGF4IG9mIHRoaXMgY29uZGl0aW9uIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBhdHRyaWJ1dGVzXG4qICAgcHJlZml4ZWQgYnkgYXNjIChhc2NlbmRpbmcgb3JkZXIpIG9yIGRlc2MgKGRlc2NlbmRpbmcgb3JkZXIpIG9wZXJhdG9yLlxuKiAgIEZvciBleGFtcGxlIGBcImN1c3RvbVJhbmtpbmdcIiA9PiBbXCJkZXNjKHBvcHVsYXRpb24pXCIsIFwiYXNjKG5hbWUpXCJdYFxuKiAtIHF1ZXJ5VHlwZTogU2VsZWN0IGhvdyB0aGUgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkLCBpdCBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWU6XG4qICAgLSBwcmVmaXhBbGw6IGFsbCBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgcHJlZml4ZXMsXG4qICAgLSBwcmVmaXhMYXN0OiBvbmx5IHRoZSBsYXN0IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXggKGRlZmF1bHQgYmVoYXZpb3IpLFxuKiAgIC0gcHJlZml4Tm9uZTogbm8gcXVlcnkgd29yZCBpcyBpbnRlcnByZXRlZCBhcyBhIHByZWZpeC4gVGhpcyBvcHRpb24gaXMgbm90IHJlY29tbWVuZGVkLlxuKiAtIGhpZ2hsaWdodFByZVRhZzogKHN0cmluZykgU3BlY2lmeSB0aGUgc3RyaW5nIHRoYXQgaXMgaW5zZXJ0ZWQgYmVmb3JlXG4qIHRoZSBoaWdobGlnaHRlZCBwYXJ0cyBpbiB0aGUgcXVlcnkgcmVzdWx0IChkZWZhdWx0IHRvIFwiPGVtPlwiKS5cbiogLSBoaWdobGlnaHRQb3N0VGFnOiAoc3RyaW5nKSBTcGVjaWZ5IHRoZSBzdHJpbmcgdGhhdCBpcyBpbnNlcnRlZCBhZnRlclxuKiB0aGUgaGlnaGxpZ2h0ZWQgcGFydHMgaW4gdGhlIHF1ZXJ5IHJlc3VsdCAoZGVmYXVsdCB0byBcIjwvZW0+XCIpLlxuKiAtIG9wdGlvbmFsV29yZHM6IChhcnJheSBvZiBzdHJpbmdzKSBTcGVjaWZ5IGEgbGlzdCBvZiB3b3JkcyB0aGF0IHNob3VsZFxuKiBiZSBjb25zaWRlcmVkIGFzIG9wdGlvbmFsIHdoZW4gZm91bmQgaW4gdGhlIHF1ZXJ5LlxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXgucHJvdG90eXBlLnNldFNldHRpbmdzID0gZnVuY3Rpb24oc2V0dGluZ3MsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL3NldHRpbmdzP2ZvcndhcmRUb1JlcGxpY2FzPSdcbiAgICAgICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgYm9keTogc2V0dGluZ3MsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXgubGlzdEFwaUtleXNcbiAqL1xuSW5kZXgucHJvdG90eXBlLmxpc3RVc2VyS2V5cyA9IGRlcHJlY2F0ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5saXN0QXBpS2V5cyhjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXgubGlzdFVzZXJLZXlzKCknLCAnaW5kZXgubGlzdEFwaUtleXMoKScpKTtcblxuLypcbiogTGlzdCBhbGwgZXhpc3RpbmcgQVBJIGtleXMgdG8gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIEFQSSBrZXlzIGJlbG9uZ2luZyB0byB0aGUgaW5kZXhcbiovXG5JbmRleC5wcm90b3R5cGUubGlzdEFwaUtleXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2tleXMnLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXguZ2V0QXBpS2V5XG4gKi9cbkluZGV4LnByb3RvdHlwZS5nZXRVc2VyS2V5QUNMID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZ2V0QXBpS2V5KGtleSwgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4LmdldFVzZXJLZXlBQ0woKScsICdpbmRleC5nZXRBcGlLZXkoKScpKTtcblxuXG4vKlxuKiBHZXQgYW4gQVBJIGtleSBmcm9tIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGtleVxuKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSByaWdodCBBUEkga2V5XG4qL1xuSW5kZXgucHJvdG90eXBlLmdldEFwaUtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9rZXlzLycgKyBrZXksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBpbmRleC5kZWxldGVBcGlLZXlcbiAqL1xuSW5kZXgucHJvdG90eXBlLmRlbGV0ZVVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5kZWxldGVBcGlLZXkoa2V5LCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXguZGVsZXRlVXNlcktleSgpJywgJ2luZGV4LmRlbGV0ZUFwaUtleSgpJykpO1xuXG4vKlxuKiBEZWxldGUgYW4gZXhpc3RpbmcgQVBJIGtleSBhc3NvY2lhdGVkIHRvIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGtleVxuKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBkZWxldGlvbiBkYXRlXG4qL1xuSW5kZXgucHJvdG90eXBlLmRlbGV0ZUFwaUtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9rZXlzLycgKyBrZXksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXguYWRkQXBpS2V5XG4gKi9cbkluZGV4LnByb3RvdHlwZS5hZGRVc2VyS2V5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYWRkQXBpS2V5KGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4LmFkZFVzZXJLZXkoKScsICdpbmRleC5hZGRBcGlLZXkoKScpKTtcblxuLypcbiogQWRkIGEgbmV3IEFQSSBrZXkgdG8gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2xzIC0gVGhlIGxpc3Qgb2YgQUNMIGZvciB0aGlzIGtleS4gRGVmaW5lZCBieSBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXRcbiogICBjYW4gY29udGFpbnMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4qICAgICAtIHNlYXJjaDogYWxsb3cgdG8gc2VhcmNoIChodHRwcyBhbmQgaHR0cClcbiogICAgIC0gYWRkT2JqZWN0OiBhbGxvd3MgdG8gYWRkL3VwZGF0ZSBhbiBvYmplY3QgaW4gdGhlIGluZGV4IChodHRwcyBvbmx5KVxuKiAgICAgLSBkZWxldGVPYmplY3QgOiBhbGxvd3MgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIG9iamVjdCAoaHR0cHMgb25seSlcbiogICAgIC0gZGVsZXRlSW5kZXggOiBhbGxvd3MgdG8gZGVsZXRlIGluZGV4IGNvbnRlbnQgKGh0dHBzIG9ubHkpXG4qICAgICAtIHNldHRpbmdzIDogYWxsb3dzIHRvIGdldCBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiogICAgIC0gZWRpdFNldHRpbmdzIDogYWxsb3dzIHRvIGNoYW5nZSBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9ubmFsIHBhcmFtZXRlcnMgdG8gc2V0IGZvciB0aGUga2V5XG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsaWRpdHkgLSBOdW1iZXIgb2Ygc2Vjb25kcyBhZnRlciB3aGljaCB0aGUga2V5IHdpbGxcbiogYmUgYXV0b21hdGljYWxseSByZW1vdmVkICgwIG1lYW5zIG5vIHRpbWUgbGltaXQgZm9yIHRoaXMga2V5KVxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5IC0gTnVtYmVyIG9mIGhpdHMgdGhpcyBBUEkga2V5IGNhbiByZXRyaWV2ZSBpbiBvbmUgY2FsbFxuKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBmb3IgeW91ciBrZXlcbiogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJlZmVyZXJzIC0gQSBsaXN0IG9mIGF1dGhvcml6ZWQgcmVmZXJlcnNcbiogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGFkZGVkIEFQSSBrZXlcbiogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4qIEBleGFtcGxlXG4qIGluZGV4LmFkZFVzZXJLZXkoWydzZWFyY2gnXSwge1xuKiAgIHZhbGlkaXR5OiAzMDAsXG4qICAgbWF4UXVlcmllc1BlcklQUGVySG91cjogMjAwMCxcbiogICBtYXhIaXRzUGVyUXVlcnk6IDMsXG4qICAgZGVzY3JpcHRpb246ICdFYXQgdGhyZWUgZnJ1aXRzJyxcbiogICByZWZlcmVyczogWycqLmFsZ29saWEuY29tJ10sXG4qICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4qICAgICB0YWdGaWx0ZXJzOiBbJ3B1YmxpYyddLFxuKiAgIH1cbiogfSlcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0FkZEluZGV4S2V5fEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleC5wcm90b3R5cGUuYWRkQXBpS2V5ID0gZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5hZGRBcGlLZXkoYXJyYXlPZkFjbHNbLCBwYXJhbXMsIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShhY2xzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwb3N0T2JqID0ge1xuICAgIGFjbDogYWNsc1xuICB9O1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBwb3N0T2JqLnZhbGlkaXR5ID0gcGFyYW1zLnZhbGlkaXR5O1xuICAgIHBvc3RPYmoubWF4UXVlcmllc1BlcklQUGVySG91ciA9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyO1xuICAgIHBvc3RPYmoubWF4SGl0c1BlclF1ZXJ5ID0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeTtcbiAgICBwb3N0T2JqLmRlc2NyaXB0aW9uID0gcGFyYW1zLmRlc2NyaXB0aW9uO1xuXG4gICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIHBvc3RPYmoucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5hcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMsICcnKTtcbiAgICB9XG5cbiAgICBwb3N0T2JqLnJlZmVyZXJzID0gcGFyYW1zLnJlZmVyZXJzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9rZXlzJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuKiBAZGVwcmVjYXRlZCB1c2UgaW5kZXguYWRkQXBpS2V5KClcbiovXG5JbmRleC5wcm90b3R5cGUuYWRkVXNlcktleVdpdGhWYWxpZGl0eSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBkZXByZWNhdGVkQWRkVXNlcktleVdpdGhWYWxpZGl0eShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFkZEFwaUtleShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5KCknLCAnaW5kZXguYWRkQXBpS2V5KCknKSk7XG5cbi8qXG4gQGRlcHJlY2F0ZWQgc2VlIGluZGV4LnVwZGF0ZUFwaUtleVxuICovXG5JbmRleC5wcm90b3R5cGUudXBkYXRlVXNlcktleSA9IGRlcHJlY2F0ZShmdW5jdGlvbihrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMudXBkYXRlQXBpS2V5KGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXgudXBkYXRlVXNlcktleSgpJywgJ2luZGV4LnVwZGF0ZUFwaUtleSgpJykpO1xuXG4vKipcbiogVXBkYXRlIGFuIGV4aXN0aW5nIEFQSSBrZXkgb2YgdGhpcyBpbmRleFxuKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB1cGRhdGVcbiogQHBhcmFtIHtzdHJpbmdbXX0gYWNscyAtIFRoZSBsaXN0IG9mIEFDTCBmb3IgdGhpcyBrZXkuIERlZmluZWQgYnkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0XG4qICAgY2FuIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuKiAgICAgLSBzZWFyY2g6IGFsbG93IHRvIHNlYXJjaCAoaHR0cHMgYW5kIGh0dHApXG4qICAgICAtIGFkZE9iamVjdDogYWxsb3dzIHRvIGFkZC91cGRhdGUgYW4gb2JqZWN0IGluIHRoZSBpbmRleCAoaHR0cHMgb25seSlcbiogICAgIC0gZGVsZXRlT2JqZWN0IDogYWxsb3dzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBvYmplY3QgKGh0dHBzIG9ubHkpXG4qICAgICAtIGRlbGV0ZUluZGV4IDogYWxsb3dzIHRvIGRlbGV0ZSBpbmRleCBjb250ZW50IChodHRwcyBvbmx5KVxuKiAgICAgLSBzZXR0aW5ncyA6IGFsbG93cyB0byBnZXQgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4qICAgICAtIGVkaXRTZXR0aW5ncyA6IGFsbG93cyB0byBjaGFuZ2UgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4qIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbm5hbCBwYXJhbWV0ZXJzIHRvIHNldCBmb3IgdGhlIGtleVxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbGlkaXR5IC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGtleSB3aWxsXG4qIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCAoMCBtZWFucyBubyB0aW1lIGxpbWl0IGZvciB0aGlzIGtleSlcbiogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyIC0gTnVtYmVyIG9mIEFQSSBjYWxscyBhbGxvd2VkIGZyb20gYW4gSVAgYWRkcmVzcyBwZXIgaG91clxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4qIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5yZWZlcmVycyAtIEEgbGlzdCBvZiBhdXRob3JpemVkIHJlZmVyZXJzXG4qIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucXVlcnlQYXJhbWV0ZXJzIC0gRm9yY2UgdGhlIGtleSB0byB1c2Ugc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHVzZXIga2V5cyBsaXN0XG4qIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuKiBAZXhhbXBsZVxuKiBpbmRleC51cGRhdGVBcGlLZXkoJ0FQSUtFWScsIFsnc2VhcmNoJ10sIHtcbiogICB2YWxpZGl0eTogMzAwLFxuKiAgIG1heFF1ZXJpZXNQZXJJUFBlckhvdXI6IDIwMDAsXG4qICAgbWF4SGl0c1BlclF1ZXJ5OiAzLFxuKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4qICAgcmVmZXJlcnM6IFsnKi5hbGdvbGlhLmNvbSddLFxuKiAgIHF1ZXJ5UGFyYW1ldGVyczoge1xuKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiogICB9XG4qIH0pXG4qIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNVcGRhdGVJbmRleEtleXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXgucHJvdG90eXBlLnVwZGF0ZUFwaUtleSA9IGZ1bmN0aW9uKGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC51cGRhdGVBcGlLZXkoa2V5LCBhcnJheU9mQWNsc1ssIHBhcmFtcywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KGFjbHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSBudWxsO1xuICB9XG5cbiAgdmFyIHB1dE9iaiA9IHtcbiAgICBhY2w6IGFjbHNcbiAgfTtcblxuICBpZiAocGFyYW1zKSB7XG4gICAgcHV0T2JqLnZhbGlkaXR5ID0gcGFyYW1zLnZhbGlkaXR5O1xuICAgIHB1dE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgcHV0T2JqLm1heEhpdHNQZXJRdWVyeSA9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnk7XG4gICAgcHV0T2JqLmRlc2NyaXB0aW9uID0gcGFyYW1zLmRlc2NyaXB0aW9uO1xuXG4gICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIHB1dE9iai5xdWVyeVBhcmFtZXRlcnMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycywgJycpO1xuICAgIH1cblxuICAgIHB1dE9iai5yZWZlcmVycyA9IHBhcmFtcy5yZWZlcmVycztcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9rZXlzLycgKyBrZXksXG4gICAgYm9keTogcHV0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0luZGV4LmpzIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ2YXIgYnVpbGRTZWFyY2hNZXRob2QgPSByZXF1aXJlKCcuL2J1aWxkU2VhcmNoTWV0aG9kLmpzJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUuanMnKTtcbnZhciBkZXByZWNhdGVkTWVzc2FnZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZE1lc3NhZ2UuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleENvcmU7XG5cbi8qXG4qIEluZGV4IGNsYXNzIGNvbnN0cnVjdG9yLlxuKiBZb3Ugc2hvdWxkIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgYnV0IHVzZSBpbml0SW5kZXgoKSBmdW5jdGlvblxuKi9cbmZ1bmN0aW9uIEluZGV4Q29yZShhbGdvbGlhc2VhcmNoLCBpbmRleE5hbWUpIHtcbiAgdGhpcy5pbmRleE5hbWUgPSBpbmRleE5hbWU7XG4gIHRoaXMuYXMgPSBhbGdvbGlhc2VhcmNoO1xuICB0aGlzLnR5cGVBaGVhZEFyZ3MgPSBudWxsO1xuICB0aGlzLnR5cGVBaGVhZFZhbHVlT3B0aW9uID0gbnVsbDtcblxuICAvLyBtYWtlIHN1cmUgZXZlcnkgaW5kZXggaW5zdGFuY2UgaGFzIGl0J3Mgb3duIGNhY2hlXG4gIHRoaXMuY2FjaGUgPSB7fTtcbn1cblxuLypcbiogQ2xlYXIgYWxsIHF1ZXJpZXMgaW4gY2FjaGVcbiovXG5JbmRleENvcmUucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYWNoZSA9IHt9O1xufTtcblxuLypcbiogU2VhcmNoIGluc2lkZSB0aGUgaW5kZXggdXNpbmcgWE1MSHR0cFJlcXVlc3QgcmVxdWVzdCAoVXNpbmcgYSBQT1NUIHF1ZXJ5IHRvXG4qIG1pbmltaXplIG51bWJlciBvZiBPUFRJT05TIHF1ZXJpZXM6IENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nKS5cbipcbiogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV0gdGhlIGZ1bGwgdGV4dCBxdWVyeVxuKiBAcGFyYW0ge29iamVjdH0gW2FyZ3NdIChvcHRpb25hbCkgaWYgc2V0LCBjb250YWlucyBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzOlxuKiAtIHBhZ2U6IChpbnRlZ2VyKSBQYWdpbmF0aW9uIHBhcmFtZXRlciB1c2VkIHRvIHNlbGVjdCB0aGUgcGFnZSB0byByZXRyaWV2ZS5cbiogICAgICAgICAgICAgICAgICAgUGFnZSBpcyB6ZXJvLWJhc2VkIGFuZCBkZWZhdWx0cyB0byAwLiBUaHVzLFxuKiAgICAgICAgICAgICAgICAgICB0byByZXRyaWV2ZSB0aGUgMTB0aCBwYWdlIHlvdSBuZWVkIHRvIHNldCBwYWdlPTlcbiogLSBoaXRzUGVyUGFnZTogKGludGVnZXIpIFBhZ2luYXRpb24gcGFyYW1ldGVyIHVzZWQgdG8gc2VsZWN0IHRoZSBudW1iZXIgb2YgaGl0cyBwZXIgcGFnZS4gRGVmYXVsdHMgdG8gMjAuXG4qIC0gYXR0cmlidXRlc1RvUmV0cmlldmU6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2Ygb2JqZWN0IGF0dHJpYnV0ZXNcbiogeW91IHdhbnQgdG8gcmV0cmlldmUgKGxldCB5b3UgbWluaW1pemUgdGhlIGFuc3dlciBzaXplKS5cbiogICBBdHRyaWJ1dGVzIGFyZSBzZXBhcmF0ZWQgd2l0aCBhIGNvbW1hIChmb3IgZXhhbXBsZSBcIm5hbWUsYWRkcmVzc1wiKS5cbiogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBbXCJuYW1lXCIsXCJhZGRyZXNzXCJdKS5cbiogICBCeSBkZWZhdWx0LCBhbGwgYXR0cmlidXRlcyBhcmUgcmV0cmlldmVkLiBZb3UgY2FuIGFsc28gdXNlICcqJyB0byByZXRyaWV2ZSBhbGxcbiogICB2YWx1ZXMgd2hlbiBhbiBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSBzZXR0aW5nIGlzIHNwZWNpZmllZCBmb3IgeW91ciBpbmRleC5cbiogLSBhdHRyaWJ1dGVzVG9IaWdobGlnaHQ6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgYXR0cmlidXRlcyB5b3VcbiogICB3YW50IHRvIGhpZ2hsaWdodCBhY2NvcmRpbmcgdG8gdGhlIHF1ZXJ5LlxuKiAgIEF0dHJpYnV0ZXMgYXJlIHNlcGFyYXRlZCBieSBhIGNvbW1hLiBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBbXCJuYW1lXCIsXCJhZGRyZXNzXCJdKS5cbiogICBJZiBhbiBhdHRyaWJ1dGUgaGFzIG5vIG1hdGNoIGZvciB0aGUgcXVlcnksIHRoZSByYXcgdmFsdWUgaXMgcmV0dXJuZWQuXG4qICAgQnkgZGVmYXVsdCBhbGwgaW5kZXhlZCB0ZXh0IGF0dHJpYnV0ZXMgYXJlIGhpZ2hsaWdodGVkLlxuKiAgIFlvdSBjYW4gdXNlIGAqYCBpZiB5b3Ugd2FudCB0byBoaWdobGlnaHQgYWxsIHRleHR1YWwgYXR0cmlidXRlcy5cbiogICBOdW1lcmljYWwgYXR0cmlidXRlcyBhcmUgbm90IGhpZ2hsaWdodGVkLlxuKiAgIEEgbWF0Y2hMZXZlbCBpcyByZXR1cm5lZCBmb3IgZWFjaCBoaWdobGlnaHRlZCBhdHRyaWJ1dGUgYW5kIGNhbiBjb250YWluOlxuKiAgICAgIC0gZnVsbDogaWYgYWxsIHRoZSBxdWVyeSB0ZXJtcyB3ZXJlIGZvdW5kIGluIHRoZSBhdHRyaWJ1dGUsXG4qICAgICAgLSBwYXJ0aWFsOiBpZiBvbmx5IHNvbWUgb2YgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQsXG4qICAgICAgLSBub25lOiBpZiBub25lIG9mIHRoZSBxdWVyeSB0ZXJtcyB3ZXJlIGZvdW5kLlxuKiAtIGF0dHJpYnV0ZXNUb1NuaXBwZXQ6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBzbmlwcGV0IGFsb25nc2lkZVxuKiB0aGUgbnVtYmVyIG9mIHdvcmRzIHRvIHJldHVybiAoc3ludGF4IGlzIGBhdHRyaWJ1dGVOYW1lOm5iV29yZHNgKS5cbiogICAgQXR0cmlidXRlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEgKEV4YW1wbGU6IGF0dHJpYnV0ZXNUb1NuaXBwZXQ9bmFtZToxMCxjb250ZW50OjEwKS5cbiogICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoRXhhbXBsZTogYXR0cmlidXRlc1RvU25pcHBldDogWyduYW1lOjEwJywnY29udGVudDoxMCddKS5cbiogICAgQnkgZGVmYXVsdCBubyBzbmlwcGV0IGlzIGNvbXB1dGVkLlxuKiAtIG1pbldvcmRTaXplZm9yMVR5cG86IHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIGEgcXVlcnkgd29yZCB0byBhY2NlcHQgb25lIHR5cG8gaW4gdGhpcyB3b3JkLlxuKiBEZWZhdWx0cyB0byAzLlxuKiAtIG1pbldvcmRTaXplZm9yMlR5cG9zOiB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBhIHF1ZXJ5IHdvcmRcbiogdG8gYWNjZXB0IHR3byB0eXBvcyBpbiB0aGlzIHdvcmQuIERlZmF1bHRzIHRvIDcuXG4qIC0gZ2V0UmFua2luZ0luZm86IGlmIHNldCB0byAxLCB0aGUgcmVzdWx0IGhpdHMgd2lsbCBjb250YWluIHJhbmtpbmdcbiogaW5mb3JtYXRpb24gaW4gX3JhbmtpbmdJbmZvIGF0dHJpYnV0ZS5cbiogLSBhcm91bmRMYXRMbmc6IHNlYXJjaCBmb3IgZW50cmllcyBhcm91bmQgYSBnaXZlblxuKiBsYXRpdHVkZS9sb25naXR1ZGUgKHNwZWNpZmllZCBhcyB0d28gZmxvYXRzIHNlcGFyYXRlZCBieSBhIGNvbW1hKS5cbiogICBGb3IgZXhhbXBsZSBhcm91bmRMYXRMbmc9NDcuMzE2NjY5LDUuMDE2NjcwKS5cbiogICBZb3UgY2FuIHNwZWNpZnkgdGhlIG1heGltdW0gZGlzdGFuY2UgaW4gbWV0ZXJzIHdpdGggdGhlIGFyb3VuZFJhZGl1cyBwYXJhbWV0ZXIgKGluIG1ldGVycylcbiogICBhbmQgdGhlIHByZWNpc2lvbiBmb3IgcmFua2luZyB3aXRoIGFyb3VuZFByZWNpc2lvblxuKiAgIChmb3IgZXhhbXBsZSBpZiB5b3Ugc2V0IGFyb3VuZFByZWNpc2lvbj0xMDAsIHR3byBvYmplY3RzIHRoYXQgYXJlIGRpc3RhbnQgb2ZcbiogICBsZXNzIHRoYW4gMTAwbSB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgaWRlbnRpY2FsIGZvciBcImdlb1wiIHJhbmtpbmcgcGFyYW1ldGVyKS5cbiogICBBdCBpbmRleGluZywgeW91IHNob3VsZCBzcGVjaWZ5IGdlb2xvYyBvZiBhbiBvYmplY3Qgd2l0aCB0aGUgX2dlb2xvYyBhdHRyaWJ1dGVcbiogICAoaW4gdGhlIGZvcm0ge1wiX2dlb2xvY1wiOntcImxhdFwiOjQ4Ljg1MzQwOSwgXCJsbmdcIjoyLjM0ODgwMH19KVxuKiAtIGluc2lkZUJvdW5kaW5nQm94OiBzZWFyY2ggZW50cmllcyBpbnNpZGUgYSBnaXZlbiBhcmVhIGRlZmluZWQgYnkgdGhlIHR3byBleHRyZW1lIHBvaW50c1xuKiBvZiBhIHJlY3RhbmdsZSAoZGVmaW5lZCBieSA0IGZsb2F0czogcDFMYXQscDFMbmcscDJMYXQscDJMbmcpLlxuKiAgIEZvciBleGFtcGxlIGluc2lkZUJvdW5kaW5nQm94PTQ3LjMxNjUsNC45NjY1LDQ3LjM0MjQsNS4wMjAxKS5cbiogICBBdCBpbmRleGluZywgeW91IHNob3VsZCBzcGVjaWZ5IGdlb2xvYyBvZiBhbiBvYmplY3Qgd2l0aCB0aGUgX2dlb2xvYyBhdHRyaWJ1dGVcbiogICAoaW4gdGhlIGZvcm0ge1wiX2dlb2xvY1wiOntcImxhdFwiOjQ4Ljg1MzQwOSwgXCJsbmdcIjoyLjM0ODgwMH19KVxuKiAtIG51bWVyaWNGaWx0ZXJzOiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIG51bWVyaWMgZmlsdGVycyB5b3Ugd2FudCB0b1xuKiBhcHBseSBzZXBhcmF0ZWQgYnkgYSBjb21tYS5cbiogICBUaGUgc3ludGF4IG9mIG9uZSBmaWx0ZXIgaXMgYGF0dHJpYnV0ZU5hbWVgIGZvbGxvd2VkIGJ5IGBvcGVyYW5kYCBmb2xsb3dlZCBieSBgdmFsdWVgLlxuKiAgIFN1cHBvcnRlZCBvcGVyYW5kcyBhcmUgYDxgLCBgPD1gLCBgPWAsIGA+YCBhbmQgYD49YC5cbiogICBZb3UgY2FuIGhhdmUgbXVsdGlwbGUgY29uZGl0aW9ucyBvbiBvbmUgYXR0cmlidXRlIGxpa2UgZm9yIGV4YW1wbGUgbnVtZXJpY0ZpbHRlcnM9cHJpY2U+MTAwLHByaWNlPDEwMDAuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoZm9yIGV4YW1wbGUgbnVtZXJpY0ZpbHRlcnM6IFtcInByaWNlPjEwMFwiLFwicHJpY2U8MTAwMFwiXSkuXG4qIC0gdGFnRmlsdGVyczogZmlsdGVyIHRoZSBxdWVyeSBieSBhIHNldCBvZiB0YWdzLiBZb3UgY2FuIEFORCB0YWdzIGJ5IHNlcGFyYXRpbmcgdGhlbSBieSBjb21tYXMuXG4qICAgVG8gT1IgdGFncywgeW91IG11c3QgYWRkIHBhcmVudGhlc2VzLiBGb3IgZXhhbXBsZSwgdGFncz10YWcxLCh0YWcyLHRhZzMpIG1lYW5zIHRhZzEgQU5EICh0YWcyIE9SIHRhZzMpLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXksIGZvciBleGFtcGxlIHRhZ0ZpbHRlcnM6IFtcInRhZzFcIixbXCJ0YWcyXCIsXCJ0YWczXCJdXVxuKiAgIG1lYW5zIHRhZzEgQU5EICh0YWcyIE9SIHRhZzMpLlxuKiAgIEF0IGluZGV4aW5nLCB0YWdzIHNob3VsZCBiZSBhZGRlZCBpbiB0aGUgX3RhZ3MqKiBhdHRyaWJ1dGVcbiogICBvZiBvYmplY3RzIChmb3IgZXhhbXBsZSB7XCJfdGFnc1wiOltcInRhZzFcIixcInRhZzJcIl19KS5cbiogLSBmYWNldEZpbHRlcnM6IGZpbHRlciB0aGUgcXVlcnkgYnkgYSBsaXN0IG9mIGZhY2V0cy5cbiogICBGYWNldHMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMgYW5kIGVhY2ggZmFjZXQgaXMgZW5jb2RlZCBhcyBgYXR0cmlidXRlTmFtZTp2YWx1ZWAuXG4qICAgRm9yIGV4YW1wbGU6IGBmYWNldEZpbHRlcnM9Y2F0ZWdvcnk6Qm9vayxhdXRob3I6Sm9obiUyMERvZWAuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoZm9yIGV4YW1wbGUgYFtcImNhdGVnb3J5OkJvb2tcIixcImF1dGhvcjpKb2huJTIwRG9lXCJdYCkuXG4qIC0gZmFjZXRzOiBMaXN0IG9mIG9iamVjdCBhdHRyaWJ1dGVzIHRoYXQgeW91IHdhbnQgdG8gdXNlIGZvciBmYWNldGluZy5cbiogICBDb21tYSBzZXBhcmF0ZWQgbGlzdDogYFwiY2F0ZWdvcnksYXV0aG9yXCJgIG9yIGFycmF5IGBbJ2NhdGVnb3J5JywnYXV0aG9yJ11gXG4qICAgT25seSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIGluICoqYXR0cmlidXRlc0ZvckZhY2V0aW5nKiogaW5kZXggc2V0dGluZ1xuKiAgIGNhbiBiZSB1c2VkIGluIHRoaXMgcGFyYW1ldGVyLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYCpgIHRvIHBlcmZvcm0gZmFjZXRpbmcgb24gYWxsIGF0dHJpYnV0ZXMgc3BlY2lmaWVkIGluICoqYXR0cmlidXRlc0ZvckZhY2V0aW5nKiouXG4qIC0gcXVlcnlUeXBlOiBzZWxlY3QgaG93IHRoZSBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQsIGl0IGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZTpcbiogICAgLSBwcmVmaXhBbGw6IGFsbCBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgcHJlZml4ZXMsXG4qICAgIC0gcHJlZml4TGFzdDogb25seSB0aGUgbGFzdCB3b3JkIGlzIGludGVycHJldGVkIGFzIGEgcHJlZml4IChkZWZhdWx0IGJlaGF2aW9yKSxcbiogICAgLSBwcmVmaXhOb25lOiBubyBxdWVyeSB3b3JkIGlzIGludGVycHJldGVkIGFzIGEgcHJlZml4LiBUaGlzIG9wdGlvbiBpcyBub3QgcmVjb21tZW5kZWQuXG4qIC0gb3B0aW9uYWxXb3JkczogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiB3b3JkcyB0aGF0IHNob3VsZFxuKiBiZSBjb25zaWRlcmVkIGFzIG9wdGlvbmFsIHdoZW4gZm91bmQgaW4gdGhlIHF1ZXJ5LlxuKiAgIENvbW1hIHNlcGFyYXRlZCBhbmQgYXJyYXkgYXJlIGFjY2VwdGVkLlxuKiAtIGRpc3RpbmN0OiBJZiBzZXQgdG8gMSwgZW5hYmxlIHRoZSBkaXN0aW5jdCBmZWF0dXJlIChkaXNhYmxlZCBieSBkZWZhdWx0KVxuKiBpZiB0aGUgYXR0cmlidXRlRm9yRGlzdGluY3QgaW5kZXggc2V0dGluZyBpcyBzZXQuXG4qICAgVGhpcyBmZWF0dXJlIGlzIHNpbWlsYXIgdG8gdGhlIFNRTCBcImRpc3RpbmN0XCIga2V5d29yZDogd2hlbiBlbmFibGVkXG4qICAgaW4gYSBxdWVyeSB3aXRoIHRoZSBkaXN0aW5jdD0xIHBhcmFtZXRlcixcbiogICBhbGwgaGl0cyBjb250YWluaW5nIGEgZHVwbGljYXRlIHZhbHVlIGZvciB0aGUgYXR0cmlidXRlRm9yRGlzdGluY3QgYXR0cmlidXRlIGFyZSByZW1vdmVkIGZyb20gcmVzdWx0cy5cbiogICBGb3IgZXhhbXBsZSwgaWYgdGhlIGNob3NlbiBhdHRyaWJ1dGUgaXMgc2hvd19uYW1lIGFuZCBzZXZlcmFsIGhpdHMgaGF2ZVxuKiAgIHRoZSBzYW1lIHZhbHVlIGZvciBzaG93X25hbWUsIHRoZW4gb25seSB0aGUgYmVzdFxuKiAgIG9uZSBpcyBrZXB0IGFuZCBvdGhlcnMgYXJlIHJlbW92ZWQuXG4qIC0gcmVzdHJpY3RTZWFyY2hhYmxlQXR0cmlidXRlczogTGlzdCBvZiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHVzZSBmb3JcbiogdGV4dHVhbCBzZWFyY2ggKG11c3QgYmUgYSBzdWJzZXQgb2YgdGhlIGF0dHJpYnV0ZXNUb0luZGV4IGluZGV4IHNldHRpbmcpXG4qIGVpdGhlciBjb21tYSBzZXBhcmF0ZWQgb3IgYXMgYW4gYXJyYXlcbiogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpLiBJZiBmYWxzZSwgdGhlIGNvbnRlbnQgY29udGFpbnMgdGhlIGVycm9yLlxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiByZXN1bHRzLlxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuc2VhcmNoID0gYnVpbGRTZWFyY2hNZXRob2QoJ3F1ZXJ5Jyk7XG5cbi8qXG4qIC0tIEJFVEEgLS1cbiogU2VhcmNoIGEgcmVjb3JkIHNpbWlsYXIgdG8gdGhlIHF1ZXJ5IGluc2lkZSB0aGUgaW5kZXggdXNpbmcgWE1MSHR0cFJlcXVlc3QgcmVxdWVzdCAoVXNpbmcgYSBQT1NUIHF1ZXJ5IHRvXG4qIG1pbmltaXplIG51bWJlciBvZiBPUFRJT05TIHF1ZXJpZXM6IENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nKS5cbipcbiogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV0gdGhlIHNpbWlsYXIgcXVlcnlcbiogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAob3B0aW9uYWwpIGlmIHNldCwgY29udGFpbnMgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycy5cbiogICBBbGwgc2VhcmNoIHBhcmFtZXRlcnMgYXJlIHN1cHBvcnRlZCAoc2VlIHNlYXJjaCBmdW5jdGlvbiksIHJlc3RyaWN0U2VhcmNoYWJsZUF0dHJpYnV0ZXMgYW5kIGZhY2V0RmlsdGVyc1xuKiAgIGFyZSB0aGUgdHdvIG1vc3QgdXNlZnVsIHRvIHJlc3RyaWN0IHRoZSBzaW1pbGFyIHJlc3VsdHMgYW5kIGdldCBtb3JlIHJlbGV2YW50IGNvbnRlbnRcbiovXG5JbmRleENvcmUucHJvdG90eXBlLnNpbWlsYXJTZWFyY2ggPSBidWlsZFNlYXJjaE1ldGhvZCgnc2ltaWxhclF1ZXJ5Jyk7XG5cbi8qXG4qIEJyb3dzZSBpbmRleCBjb250ZW50LiBUaGUgcmVzcG9uc2UgY29udGVudCB3aWxsIGhhdmUgYSBgY3Vyc29yYCBwcm9wZXJ0eSB0aGF0IHlvdSBjYW4gdXNlXG4qIHRvIGJyb3dzZSBzdWJzZXF1ZW50IHBhZ2VzIGZvciB0aGlzIHF1ZXJ5LiBVc2UgYGluZGV4LmJyb3dzZUZyb20oY3Vyc29yKWAgd2hlbiB5b3Ugd2FudC5cbipcbiogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGZ1bGwgdGV4dCBxdWVyeVxuKiBAcGFyYW0ge09iamVjdH0gW3F1ZXJ5UGFyYW1ldGVyc10gLSBBbnkgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlclxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGJyb3dzZSByZXN1bHRcbiogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4qIEBleGFtcGxlXG4qIGluZGV4LmJyb3dzZSgnY29vbCBzb25ncycsIHtcbiogICB0YWdGaWx0ZXJzOiAncHVibGljLGNvbW1lbnRzJyxcbiogICBoaXRzUGVyUGFnZTogNTAwXG4qIH0sIGNhbGxiYWNrKTtcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0Jyb3dzZXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5icm93c2UgPSBmdW5jdGlvbihxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzLCBjYWxsYmFjaykge1xuICB2YXIgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlLmpzJyk7XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICB2YXIgcGFnZTtcbiAgdmFyIGhpdHNQZXJQYWdlO1xuXG4gIC8vIHdlIGNoZWNrIHZhcmlhZGljIGNhbGxzIHRoYXQgYXJlIG5vdCB0aGUgb25lIGRlZmluZWRcbiAgLy8gLmJyb3dzZSgpLy5icm93c2UoZm4pXG4gIC8vID0+IHBhZ2UgPSAwXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhZ2UgPSAwO1xuICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgLy8gLmJyb3dzZSgyKS8uYnJvd3NlKDIsIDEwKS8uYnJvd3NlKDIsIGZuKS8uYnJvd3NlKDIsIDEwLCBmbilcbiAgICBwYWdlID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgaGl0c1BlclBhZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGhpdHNQZXJQYWdlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgICBxdWVyeVBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyAuYnJvd3NlKHF1ZXJ5UGFyYW1ldGVycykvLmJyb3dzZShxdWVyeVBhcmFtZXRlcnMsIGNiKVxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcXVlcnlQYXJhbWV0ZXJzID0gYXJndW1lbnRzWzBdO1xuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAuYnJvd3NlKHF1ZXJ5LCBjYilcbiAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICBxdWVyeVBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBvdGhlcndpc2UgaXQncyBhIC5icm93c2UocXVlcnkpLy5icm93c2UocXVlcnksIHF1ZXJ5UGFyYW1ldGVycykvLmJyb3dzZShxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzLCBjYilcblxuICAvLyBnZXQgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlcnMgY29tYmluaW5nIHZhcmlvdXMgcG9zc2libGUgY2FsbHNcbiAgLy8gdG8gLmJyb3dzZSgpO1xuICBxdWVyeVBhcmFtZXRlcnMgPSBtZXJnZSh7fSwgcXVlcnlQYXJhbWV0ZXJzIHx8IHt9LCB7XG4gICAgcGFnZTogcGFnZSxcbiAgICBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UsXG4gICAgcXVlcnk6IHF1ZXJ5XG4gIH0pO1xuXG4gIHZhciBwYXJhbXMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMocXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvYnJvd3NlJyxcbiAgICBib2R5OiB7cGFyYW1zOiBwYXJhbXN9LFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogQ29udGludWUgYnJvd3NpbmcgZnJvbSBhIHByZXZpb3VzIHBvc2l0aW9uIChjdXJzb3IpLCBvYnRhaW5lZCB2aWEgYSBjYWxsIHRvIGAuYnJvd3NlKClgLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgZnVsbCB0ZXh0IHF1ZXJ5XG4qIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbWV0ZXJzXSAtIEFueSBzZWFyY2ggcXVlcnkgcGFyYW1ldGVyXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgYnJvd3NlIHJlc3VsdFxuKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiogQGV4YW1wbGVcbiogaW5kZXguYnJvd3NlRnJvbSgnMTRsa2ZzYWtsMzInLCBjYWxsYmFjayk7XG4qIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNCcm93c2V8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuYnJvd3NlRnJvbSA9IGZ1bmN0aW9uKGN1cnNvciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9icm93c2UnLFxuICAgIGJvZHk6IHtjdXJzb3I6IGN1cnNvcn0sXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBTZWFyY2ggZm9yIGZhY2V0IHZhbHVlc1xuKiBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdC1hcGkvc2VhcmNoI3NlYXJjaC1mb3ItZmFjZXQtdmFsdWVzXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjZXROYW1lIEZhY2V0IG5hbWUsIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZWFyY2ggZm9yIHZhbHVlcyBpbi5cbiogTXVzdCBiZSBkZWNsYXJlZCBhcyBhIGZhY2V0XG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjZXRRdWVyeSBRdWVyeSBmb3IgdGhlIGZhY2V0IHNlYXJjaFxuKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy4qXSBBbnkgc2VhcmNoIHBhcmFtZXRlciBvZiBBbGdvbGlhLFxuKiBzZWUgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2FwaS1jbGllbnQvamF2YXNjcmlwdC9zZWFyY2gjc2VhcmNoLXBhcmFtZXRlcnNcbiogUGFnaW5hdGlvbiBpcyBub3Qgc3VwcG9ydGVkLiBUaGUgcGFnZSBhbmQgaGl0c1BlclBhZ2UgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5zZWFyY2hGb3JGYWNldFZhbHVlcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpO1xuICB2YXIgb21pdCA9IHJlcXVpcmUoJy4vb21pdC5qcycpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LnNlYXJjaEZvckZhY2V0VmFsdWVzKHtmYWNldE5hbWUsIGZhY2V0UXVlcnksIC4uLnBhcmFtc31bLCBjYWxsYmFja10pJztcblxuICBpZiAocGFyYW1zLmZhY2V0TmFtZSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5mYWNldFF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGZhY2V0TmFtZSA9IHBhcmFtcy5mYWNldE5hbWU7XG4gIHZhciBmaWx0ZXJlZFBhcmFtcyA9IG9taXQoY2xvbmUocGFyYW1zKSwgZnVuY3Rpb24oa2V5TmFtZSkge1xuICAgIHJldHVybiBrZXlOYW1lID09PSAnZmFjZXROYW1lJztcbiAgfSk7XG4gIHZhciBzZWFyY2hQYXJhbWV0ZXJzID0gdGhpcy5hcy5fZ2V0U2VhcmNoUGFyYW1zKGZpbHRlcmVkUGFyYW1zLCAnJyk7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgK1xuICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvZmFjZXRzLycgKyBlbmNvZGVVUklDb21wb25lbnQoZmFjZXROYW1lKSArICcvcXVlcnknLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgYm9keToge3BhcmFtczogc2VhcmNoUGFyYW1ldGVyc30sXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXhDb3JlLnByb3RvdHlwZS5zZWFyY2hGYWNldCA9IGRlcHJlY2F0ZShmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnNlYXJjaEZvckZhY2V0VmFsdWVzKHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoXG4gICdpbmRleC5zZWFyY2hGYWNldChwYXJhbXNbLCBjYWxsYmFja10pJyxcbiAgJ2luZGV4LnNlYXJjaEZvckZhY2V0VmFsdWVzKHBhcmFtc1ssIGNhbGxiYWNrXSknXG4pKTtcblxuSW5kZXhDb3JlLnByb3RvdHlwZS5fc2VhcmNoID0gZnVuY3Rpb24ocGFyYW1zLCB1cmwsIGNhbGxiYWNrLCBhZGRpdGlvbmFsVUEpIHtcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6IHVybCB8fCAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcXVlcnknLFxuICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc30sXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBmYWxsYmFjazoge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSksXG4gICAgICBib2R5OiB7cGFyYW1zOiBwYXJhbXN9XG4gICAgfSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgYWRkaXRpb25hbFVBOiBhZGRpdGlvbmFsVUFcbiAgfSk7XG59O1xuXG4vKlxuKiBHZXQgYW4gb2JqZWN0IGZyb20gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gb2JqZWN0SUQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBvYmplY3QgdG8gcmV0cmlldmVcbiogQHBhcmFtIGF0dHJzIChvcHRpb25hbCkgaWYgc2V0LCBjb250YWlucyB0aGUgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIHJldHJpZXZlXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIG9iamVjdCB0byByZXRyaWV2ZSBvciB0aGUgZXJyb3IgbWVzc2FnZSBpZiBhIGZhaWx1cmUgb2NjdXJlZFxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuZ2V0T2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0SUQsIGF0dHJzLCBjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBhdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYXR0cnM7XG4gICAgYXR0cnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgcGFyYW1zID0gJyc7XG4gIGlmIChhdHRycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zID0gJz9hdHRyaWJ1dGVzPSc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcGFyYW1zICs9ICcsJztcbiAgICAgIH1cbiAgICAgIHBhcmFtcyArPSBhdHRyc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpICsgcGFyYW1zLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogR2V0IHNldmVyYWwgb2JqZWN0cyBmcm9tIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIG9iamVjdElEcyB0aGUgYXJyYXkgb2YgdW5pcXVlIGlkZW50aWZpZXIgb2Ygb2JqZWN0cyB0byByZXRyaWV2ZVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuZ2V0T2JqZWN0cyA9IGZ1bmN0aW9uKG9iamVjdElEcywgYXR0cmlidXRlc1RvUmV0cmlldmUsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcblxuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LmdldE9iamVjdHMoYXJyYXlPZk9iamVjdElEc1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvYmplY3RJRHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGF0dHJpYnV0ZXNUb1JldHJpZXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZTtcbiAgICBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBib2R5ID0ge1xuICAgIHJlcXVlc3RzOiBtYXAob2JqZWN0SURzLCBmdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChvYmplY3RJRCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgIGluZGV4TmFtZTogaW5kZXhPYmouaW5kZXhOYW1lLFxuICAgICAgICBvYmplY3RJRDogb2JqZWN0SURcbiAgICAgIH07XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzVG9SZXRyaWV2ZSkge1xuICAgICAgICByZXF1ZXN0LmF0dHJpYnV0ZXNUb1JldHJpZXZlID0gYXR0cmlidXRlc1RvUmV0cmlldmUuam9pbignLCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9KVxuICB9O1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8qL29iamVjdHMnLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgYm9keTogYm9keSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleENvcmUucHJvdG90eXBlLmFzID0gbnVsbDtcbkluZGV4Q29yZS5wcm90b3R5cGUuaW5kZXhOYW1lID0gbnVsbDtcbkluZGV4Q29yZS5wcm90b3R5cGUudHlwZUFoZWFkQXJncyA9IG51bGw7XG5JbmRleENvcmUucHJvdG90eXBlLnR5cGVBaGVhZFZhbHVlT3B0aW9uID0gbnVsbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhDb3JlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBidWlsZFNlYXJjaE1ldGhvZDtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzLmpzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlYXJjaCBtZXRob2QgdG8gYmUgdXNlZCBpbiBjbGllbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlQYXJhbSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIHRoZSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgdXJsXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gdGhlIHNlYXJjaCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gYnVpbGRTZWFyY2hNZXRob2QocXVlcnlQYXJhbSwgdXJsKSB7XG4gIC8qKlxuICAgKiBUaGUgc2VhcmNoIG1ldGhvZC4gUHJlcGFyZXMgdGhlIGRhdGEgYW5kIHNlbmQgdGhlIHF1ZXJ5IHRvIEFsZ29saWEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgc3RyaW5nIHVzZWQgZm9yIHF1ZXJ5IHNlYXJjaFxuICAgKiBAcGFyYW0ge29iamVjdH0gYXJncyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gc2VuZCB3aXRoIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0aGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGNsaWVudCBnZXRzIHRoZSBhbnN3ZXJcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfFByb21pc2V9IElmIHRoZSBjYWxsYmFjayBpcyBub3QgcHJvdmlkZWQgdGhlbiB0aGlzIG1ldGhvZHMgcmV0dXJucyBhIFByb21pc2VcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2gocXVlcnksIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgLy8gd2FybiBWMiB1c2VycyBvbiBob3cgdG8gc2VhcmNoXG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgfHxcbiAgICAgIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIC5zZWFyY2gocXVlcnksIHBhcmFtcywgY2IpXG4gICAgICAvLyAuc2VhcmNoKGNiLCBwYXJhbXMpXG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcignaW5kZXguc2VhcmNoIHVzYWdlIGlzIGluZGV4LnNlYXJjaChxdWVyeSwgcGFyYW1zLCBjYiknKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemluZyB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2FnZSA6IC5zZWFyY2goKSwgLnNlYXJjaChjYilcbiAgICAgIGNhbGxiYWNrID0gcXVlcnk7XG4gICAgICBxdWVyeSA9ICcnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVXNhZ2UgOiAuc2VhcmNoKHF1ZXJ5L2FyZ3MpLCAuc2VhcmNoKHF1ZXJ5LCBjYilcbiAgICAgIGNhbGxiYWNrID0gYXJncztcbiAgICAgIGFyZ3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSAzIGFyZ3VtZW50cyB3aXRoIHZhbHVlc1xuXG4gICAgLy8gVXNhZ2UgOiAuc2VhcmNoKGFyZ3MpIC8vIGNhcmVmdWw6IHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnICYmIHF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICBhcmdzID0gcXVlcnk7XG4gICAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQgfHwgcXVlcnkgPT09IG51bGwpIHsgLy8gLnNlYXJjaCh1bmRlZmluZWQvbnVsbClcbiAgICAgIHF1ZXJ5ID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gICAgaWYgKHF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcyArPSBxdWVyeVBhcmFtICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KTtcbiAgICB9XG5cbiAgICB2YXIgYWRkaXRpb25hbFVBO1xuICAgIGlmIChhcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChhcmdzLmFkZGl0aW9uYWxVQSkge1xuICAgICAgICBhZGRpdGlvbmFsVUEgPSBhcmdzLmFkZGl0aW9uYWxVQTtcbiAgICAgICAgZGVsZXRlIGFyZ3MuYWRkaXRpb25hbFVBO1xuICAgICAgfVxuICAgICAgLy8gYF9nZXRTZWFyY2hQYXJhbXNgIHdpbGwgYXVnbWVudCBwYXJhbXMsIGRvIG5vdCBiZSBmb29sZWQgYnkgdGhlID0gdmVyc3VzICs9IGZyb20gcHJldmlvdXMgaWZcbiAgICAgIHBhcmFtcyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhhcmdzLCBwYXJhbXMpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaChwYXJhbXMsIHVybCwgY2FsbGJhY2ssIGFkZGl0aW9uYWxVQSk7XG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2J1aWxkU2VhcmNoTWV0aG9kLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgaG9zdHMgb3VyIGVycm9yIGRlZmluaXRpb25zXG4vLyBXZSB1c2UgY3VzdG9tIGVycm9yIFwidHlwZXNcIiBzbyB0aGF0IHdlIGNhbiBhY3Qgb24gdGhlbSB3aGVuIHdlIG5lZWQgaXRcbi8vIGUuZy46IGlmIGVycm9yIGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OIHRoZW4uLlxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiBBbGdvbGlhU2VhcmNoRXJyb3IobWVzc2FnZSwgZXh0cmFQcm9wZXJ0aWVzKSB7XG4gIHZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG4gIHZhciBlcnJvciA9IHRoaXM7XG5cbiAgLy8gdHJ5IHRvIGdldCBhIHN0YWNrdHJhY2VcbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnQ2Fubm90IGdldCBhIHN0YWNrdHJhY2UsIGJyb3dzZXIgaXMgdG9vIG9sZCc7XG4gIH1cblxuICB0aGlzLm5hbWUgPSAnQWxnb2xpYVNlYXJjaEVycm9yJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG5cbiAgaWYgKGV4dHJhUHJvcGVydGllcykge1xuICAgIGZvckVhY2goZXh0cmFQcm9wZXJ0aWVzLCBmdW5jdGlvbiBhZGRUb0Vycm9yT2JqZWN0KHZhbHVlLCBrZXkpIHtcbiAgICAgIGVycm9yW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxufVxuXG5pbmhlcml0cyhBbGdvbGlhU2VhcmNoRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXJyb3IobmFtZSwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBBbGdvbGlhU2VhcmNoQ3VzdG9tRXJyb3IoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgLy8gY3VzdG9tIG1lc3NhZ2Ugbm90IHNldCwgdXNlIGRlZmF1bHRcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBhcmdzLnVuc2hpZnQobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgQWxnb2xpYVNlYXJjaEVycm9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHRoaXMubmFtZSA9ICdBbGdvbGlhU2VhcmNoJyArIG5hbWUgKyAnRXJyb3InO1xuICB9XG5cbiAgaW5oZXJpdHMoQWxnb2xpYVNlYXJjaEN1c3RvbUVycm9yLCBBbGdvbGlhU2VhcmNoRXJyb3IpO1xuXG4gIHJldHVybiBBbGdvbGlhU2VhcmNoQ3VzdG9tRXJyb3I7XG59XG5cbi8vIGxhdGUgZXhwb3J0cyB0byBsZXQgdmFyaW91cyBmbiBkZWZzIGFuZCBpbmhlcml0cyB0YWtlIHBsYWNlXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWxnb2xpYVNlYXJjaEVycm9yOiBBbGdvbGlhU2VhcmNoRXJyb3IsXG4gIFVucGFyc2FibGVKU09OOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnVW5wYXJzYWJsZUpTT04nLFxuICAgICdDb3VsZCBub3QgcGFyc2UgdGhlIGluY29taW5nIHJlc3BvbnNlIGFzIEpTT04sIHNlZSBlcnIubW9yZSBmb3IgZGV0YWlscydcbiAgKSxcbiAgUmVxdWVzdFRpbWVvdXQ6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdSZXF1ZXN0VGltZW91dCcsXG4gICAgJ1JlcXVlc3QgdGltZWRvdXQgYmVmb3JlIGdldHRpbmcgYSByZXNwb25zZSdcbiAgKSxcbiAgTmV0d29yazogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ05ldHdvcmsnLFxuICAgICdOZXR3b3JrIGlzc3VlLCBzZWUgZXJyLm1vcmUgZm9yIGRldGFpbHMnXG4gICksXG4gIEpTT05QU2NyaXB0RmFpbDogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ0pTT05QU2NyaXB0RmFpbCcsXG4gICAgJzxzY3JpcHQ+IHdhcyBsb2FkZWQgYnV0IGRpZCBub3QgY2FsbCBvdXIgcHJvdmlkZWQgY2FsbGJhY2snXG4gICksXG4gIEpTT05QU2NyaXB0RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdKU09OUFNjcmlwdEVycm9yJyxcbiAgICAnPHNjcmlwdD4gdW5hYmxlIHRvIGxvYWQgZHVlIHRvIGFuIGBlcnJvcmAgZXZlbnQgb24gaXQnXG4gICksXG4gIFVua25vd246IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdVbmtub3duJyxcbiAgICAnVW5rbm93biBlcnJvciBvY2N1cmVkJ1xuICApXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9lcnJvcnMuanMiLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mb3JlYWNoL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2RlcHJlY2F0ZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVwcmVjYXRlZE1lc3NhZ2UocHJldmlvdXNVc2FnZSwgbmV3VXNhZ2UpIHtcbiAgdmFyIGdpdGh1YkFuY2hvckxpbmsgPSBwcmV2aW91c1VzYWdlLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvW1xcLlxcKFxcKV0vZywgJycpO1xuXG4gIHJldHVybiAnYWxnb2xpYXNlYXJjaDogYCcgKyBwcmV2aW91c1VzYWdlICsgJ2Agd2FzIHJlcGxhY2VkIGJ5IGAnICsgbmV3VXNhZ2UgK1xuICAgICdgLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWphdmFzY3JpcHQvd2lraS9EZXByZWNhdGVkIycgKyBnaXRodWJBbmNob3JMaW5rO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlZE1lc3NhZ2UuanMiLCJ2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZShkZXN0aW5hdGlvbi8qICwgc291cmNlcyAqLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgZm9yZWFjaChzb3VyY2VzLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXlOYW1lIGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXlOYW1lKSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uW2tleU5hbWVdID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc291cmNlW2tleU5hbWVdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW2tleU5hbWVdID0gbWVyZ2Uoe30sIGRlc3RpbmF0aW9uW2tleU5hbWVdLCBzb3VyY2Vba2V5TmFtZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVtrZXlOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25ba2V5TmFtZV0gPSBzb3VyY2Vba2V5TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL21lcmdlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9jbG9uZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb21pdChvYmosIHRlc3QpIHtcbiAgdmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xuICB2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxuICB2YXIgZmlsdGVyZWQgPSB7fTtcblxuICBmb3JlYWNoKGtleXMob2JqKSwgZnVuY3Rpb24gZG9GaWx0ZXIoa2V5TmFtZSkge1xuICAgIGlmICh0ZXN0KGtleU5hbWUpICE9PSB0cnVlKSB7XG4gICAgICBmaWx0ZXJlZFtrZXlOYW1lXSA9IG9ialtrZXlOYW1lXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmaWx0ZXJlZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL29taXQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbnZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xudmFyIGRvbnRFbnVtcyA9IFtcblx0J3RvU3RyaW5nJyxcblx0J3RvTG9jYWxlU3RyaW5nJyxcblx0J3ZhbHVlT2YnLFxuXHQnaGFzT3duUHJvcGVydHknLFxuXHQnaXNQcm90b3R5cGVPZicsXG5cdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdCdjb25zdHJ1Y3Rvcidcbl07XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xufTtcbnZhciBleGNsdWRlZEtleXMgPSB7XG5cdCRjb25zb2xlOiB0cnVlLFxuXHQkZXh0ZXJuYWw6IHRydWUsXG5cdCRmcmFtZTogdHJ1ZSxcblx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0JGZyYW1lczogdHJ1ZSxcblx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdCRwYXJlbnQ6IHRydWUsXG5cdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHQkc2Nyb2xsWDogdHJ1ZSxcblx0JHNjcm9sbFk6IHRydWUsXG5cdCRzZWxmOiB0cnVlLFxuXHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdCR3aW5kb3c6IHRydWVcbn07XG52YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn0oKSk7XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdHZhciB0aGVLZXlzID0gW107XG5cblx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdH1cblxuXHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoZUtleXM7XG59O1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHRyZXR1cm4gKE9iamVjdC5rZXlzKGFyZ3VtZW50cykgfHwgJycpLmxlbmd0aCA9PT0gMjtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdHZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL34vb2JqZWN0LWtleXMvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9+L29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvfi9pc2FycmF5L2luZGV4LmpzIiwidmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgdmFyIG5ld0FyciA9IFtdO1xuICBmb3JlYWNoKGFyciwgZnVuY3Rpb24oaXRlbSwgaXRlbUluZGV4KSB7XG4gICAgbmV3QXJyLnB1c2goZm4oaXRlbSwgaXRlbUluZGV4LCBhcnIpKTtcbiAgfSk7XG4gIHJldHVybiBuZXdBcnI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tYXAuanMiLCIvLyBQYXJzZSBjbG91ZCBkb2VzIG5vdCBzdXBwb3J0cyBzZXRUaW1lb3V0XG4vLyBXZSBkbyBub3Qgc3RvcmUgYSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBpbiB0aGUgY2xpZW50IGV2ZXJ5dGltZVxuLy8gV2Ugb25seSBmYWxsYmFjayB0byBhIGZha2Ugc2V0VGltZW91dCB3aGVuIG5vdCBhdmFpbGFibGVcbi8vIHNldFRpbWVvdXQgY2Fubm90IGJlIG92ZXJyaWRlIGdsb2JhbGx5IHNhZGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4aXRQcm9taXNlKGZuLCBfc2V0VGltZW91dCkge1xuICBfc2V0VGltZW91dChmbiwgMCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9leGl0UHJvbWlzZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBpcyB0aGUgb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBgaW5kZXguYnJvd3NlQWxsKClgIG1ldGhvZFxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4QnJvd3NlcjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbmZ1bmN0aW9uIEluZGV4QnJvd3NlcigpIHtcbn1cblxuaW5oZXJpdHMoSW5kZXhCcm93c2VyLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmRleEJyb3dzZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gIHRoaXMuX2NsZWFuKCk7XG59O1xuXG5JbmRleEJyb3dzZXIucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgdGhpcy5fY2xlYW4oKTtcbn07XG5cbkluZGV4QnJvd3Nlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLl9jbGVhbigpO1xufTtcblxuSW5kZXhCcm93c2VyLnByb3RvdHlwZS5fcmVzdWx0ID0gZnVuY3Rpb24oY29udGVudCkge1xuICB0aGlzLmVtaXQoJ3Jlc3VsdCcsIGNvbnRlbnQpO1xufTtcblxuSW5kZXhCcm93c2VyLnByb3RvdHlwZS5fY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3N0b3AnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3Jlc3VsdCcpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhCcm93c2VyLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9ldmVudHMvZXZlbnRzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBBbGdvbGlhU2VhcmNoQ29yZTtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgZXhpdFByb21pc2UgPSByZXF1aXJlKCcuL2V4aXRQcm9taXNlLmpzJyk7XG52YXIgSW5kZXhDb3JlID0gcmVxdWlyZSgnLi9JbmRleENvcmUuanMnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUuanMnKTtcblxuLy8gV2Ugd2lsbCBhbHdheXMgcHV0IHRoZSBBUEkgS0VZIGluIHRoZSBKU09OIGJvZHkgaW4gY2FzZSBvZiB0b28gbG9uZyBBUEkgS0VZLFxuLy8gdG8gYXZvaWQgcXVlcnkgc3RyaW5nIGJlaW5nIHRvbyBsb25nIGFuZCBmYWlsaW5nIGluIHZhcmlvdXMgY29uZGl0aW9ucyAob3VyIHNlcnZlciBsaW1pdCwgYnJvd3NlciBsaW1pdCxcbi8vIHByb3hpZXMgbGltaXQpXG52YXIgTUFYX0FQSV9LRVlfTEVOR1RIID0gNTAwO1xudmFyIFJFU0VUX0FQUF9EQVRBX1RJTUVSID1cbiAgcHJvY2Vzcy5lbnYuUkVTRVRfQVBQX0RBVEFfVElNRVIgJiYgcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVTRVRfQVBQX0RBVEFfVElNRVIsIDEwKSB8fFxuICA2MCAqIDIgKiAxMDAwOyAvLyBhZnRlciAyIG1pbnV0ZXMgcmVzZXQgdG8gZmlyc3QgaG9zdFxuXG4vKlxuICogQWxnb2xpYSBTZWFyY2ggbGlicmFyeSBpbml0aWFsaXphdGlvblxuICogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFwcGxpY2F0aW9uSUQgLSBZb3VyIGFwcGxpY2F0aW9uSUQsIGZvdW5kIGluIHlvdXIgZGFzaGJvYXJkXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5IC0gWW91ciBBUEkga2V5LCBmb3VuZCBpbiB5b3VyIGRhc2hib2FyZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MjAwMF0gLSBUaGUgcmVxdWVzdCB0aW1lb3V0IHNldCBpbiBtaWxsaXNlY29uZHMsXG4gKiBhbm90aGVyIHJlcXVlc3Qgd2lsbCBiZSBpc3N1ZWQgYWZ0ZXIgdGhpcyB0aW1lb3V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJvdG9jb2w9J2h0dHA6J10gLSBUaGUgcHJvdG9jb2wgdXNlZCB0byBxdWVyeSBBbGdvbGlhIFNlYXJjaCBBUEkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgdG8gJ2h0dHBzOicgdG8gZm9yY2UgdXNpbmcgaHR0cHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHRvIGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sIGluIGJyb3dzZXJzXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gW29wdHMuaG9zdHM9e1xuICogICAgICAgICAgIHJlYWQ6IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLWRzbi5hbGdvbGlhLm5ldCddLmNvbmNhdChbXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTEuYWxnb2xpYW5ldC5jb20nLFxuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0yLmFsZ29saWFuZXQuY29tJyxcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMy5hbGdvbGlhbmV0LmNvbSddXG4gKiAgICAgICAgICAgXSksXG4gKiAgICAgICAgICAgd3JpdGU6IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLmFsZ29saWEubmV0J10uY29uY2F0KFtcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMS5hbGdvbGlhbmV0LmNvbScsXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTIuYWxnb2xpYW5ldC5jb20nLFxuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0zLmFsZ29saWFuZXQuY29tJ11cbiAqICAgICAgICAgICBdKSAtIFRoZSBob3N0cyB0byB1c2UgZm9yIEFsZ29saWEgU2VhcmNoIEFQSS5cbiAqICAgICAgICAgICBJZiB5b3UgcHJvdmlkZSB0aGVtLCB5b3Ugd2lsbCBsZXNzIGJlbmVmaXQgZnJvbSBvdXIgSEEgaW1wbGVtZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gQWxnb2xpYVNlYXJjaENvcmUoYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSB7XG4gIHZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2FsZ29saWFzZWFyY2gnKTtcblxuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcblxuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGFsZ29saWFzZWFyY2goYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSc7XG5cbiAgaWYgKG9wdHMuX2FsbG93RW1wdHlDcmVkZW50aWFscyAhPT0gdHJ1ZSAmJiAhYXBwbGljYXRpb25JRCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBhcHBsaWNhdGlvbiBJRC4gJyArIHVzYWdlKTtcbiAgfVxuXG4gIGlmIChvcHRzLl9hbGxvd0VtcHR5Q3JlZGVudGlhbHMgIT09IHRydWUgJiYgIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBBUEkga2V5LiAnICsgdXNhZ2UpO1xuICB9XG5cbiAgdGhpcy5hcHBsaWNhdGlvbklEID0gYXBwbGljYXRpb25JRDtcbiAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG5cbiAgdGhpcy5ob3N0cyA9IHtcbiAgICByZWFkOiBbXSxcbiAgICB3cml0ZTogW11cbiAgfTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8ICdodHRwczonO1xuICB0aGlzLl90aW1lb3V0cyA9IG9wdHMudGltZW91dHMgfHwge1xuICAgIGNvbm5lY3Q6IDEgKiAxMDAwLCAvLyA1MDBtcyBjb25uZWN0IGlzIEdQUlMgbGF0ZW5jeVxuICAgIHJlYWQ6IDIgKiAxMDAwLFxuICAgIHdyaXRlOiAzMCAqIDEwMDBcbiAgfTtcblxuICAvLyBiYWNrd2FyZCBjb21wYXQsIGlmIG9wdHMudGltZW91dCBpcyBwYXNzZWQsIHdlIHVzZSBpdCB0byBjb25maWd1cmUgYWxsIHRpbWVvdXRzIGxpa2UgYmVmb3JlXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICB0aGlzLl90aW1lb3V0cy5jb25uZWN0ID0gdGhpcy5fdGltZW91dHMucmVhZCA9IHRoaXMuX3RpbWVvdXRzLndyaXRlID0gb3B0cy50aW1lb3V0O1xuICB9XG5cbiAgLy8gd2hpbGUgd2UgYWR2b2NhdGUgZm9yIGNvbG9uLWF0LXRoZS1lbmQgdmFsdWVzOiAnaHR0cDonIGZvciBgb3B0cy5wcm90b2NvbGBcbiAgLy8gd2UgYWxzbyBhY2NlcHQgYGh0dHBgIGFuZCBgaHR0cHNgLiBJdCdzIGEgY29tbW9uIGVycm9yLlxuICBpZiAoIS86JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICBwcm90b2NvbCA9IHByb3RvY29sICsgJzonO1xuICB9XG5cbiAgaWYgKG9wdHMucHJvdG9jb2wgIT09ICdodHRwOicgJiYgb3B0cy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcigncHJvdG9jb2wgbXVzdCBiZSBgaHR0cDpgIG9yIGBodHRwczpgICh3YXMgYCcgKyBvcHRzLnByb3RvY29sICsgJ2ApJyk7XG4gIH1cblxuICB0aGlzLl9jaGVja0FwcElkRGF0YSgpO1xuXG4gIGlmICghb3B0cy5ob3N0cykge1xuICAgIHZhciBkZWZhdWx0SG9zdHMgPSBtYXAodGhpcy5fc2h1ZmZsZVJlc3VsdCwgZnVuY3Rpb24oaG9zdE51bWJlcikge1xuICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uSUQgKyAnLScgKyBob3N0TnVtYmVyICsgJy5hbGdvbGlhbmV0LmNvbSc7XG4gICAgfSk7XG5cbiAgICAvLyBubyBob3N0cyBnaXZlbiwgY29tcHV0ZSBkZWZhdWx0c1xuICAgIHRoaXMuaG9zdHMucmVhZCA9IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLWRzbi5hbGdvbGlhLm5ldCddLmNvbmNhdChkZWZhdWx0SG9zdHMpO1xuICAgIHRoaXMuaG9zdHMud3JpdGUgPSBbdGhpcy5hcHBsaWNhdGlvbklEICsgJy5hbGdvbGlhLm5ldCddLmNvbmNhdChkZWZhdWx0SG9zdHMpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0cy5ob3N0cykpIHtcbiAgICAvLyB3aGVuIHBhc3NpbmcgY3VzdG9tIGhvc3RzLCB3ZSBuZWVkIHRvIGhhdmUgYSBkaWZmZXJlbnQgaG9zdCBpbmRleCBpZiB0aGUgbnVtYmVyXG4gICAgLy8gb2Ygd3JpdGUvcmVhZCBob3N0cyBhcmUgZGlmZmVyZW50LlxuICAgIHRoaXMuaG9zdHMucmVhZCA9IGNsb25lKG9wdHMuaG9zdHMpO1xuICAgIHRoaXMuaG9zdHMud3JpdGUgPSBjbG9uZShvcHRzLmhvc3RzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhvc3RzLnJlYWQgPSBjbG9uZShvcHRzLmhvc3RzLnJlYWQpO1xuICAgIHRoaXMuaG9zdHMud3JpdGUgPSBjbG9uZShvcHRzLmhvc3RzLndyaXRlKTtcbiAgfVxuXG4gIC8vIGFkZCBwcm90b2NvbCBhbmQgbG93ZXJjYXNlIGhvc3RzXG4gIHRoaXMuaG9zdHMucmVhZCA9IG1hcCh0aGlzLmhvc3RzLnJlYWQsIHByZXBhcmVIb3N0KHByb3RvY29sKSk7XG4gIHRoaXMuaG9zdHMud3JpdGUgPSBtYXAodGhpcy5ob3N0cy53cml0ZSwgcHJlcGFyZUhvc3QocHJvdG9jb2wpKTtcblxuICB0aGlzLmV4dHJhSGVhZGVycyA9IHt9O1xuXG4gIC8vIEluIHNvbWUgc2l0dWF0aW9ucyB5b3UgbWlnaHQgd2FudCB0byB3YXJtIHRoZSBjYWNoZVxuICB0aGlzLmNhY2hlID0gb3B0cy5fY2FjaGUgfHwge307XG5cbiAgdGhpcy5fdWEgPSBvcHRzLl91YTtcbiAgdGhpcy5fdXNlQ2FjaGUgPSBvcHRzLl91c2VDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuX2NhY2hlID8gdHJ1ZSA6IG9wdHMuX3VzZUNhY2hlO1xuICB0aGlzLl91c2VGYWxsYmFjayA9IG9wdHMudXNlRmFsbGJhY2sgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnVzZUZhbGxiYWNrO1xuXG4gIHRoaXMuX3NldFRpbWVvdXQgPSBvcHRzLl9zZXRUaW1lb3V0O1xuXG4gIGRlYnVnKCdpbml0IGRvbmUsICVqJywgdGhpcyk7XG59XG5cbi8qXG4gKiBHZXQgdGhlIGluZGV4IG9iamVjdCBpbml0aWFsaXplZFxuICpcbiAqIEBwYXJhbSBpbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXhcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIHdpdGggb25lIGFyZ3VtZW50ICh0aGUgSW5kZXggaW5zdGFuY2UpXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5pbml0SW5kZXggPSBmdW5jdGlvbihpbmRleE5hbWUpIHtcbiAgcmV0dXJuIG5ldyBJbmRleENvcmUodGhpcywgaW5kZXhOYW1lKTtcbn07XG5cbi8qKlxuKiBBZGQgYW4gZXh0cmEgZmllbGQgdG8gdGhlIEhUVFAgcmVxdWVzdFxuKlxuKiBAcGFyYW0gbmFtZSB0aGUgaGVhZGVyIGZpZWxkIG5hbWVcbiogQHBhcmFtIHZhbHVlIHRoZSBoZWFkZXIgZmllbGQgdmFsdWVcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0RXh0cmFIZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLmV4dHJhSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG59O1xuXG4vKipcbiogR2V0IHRoZSB2YWx1ZSBvZiBhbiBleHRyYSBIVFRQIGhlYWRlclxuKlxuKiBAcGFyYW0gbmFtZSB0aGUgaGVhZGVyIGZpZWxkIG5hbWVcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuZ2V0RXh0cmFIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmV4dHJhSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4qIFJlbW92ZSBhbiBleHRyYSBmaWVsZCBmcm9tIHRoZSBIVFRQIHJlcXVlc3RcbipcbiogQHBhcmFtIG5hbWUgdGhlIGhlYWRlciBmaWVsZCBuYW1lXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnVuc2V0RXh0cmFIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLmV4dHJhSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4qIEF1Z21lbnQgc2VudCB4LWFsZ29saWEtYWdlbnQgd2l0aCBtb3JlIGRhdGEsIGVhY2ggYWdlbnQgcGFydFxuKiBpcyBhdXRvbWF0aWNhbGx5IHNlcGFyYXRlZCBmcm9tIHRoZSBvdGhlcnMgYnkgYSBzZW1pY29sb247XG4qXG4qIEBwYXJhbSBhbGdvbGlhQWdlbnQgdGhlIGFnZW50IHRvIGFkZFxuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5hZGRBbGdvbGlhQWdlbnQgPSBmdW5jdGlvbihhbGdvbGlhQWdlbnQpIHtcbiAgaWYgKHRoaXMuX3VhLmluZGV4T2YoJzsnICsgYWxnb2xpYUFnZW50KSA9PT0gLTEpIHtcbiAgICB0aGlzLl91YSArPSAnOycgKyBhbGdvbGlhQWdlbnQ7XG4gIH1cbn07XG5cbi8qXG4gKiBXcmFwcGVyIHRoYXQgdHJ5IGFsbCBob3N0cyB0byBtYXhpbWl6ZSB0aGUgcXVhbGl0eSBvZiBzZXJ2aWNlXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fanNvblJlcXVlc3QgPSBmdW5jdGlvbihpbml0aWFsT3B0cykge1xuICB0aGlzLl9jaGVja0FwcElkRGF0YSgpO1xuXG4gIHZhciByZXF1ZXN0RGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdhbGdvbGlhc2VhcmNoOicgKyBpbml0aWFsT3B0cy51cmwpO1xuXG4gIHZhciBib2R5O1xuICB2YXIgYWRkaXRpb25hbFVBID0gaW5pdGlhbE9wdHMuYWRkaXRpb25hbFVBIHx8ICcnO1xuICB2YXIgY2FjaGUgPSBpbml0aWFsT3B0cy5jYWNoZTtcbiAgdmFyIGNsaWVudCA9IHRoaXM7XG4gIHZhciB0cmllcyA9IDA7XG4gIHZhciB1c2luZ0ZhbGxiYWNrID0gZmFsc2U7XG4gIHZhciBoYXNGYWxsYmFjayA9IGNsaWVudC5fdXNlRmFsbGJhY2sgJiYgY2xpZW50Ll9yZXF1ZXN0LmZhbGxiYWNrICYmIGluaXRpYWxPcHRzLmZhbGxiYWNrO1xuICB2YXIgaGVhZGVycztcblxuICBpZiAoXG4gICAgdGhpcy5hcGlLZXkubGVuZ3RoID4gTUFYX0FQSV9LRVlfTEVOR1RIICYmXG4gICAgaW5pdGlhbE9wdHMuYm9keSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGluaXRpYWxPcHRzLmJvZHkucGFyYW1zICE9PSB1bmRlZmluZWQgfHwgLy8gaW5kZXguc2VhcmNoKClcbiAgICBpbml0aWFsT3B0cy5ib2R5LnJlcXVlc3RzICE9PSB1bmRlZmluZWQpIC8vIGNsaWVudC5zZWFyY2goKVxuICApIHtcbiAgICBpbml0aWFsT3B0cy5ib2R5LmFwaUtleSA9IHRoaXMuYXBpS2V5O1xuICAgIGhlYWRlcnMgPSB0aGlzLl9jb21wdXRlUmVxdWVzdEhlYWRlcnMoYWRkaXRpb25hbFVBLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHRoaXMuX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyhhZGRpdGlvbmFsVUEpO1xuICB9XG5cbiAgaWYgKGluaXRpYWxPcHRzLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGJvZHkgPSBzYWZlSlNPTlN0cmluZ2lmeShpbml0aWFsT3B0cy5ib2R5KTtcbiAgfVxuXG4gIHJlcXVlc3REZWJ1ZygncmVxdWVzdCBzdGFydCcpO1xuICB2YXIgZGVidWdEYXRhID0gW107XG5cbiAgZnVuY3Rpb24gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cykge1xuICAgIGNsaWVudC5fY2hlY2tBcHBJZERhdGEoKTtcblxuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBjYWNoZUlEO1xuXG4gICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUpIHtcbiAgICAgIGNhY2hlSUQgPSBpbml0aWFsT3B0cy51cmw7XG4gICAgfVxuXG4gICAgLy8gYXMgd2Ugc29tZXRpbWUgdXNlIFBPU1QgcmVxdWVzdHMgdG8gcGFzcyBwYXJhbWV0ZXJzIChsaWtlIHF1ZXJ5PSdhYScpLFxuICAgIC8vIHRoZSBjYWNoZUlEIG11c3QgYWxzbyBpbmNsdWRlIHRoZSBib2R5IHRvIGJlIGRpZmZlcmVudCBiZXR3ZWVuIGNhbGxzXG4gICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUgJiYgYm9keSkge1xuICAgICAgY2FjaGVJRCArPSAnX2JvZHlfJyArIHJlcU9wdHMuYm9keTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgY2FjaGUgZXhpc3RlbmNlXG4gICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUgJiYgY2FjaGUgJiYgY2FjaGVbY2FjaGVJRF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERlYnVnKCdzZXJ2aW5nIHJlc3BvbnNlIGZyb20gY2FjaGUnKTtcbiAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UucmVzb2x2ZShKU09OLnBhcnNlKGNhY2hlW2NhY2hlSURdKSk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgcmVhY2hlZCBtYXggdHJpZXNcbiAgICBpZiAodHJpZXMgPj0gY2xpZW50Lmhvc3RzW2luaXRpYWxPcHRzLmhvc3RUeXBlXS5sZW5ndGgpIHtcbiAgICAgIGlmICghaGFzRmFsbGJhY2sgfHwgdXNpbmdGYWxsYmFjaykge1xuICAgICAgICByZXF1ZXN0RGVidWcoJ2NvdWxkIG5vdCBnZXQgYW55IHJlc3BvbnNlJyk7XG4gICAgICAgIC8vIHRoZW4gc3RvcFxuICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdChuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbm5lY3QgdG8gdGhlIEFsZ29saWFTZWFyY2ggQVBJLicgK1xuICAgICAgICAgICcgU2VuZCBhbiBlbWFpbCB0byBzdXBwb3J0QGFsZ29saWEuY29tIHRvIHJlcG9ydCBhbmQgcmVzb2x2ZSB0aGUgaXNzdWUuJyArXG4gICAgICAgICAgJyBBcHBsaWNhdGlvbiBpZCB3YXM6ICcgKyBjbGllbnQuYXBwbGljYXRpb25JRCwge2RlYnVnRGF0YTogZGVidWdEYXRhfVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdERlYnVnKCdzd2l0Y2hpbmcgdG8gZmFsbGJhY2snKTtcblxuICAgICAgLy8gbGV0J3MgdHJ5IHRoZSBmYWxsYmFjayBzdGFydGluZyBmcm9tIGhlcmVcbiAgICAgIHRyaWVzID0gMDtcblxuICAgICAgLy8gbWV0aG9kLCB1cmwgYW5kIGJvZHkgYXJlIGZhbGxiYWNrIGRlcGVuZGVudFxuICAgICAgcmVxT3B0cy5tZXRob2QgPSBpbml0aWFsT3B0cy5mYWxsYmFjay5tZXRob2Q7XG4gICAgICByZXFPcHRzLnVybCA9IGluaXRpYWxPcHRzLmZhbGxiYWNrLnVybDtcbiAgICAgIHJlcU9wdHMuanNvbkJvZHkgPSBpbml0aWFsT3B0cy5mYWxsYmFjay5ib2R5O1xuICAgICAgaWYgKHJlcU9wdHMuanNvbkJvZHkpIHtcbiAgICAgICAgcmVxT3B0cy5ib2R5ID0gc2FmZUpTT05TdHJpbmdpZnkocmVxT3B0cy5qc29uQm9keSk7XG4gICAgICB9XG4gICAgICAvLyByZS1jb21wdXRlIGhlYWRlcnMsIHRoZXkgY291bGQgYmUgb21pdHRpbmcgdGhlIEFQSSBLRVlcbiAgICAgIGhlYWRlcnMgPSBjbGllbnQuX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyhhZGRpdGlvbmFsVUEpO1xuXG4gICAgICByZXFPcHRzLnRpbWVvdXRzID0gY2xpZW50Ll9nZXRUaW1lb3V0c0ZvclJlcXVlc3QoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgY2xpZW50Ll9zZXRIb3N0SW5kZXhCeVR5cGUoMCwgaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgdXNpbmdGYWxsYmFjayA9IHRydWU7IC8vIHRoZSBjdXJyZW50IHJlcXVlc3QgaXMgbm93IHVzaW5nIGZhbGxiYWNrXG4gICAgICByZXR1cm4gZG9SZXF1ZXN0KGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjaywgcmVxT3B0cyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRIb3N0ID0gY2xpZW50Ll9nZXRIb3N0QnlUeXBlKGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcblxuICAgIHZhciB1cmwgPSBjdXJyZW50SG9zdCArIHJlcU9wdHMudXJsO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYm9keTogcmVxT3B0cy5ib2R5LFxuICAgICAganNvbkJvZHk6IHJlcU9wdHMuanNvbkJvZHksXG4gICAgICBtZXRob2Q6IHJlcU9wdHMubWV0aG9kLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIHRpbWVvdXRzOiByZXFPcHRzLnRpbWVvdXRzLFxuICAgICAgZGVidWc6IHJlcXVlc3REZWJ1Z1xuICAgIH07XG5cbiAgICByZXF1ZXN0RGVidWcoJ21ldGhvZDogJXMsIHVybDogJXMsIGhlYWRlcnM6ICVqLCB0aW1lb3V0czogJWQnLFxuICAgICAgb3B0aW9ucy5tZXRob2QsIHVybCwgb3B0aW9ucy5oZWFkZXJzLCBvcHRpb25zLnRpbWVvdXRzKTtcblxuICAgIGlmIChyZXF1ZXN0ZXIgPT09IGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjaykge1xuICAgICAgcmVxdWVzdERlYnVnKCd1c2luZyBmYWxsYmFjaycpO1xuICAgIH1cblxuICAgIC8vIGByZXF1ZXN0ZXJgIGlzIGFueSBvZiB0aGlzLl9yZXF1ZXN0IG9yIHRoaXMuX3JlcXVlc3QuZmFsbGJhY2tcbiAgICAvLyB0aHVzIGl0IG5lZWRzIHRvIGJlIGNhbGxlZCB1c2luZyB0aGUgY2xpZW50IGFzIGNvbnRleHRcbiAgICByZXR1cm4gcmVxdWVzdGVyLmNhbGwoY2xpZW50LCB1cmwsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcywgdHJ5RmFsbGJhY2spO1xuXG4gICAgZnVuY3Rpb24gc3VjY2VzcyhodHRwUmVzcG9uc2UpIHtcbiAgICAgIC8vIGNvbXB1dGUgdGhlIHN0YXR1cyBvZiB0aGUgcmVzcG9uc2UsXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiBpbiBicm93c2VyIG1vZGUsIHVzaW5nIFhEUiBvciBKU09OUCwgd2UgaGF2ZSBubyBzdGF0dXNDb2RlIGF2YWlsYWJsZVxuICAgICAgLy8gU28gd2UgcmVseSBvbiBvdXIgQVBJIHJlc3BvbnNlIGBzdGF0dXNgIHByb3BlcnR5LlxuICAgICAgLy8gQnV0IGB3YWl0VGFza2AgY2FuIHNldCBhIGBzdGF0dXNgIHByb3BlcnR5IHdoaWNoIGlzIG5vdCB0aGUgc3RhdHVzQ29kZSAoaXQncyB0aGUgdGFzayBzdGF0dXMpXG4gICAgICAvLyBTbyB3ZSBjaGVjayBpZiB0aGVyZSdzIGEgYG1lc3NhZ2VgIGFsb25nIGBzdGF0dXNgIGFuZCBpdCBtZWFucyBpdCdzIGFuIGVycm9yXG4gICAgICAvL1xuICAgICAgLy8gVGhhdCdzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgaGF2ZSBhIHJlc3BvbnNlLnN0YXR1cyB0aGF0J3Mgbm90IHRoZSBodHRwIHN0YXR1c0NvZGVcbiAgICAgIHZhciBzdGF0dXMgPSBodHRwUmVzcG9uc2UgJiYgaHR0cFJlc3BvbnNlLmJvZHkgJiYgaHR0cFJlc3BvbnNlLmJvZHkubWVzc2FnZSAmJiBodHRwUmVzcG9uc2UuYm9keS5zdGF0dXMgfHxcblxuICAgICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCB0byBjaGVjayB0aGUgcmVxdWVzdCBzdGF0dXNDb2RlIEFGVEVSIHRoZSBib2R5IGV2ZW50dWFsXG4gICAgICAgIC8vIHN0YXR1c0NvZGUgYmVjYXVzZSBzb21lIGltcGxlbWVudGF0aW9ucyAoalF1ZXJ5IFhEb21haW5SZXF1ZXN0IHRyYW5zcG9ydCkgbWF5XG4gICAgICAgIC8vIHNlbmQgc3RhdHVzQ29kZSAyMDAgd2hpbGUgd2UgaGFkIGFuIGVycm9yXG4gICAgICAgIGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlIHx8XG5cbiAgICAgICAgLy8gV2hlbiBpbiBicm93c2VyIG1vZGUsIHVzaW5nIFhEUiBvciBKU09OUFxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIHN1Y2Nlc3Mgd2hlbiBubyBlcnJvciAobm8gcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLm1lc3NhZ2UpXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIEpTT04ucGFyc2UoKSBlcnJvciB0aGVuIGJvZHkgaXMgbnVsbCBhbmQgaXQgZmFpbHNcbiAgICAgICAgaHR0cFJlc3BvbnNlICYmIGh0dHBSZXNwb25zZS5ib2R5ICYmIDIwMDtcblxuICAgICAgcmVxdWVzdERlYnVnKCdyZWNlaXZlZCByZXNwb25zZTogc3RhdHVzQ29kZTogJXMsIGNvbXB1dGVkIHN0YXR1c0NvZGU6ICVkLCBoZWFkZXJzOiAlaicsXG4gICAgICAgIGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLCBzdGF0dXMsIGh0dHBSZXNwb25zZS5oZWFkZXJzKTtcblxuICAgICAgdmFyIGh0dHBSZXNwb25zZU9rID0gTWF0aC5mbG9vcihzdGF0dXMgLyAxMDApID09PSAyO1xuXG4gICAgICB2YXIgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBkZWJ1Z0RhdGEucHVzaCh7XG4gICAgICAgIGN1cnJlbnRIb3N0OiBjdXJyZW50SG9zdCxcbiAgICAgICAgaGVhZGVyczogcmVtb3ZlQ3JlZGVudGlhbHMoaGVhZGVycyksXG4gICAgICAgIGNvbnRlbnQ6IGJvZHkgfHwgbnVsbCxcbiAgICAgICAgY29udGVudExlbmd0aDogYm9keSAhPT0gdW5kZWZpbmVkID8gYm9keS5sZW5ndGggOiBudWxsLFxuICAgICAgICBtZXRob2Q6IHJlcU9wdHMubWV0aG9kLFxuICAgICAgICB0aW1lb3V0czogcmVxT3B0cy50aW1lb3V0cyxcbiAgICAgICAgdXJsOiByZXFPcHRzLnVybCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaHR0cFJlc3BvbnNlT2spIHtcbiAgICAgICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUgJiYgY2FjaGUpIHtcbiAgICAgICAgICBjYWNoZVtjYWNoZUlEXSA9IGh0dHBSZXNwb25zZS5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmJvZHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG91bGRSZXRyeSA9IE1hdGguZmxvb3Ioc3RhdHVzIC8gMTAwKSAhPT0gNDtcblxuICAgICAgaWYgKHNob3VsZFJldHJ5KSB7XG4gICAgICAgIHRyaWVzICs9IDE7XG4gICAgICAgIHJldHVybiByZXRyeVJlcXVlc3QoKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdERlYnVnKCd1bnJlY292ZXJhYmxlIGVycm9yJyk7XG5cbiAgICAgIC8vIG5vIHN1Y2Nlc3MgYW5kIG5vIHJldHJ5ID0+IGZhaWxcbiAgICAgIHZhciB1bnJlY292ZXJhYmxlRXJyb3IgPSBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihcbiAgICAgICAgaHR0cFJlc3BvbnNlLmJvZHkgJiYgaHR0cFJlc3BvbnNlLmJvZHkubWVzc2FnZSwge2RlYnVnRGF0YTogZGVidWdEYXRhLCBzdGF0dXNDb2RlOiBzdGF0dXN9XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdCh1bnJlY292ZXJhYmxlRXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyeUZhbGxiYWNrKGVycikge1xuICAgICAgLy8gZXJyb3IgY2FzZXM6XG4gICAgICAvLyAgV2hpbGUgbm90IGluIGZhbGxiYWNrIG1vZGU6XG4gICAgICAvLyAgICAtIENPUlMgbm90IHN1cHBvcnRlZFxuICAgICAgLy8gICAgLSBuZXR3b3JrIGVycm9yXG4gICAgICAvLyAgV2hpbGUgaW4gZmFsbGJhY2sgbW9kZTpcbiAgICAgIC8vICAgIC0gdGltZW91dFxuICAgICAgLy8gICAgLSBuZXR3b3JrIGVycm9yXG4gICAgICAvLyAgICAtIGJhZGx5IGZvcm1hdHRlZCBKU09OUCAoc2NyaXB0IGxvYWRlZCwgZGlkIG5vdCBjYWxsIG91ciBjYWxsYmFjaylcbiAgICAgIC8vICBJbiBib3RoIGNhc2VzOlxuICAgICAgLy8gICAgLSB1bmNhdWdodCBleGNlcHRpb24gb2NjdXJzIChUeXBlRXJyb3IpXG4gICAgICByZXF1ZXN0RGVidWcoJ2Vycm9yOiAlcywgc3RhY2s6ICVzJywgZXJyLm1lc3NhZ2UsIGVyci5zdGFjayk7XG5cbiAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGRlYnVnRGF0YS5wdXNoKHtcbiAgICAgICAgY3VycmVudEhvc3Q6IGN1cnJlbnRIb3N0LFxuICAgICAgICBoZWFkZXJzOiByZW1vdmVDcmVkZW50aWFscyhoZWFkZXJzKSxcbiAgICAgICAgY29udGVudDogYm9keSB8fCBudWxsLFxuICAgICAgICBjb250ZW50TGVuZ3RoOiBib2R5ICE9PSB1bmRlZmluZWQgPyBib2R5Lmxlbmd0aCA6IG51bGwsXG4gICAgICAgIG1ldGhvZDogcmVxT3B0cy5tZXRob2QsXG4gICAgICAgIHRpbWVvdXRzOiByZXFPcHRzLnRpbWVvdXRzLFxuICAgICAgICB1cmw6IHJlcU9wdHMudXJsLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogZW5kVGltZSxcbiAgICAgICAgZHVyYXRpb246IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKSkge1xuICAgICAgICBlcnIgPSBuZXcgZXJyb3JzLlVua25vd24oZXJyICYmIGVyci5tZXNzYWdlLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICB0cmllcyArPSAxO1xuXG4gICAgICAvLyBzdG9wIHRoZSByZXF1ZXN0IGltcGxlbWVudGF0aW9uIHdoZW46XG4gICAgICBpZiAoXG4gICAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgdGhpcyBlcnJvcixcbiAgICAgICAgLy8gaXQgY29tZXMgZnJvbSBhIHRocm93IGluIHNvbWUgb3RoZXIgcGllY2Ugb2YgY29kZVxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBlcnJvcnMuVW5rbm93biB8fFxuXG4gICAgICAgIC8vIHNlcnZlciBzZW50IHVucGFyc2FibGUgSlNPTlxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBlcnJvcnMuVW5wYXJzYWJsZUpTT04gfHxcblxuICAgICAgICAvLyBtYXggdHJpZXMgYW5kIGFscmVhZHkgdXNpbmcgZmFsbGJhY2sgb3Igbm8gZmFsbGJhY2tcbiAgICAgICAgdHJpZXMgPj0gY2xpZW50Lmhvc3RzW2luaXRpYWxPcHRzLmhvc3RUeXBlXS5sZW5ndGggJiZcbiAgICAgICAgKHVzaW5nRmFsbGJhY2sgfHwgIWhhc0ZhbGxiYWNrKSkge1xuICAgICAgICAvLyBzdG9wIHJlcXVlc3QgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgY29tbWFuZFxuICAgICAgICBlcnIuZGVidWdEYXRhID0gZGVidWdEYXRhO1xuICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIGEgdGltZW91dCBvY2N1cmVkLCByZXRyeSBieSByYWlzaW5nIHRpbWVvdXRcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBlcnJvcnMuUmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHJldHJ5UmVxdWVzdFdpdGhIaWdoZXJUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRyeVJlcXVlc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXRyeVJlcXVlc3QoKSB7XG4gICAgICByZXF1ZXN0RGVidWcoJ3JldHJ5aW5nIHJlcXVlc3QnKTtcbiAgICAgIGNsaWVudC5faW5jcmVtZW50SG9zdEluZGV4KGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcbiAgICAgIHJldHVybiBkb1JlcXVlc3QocmVxdWVzdGVyLCByZXFPcHRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXRyeVJlcXVlc3RXaXRoSGlnaGVyVGltZW91dCgpIHtcbiAgICAgIHJlcXVlc3REZWJ1ZygncmV0cnlpbmcgcmVxdWVzdCB3aXRoIGhpZ2hlciB0aW1lb3V0Jyk7XG4gICAgICBjbGllbnQuX2luY3JlbWVudEhvc3RJbmRleChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICBjbGllbnQuX2luY3JlbWVudFRpbWVvdXRNdWx0aXBsZXIoKTtcbiAgICAgIHJlcU9wdHMudGltZW91dHMgPSBjbGllbnQuX2dldFRpbWVvdXRzRm9yUmVxdWVzdChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICByZXR1cm4gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb21pc2UgPSBkb1JlcXVlc3QoXG4gICAgY2xpZW50Ll9yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGluaXRpYWxPcHRzLnVybCxcbiAgICAgIG1ldGhvZDogaW5pdGlhbE9wdHMubWV0aG9kLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGpzb25Cb2R5OiBpbml0aWFsT3B0cy5ib2R5LFxuICAgICAgdGltZW91dHM6IGNsaWVudC5fZ2V0VGltZW91dHNGb3JSZXF1ZXN0KGluaXRpYWxPcHRzLmhvc3RUeXBlKVxuICAgIH1cbiAgKTtcblxuICAvLyBlaXRoZXIgd2UgaGF2ZSBhIGNhbGxiYWNrXG4gIC8vIGVpdGhlciB3ZSBhcmUgdXNpbmcgcHJvbWlzZXNcbiAgaWYgKHR5cGVvZiBpbml0aWFsT3B0cy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiBva0NiKGNvbnRlbnQpIHtcbiAgICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBpbml0aWFsT3B0cy5jYWxsYmFjayhudWxsLCBjb250ZW50KTtcbiAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICB9LCBmdW5jdGlvbiBub29rQ2IoZXJyKSB7XG4gICAgICBleGl0UHJvbWlzZShmdW5jdGlvbigpIHtcbiAgICAgICAgaW5pdGlhbE9wdHMuY2FsbGJhY2soZXJyKTtcbiAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLypcbiogVHJhbnNmb3JtIHNlYXJjaCBwYXJhbSBvYmplY3QgaW4gcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSB7b2JqZWN0fSBhcmdzIGFyZ3VtZW50cyB0byBhZGQgdG8gdGhlIGN1cnJlbnQgcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMgY3VycmVudCBxdWVyeSBzdHJpbmdcbiogQHJldHVybiB7c3RyaW5nfSB0aGUgZmluYWwgcXVlcnkgc3RyaW5nXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbihhcmdzLCBwYXJhbXMpIHtcbiAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gYXJncykge1xuICAgIGlmIChrZXkgIT09IG51bGwgJiYgYXJnc1trZXldICE9PSB1bmRlZmluZWQgJiYgYXJncy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBwYXJhbXMgKz0gcGFyYW1zID09PSAnJyA/ICcnIDogJyYnO1xuICAgICAgcGFyYW1zICs9IGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnc1trZXldKSA9PT0gJ1tvYmplY3QgQXJyYXldJyA/IHNhZmVKU09OU3RyaW5naWZ5KGFyZ3Nba2V5XSkgOiBhcmdzW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9jb21wdXRlUmVxdWVzdEhlYWRlcnMgPSBmdW5jdGlvbihhZGRpdGlvbmFsVUEsIHdpdGhBUElLZXkpIHtcbiAgdmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbiAgdmFyIHVhID0gYWRkaXRpb25hbFVBID9cbiAgICB0aGlzLl91YSArICc7JyArIGFkZGl0aW9uYWxVQSA6XG4gICAgdGhpcy5fdWE7XG5cbiAgdmFyIHJlcXVlc3RIZWFkZXJzID0ge1xuICAgICd4LWFsZ29saWEtYWdlbnQnOiB1YSxcbiAgICAneC1hbGdvbGlhLWFwcGxpY2F0aW9uLWlkJzogdGhpcy5hcHBsaWNhdGlvbklEXG4gIH07XG5cbiAgLy8gYnJvd3NlciB3aWxsIGlubGluZSBoZWFkZXJzIGluIHRoZSB1cmwsIG5vZGUuanMgd2lsbCB1c2UgaHR0cCBoZWFkZXJzXG4gIC8vIGJ1dCBpbiBzb21lIHNpdHVhdGlvbnMsIHRoZSBBUEkgS0VZIHdpbGwgYmUgdG9vIGxvbmcgKGJpZyBzZWN1cmVkIEFQSSBrZXlzKVxuICAvLyBzbyBpZiB0aGUgcmVxdWVzdCBpcyBhIFBPU1QgYW5kIHRoZSBLRVkgaXMgdmVyeSBsb25nLCB3ZSB3aWxsIGJlIGFza2VkIHRvIG5vdCBwdXRcbiAgLy8gaXQgaW50byBoZWFkZXJzIGJ1dCBpbiB0aGUgSlNPTiBib2R5XG4gIGlmICh3aXRoQVBJS2V5ICE9PSBmYWxzZSkge1xuICAgIHJlcXVlc3RIZWFkZXJzWyd4LWFsZ29saWEtYXBpLWtleSddID0gdGhpcy5hcGlLZXk7XG4gIH1cblxuICBpZiAodGhpcy51c2VyVG9rZW4pIHtcbiAgICByZXF1ZXN0SGVhZGVyc1sneC1hbGdvbGlhLXVzZXJ0b2tlbiddID0gdGhpcy51c2VyVG9rZW47XG4gIH1cblxuICBpZiAodGhpcy5zZWN1cml0eVRhZ3MpIHtcbiAgICByZXF1ZXN0SGVhZGVyc1sneC1hbGdvbGlhLXRhZ2ZpbHRlcnMnXSA9IHRoaXMuc2VjdXJpdHlUYWdzO1xuICB9XG5cbiAgZm9yRWFjaCh0aGlzLmV4dHJhSGVhZGVycywgZnVuY3Rpb24gYWRkVG9SZXF1ZXN0SGVhZGVycyh2YWx1ZSwga2V5KSB7XG4gICAgcmVxdWVzdEhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gcmVxdWVzdEhlYWRlcnM7XG59O1xuXG4vKipcbiAqIFNlYXJjaCB0aHJvdWdoIG11bHRpcGxlIGluZGljZXMgYXQgdGhlIHNhbWUgdGltZVxuICogQHBhcmFtICB7T2JqZWN0W119ICAgcXVlcmllcyAgQW4gYXJyYXkgb2YgcXVlcmllcyB5b3Ugd2FudCB0byBydW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcmllc1tdLmluZGV4TmFtZSBUaGUgaW5kZXggbmFtZSB5b3Ugd2FudCB0byB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcXVlcmllc1tdLnF1ZXJ5XSBUaGUgcXVlcnkgdG8gaXNzdWUgb24gdGhpcyBpbmRleC4gQ2FuIGFsc28gYmUgcGFzc2VkIGludG8gYHBhcmFtc2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyaWVzW10ucGFyYW1zIEFueSBzZWFyY2ggcGFyYW0gbGlrZSBoaXRzUGVyUGFnZSwgLi5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWRcbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcmllcywgb3B0cywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LnNlYXJjaChhcnJheU9mUXVlcmllc1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShxdWVyaWVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBjbGllbnQgPSB0aGlzO1xuXG4gIHZhciBwb3N0T2JqID0ge1xuICAgIHJlcXVlc3RzOiBtYXAocXVlcmllcywgZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3QocXVlcnkpIHtcbiAgICAgIHZhciBwYXJhbXMgPSAnJztcblxuICAgICAgLy8gYWxsb3cgcXVlcnkucXVlcnlcbiAgICAgIC8vIHNvIHdlIGFyZSBtaW1pY2luZyB0aGUgaW5kZXguc2VhcmNoKHF1ZXJ5LCBwYXJhbXMpIG1ldGhvZFxuICAgICAgLy8ge2luZGV4TmFtZTosIHF1ZXJ5OiwgcGFyYW1zOn1cbiAgICAgIGlmIChxdWVyeS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcyArPSAncXVlcnk9JyArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeS5xdWVyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4TmFtZTogcXVlcnkuaW5kZXhOYW1lLFxuICAgICAgICBwYXJhbXM6IGNsaWVudC5fZ2V0U2VhcmNoUGFyYW1zKHF1ZXJ5LnBhcmFtcywgcGFyYW1zKVxuICAgICAgfTtcbiAgICB9KVxuICB9O1xuXG4gIHZhciBKU09OUFBhcmFtcyA9IG1hcChwb3N0T2JqLnJlcXVlc3RzLCBmdW5jdGlvbiBwcmVwYXJlSlNPTlBQYXJhbXMocmVxdWVzdCwgcmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RJZCArICc9JyArXG4gICAgICBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQocmVxdWVzdC5pbmRleE5hbWUpICsgJz8nICtcbiAgICAgICAgcmVxdWVzdC5wYXJhbXNcbiAgICAgICk7XG4gIH0pLmpvaW4oJyYnKTtcblxuICB2YXIgdXJsID0gJy8xL2luZGV4ZXMvKi9xdWVyaWVzJztcblxuICBpZiAob3B0cy5zdHJhdGVneSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJsICs9ICc/c3RyYXRlZ3k9JyArIG9wdHMuc3RyYXRlZ3k7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdXJsLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBmYWxsYmFjazoge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogJy8xL2luZGV4ZXMvKicsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHBhcmFtczogSlNPTlBQYXJhbXNcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBleHRyYSBzZWN1cml0eSB0YWdGaWx0ZXJzIGhlYWRlclxuICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHRhZ3MgVGhlIGxpc3Qgb2YgdGFncyBkZWZpbmluZyB0aGUgY3VycmVudCBzZWN1cml0eSBmaWx0ZXJzXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRTZWN1cml0eVRhZ3MgPSBmdW5jdGlvbih0YWdzKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFncykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICB2YXIgc3RyVGFncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YWdzW2ldKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICB2YXIgb3JlZFRhZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0YWdzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgb3JlZFRhZ3MucHVzaCh0YWdzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJUYWdzLnB1c2goJygnICsgb3JlZFRhZ3Muam9pbignLCcpICsgJyknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0clRhZ3MucHVzaCh0YWdzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGFncyA9IHN0clRhZ3Muam9pbignLCcpO1xuICB9XG5cbiAgdGhpcy5zZWN1cml0eVRhZ3MgPSB0YWdzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGV4dHJhIHVzZXIgdG9rZW4gaGVhZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlclRva2VuIFRoZSB0b2tlbiBpZGVudGlmeWluZyBhIHVuaXEgdXNlciAodXNlZCB0byBhcHBseSByYXRlIGxpbWl0cylcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldFVzZXJUb2tlbiA9IGZ1bmN0aW9uKHVzZXJUb2tlbikge1xuICB0aGlzLnVzZXJUb2tlbiA9IHVzZXJUb2tlbjtcbn07XG5cbi8qKlxuICogQ2xlYXIgYWxsIHF1ZXJpZXMgaW4gY2xpZW50J3MgY2FjaGVcbiAqIEByZXR1cm4gdW5kZWZpbmVkXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2FjaGUgPSB7fTtcbn07XG5cbi8qKlxuKiBTZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYSByZXF1ZXN0IGNhbiB0YWtlIGJlZm9yZSBhdXRvbWF0aWNhbGx5IGJlaW5nIHRlcm1pbmF0ZWQuXG4qIEBkZXByZWNhdGVkXG4qIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0UmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbihtaWxsaXNlY29uZHMpIHtcbiAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgIHRoaXMuX3RpbWVvdXRzLmNvbm5lY3QgPSB0aGlzLl90aW1lb3V0cy5yZWFkID0gdGhpcy5fdGltZW91dHMud3JpdGUgPSBtaWxsaXNlY29uZHM7XG4gIH1cbn07XG5cbi8qKlxuKiBTZXQgdGhlIHRocmVlIGRpZmZlcmVudCAoY29ubmVjdCwgcmVhZCwgd3JpdGUpIHRpbWVvdXRzIHRvIGJlIHVzZWQgd2hlbiByZXF1ZXN0aW5nXG4qIEBwYXJhbSB7T2JqZWN0fSB0aW1lb3V0c1xuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKHRpbWVvdXRzKSB7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGltZW91dHM7XG59O1xuXG4vKipcbiogR2V0IHRoZSB0aHJlZSBkaWZmZXJlbnQgKGNvbm5lY3QsIHJlYWQsIHdyaXRlKSB0aW1lb3V0cyB0byBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZ1xuKiBAcGFyYW0ge09iamVjdH0gdGltZW91dHNcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuZ2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbWVvdXRzO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRBcHBJZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSBzdG9yZS5nZXQodGhpcy5hcHBsaWNhdGlvbklEKTtcbiAgaWYgKGRhdGEgIT09IG51bGwpIHRoaXMuX2NhY2hlQXBwSWREYXRhKGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fc2V0QXBwSWREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBkYXRhLmxhc3RDaGFuZ2UgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB0aGlzLl9jYWNoZUFwcElkRGF0YShkYXRhKTtcbiAgcmV0dXJuIHN0b3JlLnNldCh0aGlzLmFwcGxpY2F0aW9uSUQsIGRhdGEpO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9jaGVja0FwcElkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2dldEFwcElkRGF0YSgpO1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgaWYgKGRhdGEgPT09IG51bGwgfHwgbm93IC0gZGF0YS5sYXN0Q2hhbmdlID4gUkVTRVRfQVBQX0RBVEFfVElNRVIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzZXRJbml0aWFsQXBwSWREYXRhKGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX3Jlc2V0SW5pdGlhbEFwcElkRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG5ld0RhdGEgPSBkYXRhIHx8IHt9O1xuICBuZXdEYXRhLmhvc3RJbmRleGVzID0ge3JlYWQ6IDAsIHdyaXRlOiAwfTtcbiAgbmV3RGF0YS50aW1lb3V0TXVsdGlwbGllciA9IDE7XG4gIG5ld0RhdGEuc2h1ZmZsZVJlc3VsdCA9IG5ld0RhdGEuc2h1ZmZsZVJlc3VsdCB8fCBzaHVmZmxlKFsxLCAyLCAzXSk7XG4gIHJldHVybiB0aGlzLl9zZXRBcHBJZERhdGEobmV3RGF0YSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2NhY2hlQXBwSWREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl9ob3N0SW5kZXhlcyA9IGRhdGEuaG9zdEluZGV4ZXM7XG4gIHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyID0gZGF0YS50aW1lb3V0TXVsdGlwbGllcjtcbiAgdGhpcy5fc2h1ZmZsZVJlc3VsdCA9IGRhdGEuc2h1ZmZsZVJlc3VsdDtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fcGFydGlhbEFwcElkRGF0YVVwZGF0ZSA9IGZ1bmN0aW9uKG5ld0RhdGEpIHtcbiAgdmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG4gIHZhciBjdXJyZW50RGF0YSA9IHRoaXMuX2dldEFwcElkRGF0YSgpO1xuICBmb3JlYWNoKG5ld0RhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBjdXJyZW50RGF0YVtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLl9zZXRBcHBJZERhdGEoY3VycmVudERhdGEpO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRIb3N0QnlUeXBlID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuaG9zdHNbaG9zdFR5cGVdW3RoaXMuX2dldEhvc3RJbmRleEJ5VHlwZShob3N0VHlwZSldO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRUaW1lb3V0TXVsdGlwbGllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGltZW91dE11bHRpcGxpZXI7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldEhvc3RJbmRleEJ5VHlwZSA9IGZ1bmN0aW9uKGhvc3RUeXBlKSB7XG4gIHJldHVybiB0aGlzLl9ob3N0SW5kZXhlc1tob3N0VHlwZV07XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX3NldEhvc3RJbmRleEJ5VHlwZSA9IGZ1bmN0aW9uKGhvc3RJbmRleCwgaG9zdFR5cGUpIHtcbiAgdmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuICB2YXIgbmV3SG9zdEluZGV4ZXMgPSBjbG9uZSh0aGlzLl9ob3N0SW5kZXhlcyk7XG4gIG5ld0hvc3RJbmRleGVzW2hvc3RUeXBlXSA9IGhvc3RJbmRleDtcbiAgdGhpcy5fcGFydGlhbEFwcElkRGF0YVVwZGF0ZSh7aG9zdEluZGV4ZXM6IG5ld0hvc3RJbmRleGVzfSk7XG4gIHJldHVybiBob3N0SW5kZXg7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2luY3JlbWVudEhvc3RJbmRleCA9IGZ1bmN0aW9uKGhvc3RUeXBlKSB7XG4gIHJldHVybiB0aGlzLl9zZXRIb3N0SW5kZXhCeVR5cGUoXG4gICAgKHRoaXMuX2dldEhvc3RJbmRleEJ5VHlwZShob3N0VHlwZSkgKyAxKSAlIHRoaXMuaG9zdHNbaG9zdFR5cGVdLmxlbmd0aCwgaG9zdFR5cGVcbiAgKTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5faW5jcmVtZW50VGltZW91dE11bHRpcGxlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGltZW91dE11bHRpcGxpZXIgPSBNYXRoLm1heCh0aGlzLl90aW1lb3V0TXVsdGlwbGllciArIDEsIDQpO1xuICByZXR1cm4gdGhpcy5fcGFydGlhbEFwcElkRGF0YVVwZGF0ZSh7dGltZW91dE11bHRpcGxpZXI6IHRpbWVvdXRNdWx0aXBsaWVyfSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldFRpbWVvdXRzRm9yUmVxdWVzdCA9IGZ1bmN0aW9uKGhvc3RUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgY29ubmVjdDogdGhpcy5fdGltZW91dHMuY29ubmVjdCAqIHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyLFxuICAgIGNvbXBsZXRlOiB0aGlzLl90aW1lb3V0c1tob3N0VHlwZV0gKiB0aGlzLl90aW1lb3V0TXVsdGlwbGllclxuICB9O1xufTtcblxuZnVuY3Rpb24gcHJlcGFyZUhvc3QocHJvdG9jb2wpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXBhcmUoaG9zdCkge1xuICAgIHJldHVybiBwcm90b2NvbCArICcvLycgKyBob3N0LnRvTG93ZXJDYXNlKCk7XG4gIH07XG59XG5cbi8vIFByb3RvdHlwZS5qcyA8IDEuNywgYSB3aWRlbHkgdXNlZCBsaWJyYXJ5LCBkZWZpbmVzIGEgd2VpcmRcbi8vIEFycmF5LnByb3RvdHlwZS50b0pTT04gZnVuY3Rpb24gdGhhdCB3aWxsIGZhaWwgdG8gc3RyaW5naWZ5IG91ciBjb250ZW50XG4vLyBhcHByb3ByaWF0ZWx5XG4vLyByZWZzOlxuLy8gICAtIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy9wcm90b3R5cGUtY29yZS9FLVNBVnZWX1Y5UVxuLy8gICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zc3RlcGhlbnNvbi9wcm90b3R5cGUvY29tbWl0LzAzOGEyOTg1YTcwNTkzYzFhODZjMjMwZmFkYmRmZTJlNDg5OGE0OGNcbi8vICAgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQ4NDQxLzE0NzA3OVxuZnVuY3Rpb24gc2FmZUpTT05TdHJpbmdpZnkob2JqKSB7XG4gIC8qIGVzbGludCBuby1leHRlbmQtbmF0aXZlOjAgKi9cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLnRvSlNPTiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH1cblxuICB2YXIgdG9KU09OID0gQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbiAgZGVsZXRlIEFycmF5LnByb3RvdHlwZS50b0pTT047XG4gIHZhciBvdXQgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICBBcnJheS5wcm90b3R5cGUudG9KU09OID0gdG9KU09OO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIHRlbXBvcmFyeVZhbHVlO1xuICB2YXIgcmFuZG9tSW5kZXg7XG5cbiAgLy8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cbiAgd2hpbGUgKGN1cnJlbnRJbmRleCAhPT0gMCkge1xuICAgIC8vIFBpY2sgYSByZW1haW5pbmcgZWxlbWVudC4uLlxuICAgIHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KTtcbiAgICBjdXJyZW50SW5kZXggLT0gMTtcblxuICAgIC8vIEFuZCBzd2FwIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICB0ZW1wb3JhcnlWYWx1ZSA9IGFycmF5W2N1cnJlbnRJbmRleF07XG4gICAgYXJyYXlbY3VycmVudEluZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcbiAgICBhcnJheVtyYW5kb21JbmRleF0gPSB0ZW1wb3JhcnlWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ3JlZGVudGlhbHMoaGVhZGVycykge1xuICB2YXIgbmV3SGVhZGVycyA9IHt9O1xuXG4gIGZvciAodmFyIGhlYWRlck5hbWUgaW4gaGVhZGVycykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgaGVhZGVyTmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgaWYgKGhlYWRlck5hbWUgPT09ICd4LWFsZ29saWEtYXBpLWtleScgfHwgaGVhZGVyTmFtZSA9PT0gJ3gtYWxnb2xpYS1hcHBsaWNhdGlvbi1pZCcpIHtcbiAgICAgICAgdmFsdWUgPSAnKipoaWRkZW4gZm9yIHNlY3VyaXR5IHB1cnBvc2VzKionO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgfVxuXG4gICAgICBuZXdIZWFkZXJzW2hlYWRlck5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0hlYWRlcnM7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0FsZ29saWFTZWFyY2hDb3JlLmpzIiwidmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxnb2xpYXNlYXJjaDpzcmMvaG9zdEluZGV4U3RhdGUuanMnKTtcbnZhciBsb2NhbFN0b3JhZ2VOYW1lc3BhY2UgPSAnYWxnb2xpYXNlYXJjaC1jbGllbnQtanMnO1xuXG52YXIgc3RvcmU7XG52YXIgbW9kdWxlU3RvcmUgPSB7XG4gIHN0YXRlOiB7fSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIGRhdGEpIHtcbiAgICB0aGlzLnN0YXRlW2tleV0gPSBkYXRhO1xuICAgIHJldHVybiB0aGlzLnN0YXRlW2tleV07XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVba2V5XSB8fCBudWxsO1xuICB9XG59O1xuXG52YXIgbG9jYWxTdG9yYWdlU3RvcmUgPSB7XG4gIHNldDogZnVuY3Rpb24oa2V5LCBkYXRhKSB7XG4gICAgbW9kdWxlU3RvcmUuc2V0KGtleSwgZGF0YSk7IC8vIGFsd2F5cyByZXBsaWNhdGUgbG9jYWxTdG9yYWdlU3RvcmUgdG8gbW9kdWxlU3RvcmUgaW4gY2FzZSBvZiBmYWlsdXJlXG5cbiAgICB0cnkge1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IEpTT04ucGFyc2UoZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdKTtcbiAgICAgIG5hbWVzcGFjZVtrZXldID0gZGF0YTtcbiAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSA9IEpTT04uc3RyaW5naWZ5KG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gbmFtZXNwYWNlW2tleV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZUZhaWx1cmUoa2V5LCBlKTtcbiAgICB9XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSlba2V5XSB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VGYWlsdXJlKGtleSwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2VGYWlsdXJlKGtleSwgZSkge1xuICBkZWJ1ZygnbG9jYWxTdG9yYWdlIGZhaWxlZCB3aXRoJywgZSk7XG4gIGNsZWFudXAoKTtcbiAgc3RvcmUgPSBtb2R1bGVTdG9yZTtcbiAgcmV0dXJuIHN0b3JlLmdldChrZXkpO1xufVxuXG5zdG9yZSA9IHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgPyBsb2NhbFN0b3JhZ2VTdG9yZSA6IG1vZHVsZVN0b3JlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0OiBnZXRPclNldCxcbiAgc2V0OiBnZXRPclNldCxcbiAgc3VwcG9ydHNMb2NhbFN0b3JhZ2U6IHN1cHBvcnRzTG9jYWxTdG9yYWdlXG59O1xuXG5mdW5jdGlvbiBnZXRPclNldChrZXksIGRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGtleSk7XG4gIH1cblxuICByZXR1cm4gc3RvcmUuc2V0KGtleSwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkge1xuICB0cnkge1xuICAgIGlmICgnbG9jYWxTdG9yYWdlJyBpbiBnbG9iYWwgJiZcbiAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UgIT09IG51bGwpIHtcbiAgICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdKSB7XG4gICAgICAgIC8vIGFjdHVhbCBjcmVhdGlvbiBvZiB0aGUgbmFtZXNwYWNlXG4gICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VOYW1lc3BhY2UsIEpTT04uc3RyaW5naWZ5KHt9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSW4gY2FzZSBvZiBhbnkgZXJyb3Igb24gbG9jYWxTdG9yYWdlLCB3ZSBjbGVhbiBvdXIgb3duIG5hbWVzcGFjZSwgdGhpcyBzaG91bGQgaGFuZGxlXG4vLyBxdW90YSBlcnJvcnMgd2hlbiBhIGxvdCBvZiBrZXlzICsgZGF0YSBhcmUgdXNlZFxuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgdHJ5IHtcbiAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obG9jYWxTdG9yYWdlTmFtZXNwYWNlKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9zdG9yZS5qcyIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9kZWJ1Zy9zcmMvZGVidWcuanMiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21zL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnZ2xvYmFsJyk7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlIHx8IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxuLy8gVGhpcyBpcyB0aGUgc3RhbmRhbG9uZSBicm93c2VyIGJ1aWxkIGVudHJ5IHBvaW50XG4vLyBCcm93c2VyIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBbGdvbGlhIFNlYXJjaCBKYXZhU2NyaXB0IGNsaWVudCxcbi8vIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LCBYRG9tYWluUmVxdWVzdCBhbmQgSlNPTlAgYXMgZmFsbGJhY2tcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlQWxnb2xpYXNlYXJjaChBbGdvbGlhU2VhcmNoLCB1YVN1ZmZpeCkge1xuICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuICB2YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG4gIHZhciBpbmxpbmVIZWFkZXJzID0gcmVxdWlyZSgnLi9pbmxpbmUtaGVhZGVycycpO1xuICB2YXIganNvbnBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9qc29ucC1yZXF1ZXN0Jyk7XG4gIHZhciBwbGFjZXMgPSByZXF1aXJlKCcuLi9wbGFjZXMuanMnKTtcbiAgdWFTdWZmaXggPSB1YVN1ZmZpeCB8fCAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZWJ1ZycpIHtcbiAgICByZXF1aXJlKCdkZWJ1ZycpLmVuYWJsZSgnYWxnb2xpYXNlYXJjaConKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsZ29saWFzZWFyY2goYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSB7XG4gICAgdmFyIGNsb25lRGVlcCA9IHJlcXVpcmUoJy4uL2Nsb25lLmpzJyk7XG5cbiAgICB2YXIgZ2V0RG9jdW1lbnRQcm90b2NvbCA9IHJlcXVpcmUoJy4vZ2V0LWRvY3VtZW50LXByb3RvY29sJyk7XG5cbiAgICBvcHRzID0gY2xvbmVEZWVwKG9wdHMgfHwge30pO1xuXG4gICAgaWYgKG9wdHMucHJvdG9jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0cy5wcm90b2NvbCA9IGdldERvY3VtZW50UHJvdG9jb2woKTtcbiAgICB9XG5cbiAgICBvcHRzLl91YSA9IG9wdHMuX3VhIHx8IGFsZ29saWFzZWFyY2gudWE7XG5cbiAgICByZXR1cm4gbmV3IEFsZ29saWFTZWFyY2hCcm93c2VyKGFwcGxpY2F0aW9uSUQsIGFwaUtleSwgb3B0cyk7XG4gIH1cblxuICBhbGdvbGlhc2VhcmNoLnZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uLmpzJyk7XG4gIGFsZ29saWFzZWFyY2gudWEgPSAnQWxnb2xpYSBmb3IgdmFuaWxsYSBKYXZhU2NyaXB0ICcgKyB1YVN1ZmZpeCArIGFsZ29saWFzZWFyY2gudmVyc2lvbjtcbiAgYWxnb2xpYXNlYXJjaC5pbml0UGxhY2VzID0gcGxhY2VzKGFsZ29saWFzZWFyY2gpO1xuXG4gIC8vIHdlIGV4cG9zZSBpbnRvIHdpbmRvdyBubyBtYXR0ZXIgaG93IHdlIGFyZSB1c2VkLCB0aGlzIHdpbGwgYWxsb3dcbiAgLy8gdXMgdG8gZWFzaWx5IGRlYnVnIGFueSB3ZWJzaXRlIHJ1bm5pbmcgYWxnb2xpYVxuICBnbG9iYWwuX19hbGdvbGlhID0ge1xuICAgIGRlYnVnOiByZXF1aXJlKCdkZWJ1ZycpLFxuICAgIGFsZ29saWFzZWFyY2g6IGFsZ29saWFzZWFyY2hcbiAgfTtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBoYXNYTUxIdHRwUmVxdWVzdDogJ1hNTEh0dHBSZXF1ZXN0JyBpbiBnbG9iYWwsXG4gICAgaGFzWERvbWFpblJlcXVlc3Q6ICdYRG9tYWluUmVxdWVzdCcgaW4gZ2xvYmFsXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaGFzWE1MSHR0cFJlcXVlc3QpIHtcbiAgICBzdXBwb3J0LmNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFsZ29saWFTZWFyY2hCcm93c2VyKCkge1xuICAgIC8vIGNhbGwgQWxnb2xpYVNlYXJjaCBjb25zdHJ1Y3RvclxuICAgIEFsZ29saWFTZWFyY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXRzKEFsZ29saWFTZWFyY2hCcm93c2VyLCBBbGdvbGlhU2VhcmNoKTtcblxuICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiB3cmFwUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIG5vIGNvcnMgb3IgWERvbWFpblJlcXVlc3QsIG5vIHJlcXVlc3RcbiAgICAgIGlmICghc3VwcG9ydC5jb3JzICYmICFzdXBwb3J0Lmhhc1hEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIC8vIHZlcnkgb2xkIGJyb3dzZXIsIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnMuTmV0d29yaygnQ09SUyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVybCA9IGlubGluZUhlYWRlcnModXJsLCBvcHRzLmhlYWRlcnMpO1xuXG4gICAgICB2YXIgYm9keSA9IG9wdHMuYm9keTtcbiAgICAgIHZhciByZXEgPSBzdXBwb3J0LmNvcnMgPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgdmFyIHJlcVRpbWVvdXQ7XG4gICAgICB2YXIgdGltZWRPdXQ7XG4gICAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAgIHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgb3B0cy50aW1lb3V0cy5jb25uZWN0KTtcbiAgICAgIC8vIHdlIHNldCBhbiBlbXB0eSBvbnByb2dyZXNzIGxpc3RlbmVyXG4gICAgICAvLyBzbyB0aGF0IFhEb21haW5SZXF1ZXN0IG9uIElFOSBpcyBub3QgYWJvcnRlZFxuICAgICAgLy8gcmVmczpcbiAgICAgIC8vICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWpzL2lzc3Vlcy83NlxuICAgICAgLy8gIC0gaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9pZS9lbi1VUy8zMGVmM2FkZC03NjdjLTQ0MzYtYjhhOS1mMWNhMTliNDgxMmUvaWU5LXJ0bS14ZG9tYWlucmVxdWVzdC1pc3N1ZWQtcmVxdWVzdHMtbWF5LWFib3J0LWlmLWFsbC1ldmVudC1oYW5kbGVycy1ub3Qtc3BlY2lmaWVkP2ZvcnVtPWlld2ViZGV2ZWxvcG1lbnRcbiAgICAgIHJlcS5vbnByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICAgIGlmICgnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiByZXEpIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvblJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgICByZXEub25sb2FkID0gb25Mb2FkO1xuICAgICAgcmVxLm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICAvLyBkbyBub3QgcmVseSBvbiBkZWZhdWx0IFhIUiBhc3luYyBmbGFnLCBhcyBzb21lIGFuYWx5dGljcyBjb2RlIGxpa2UgaG90amFyXG4gICAgICAvLyBicmVha3MgaXQgYW5kIHNldCBpdCB0byBmYWxzZSBieSBkZWZhdWx0XG4gICAgICBpZiAocmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmVxLm9wZW4ob3B0cy5tZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEub3BlbihvcHRzLm1ldGhvZCwgdXJsKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGVhZGVycyBhcmUgbWVhbnQgdG8gYmUgc2VudCBhZnRlciBvcGVuXG4gICAgICBpZiAoc3VwcG9ydC5jb3JzKSB7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgaWYgKG9wdHMubWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQWNjZXNzX2NvbnRyb2xfQ09SUyNTaW1wbGVfcmVxdWVzdHNcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNlbmQoYm9keSk7XG5cbiAgICAgIC8vIGV2ZW50IG9iamVjdCBub3QgcmVjZWl2ZWQgaW4gSUU4LCBhdCBsZWFzdFxuICAgICAgLy8gYnV0IHdlIGRvIG5vdCB1c2UgaXQsIHN0aWxsIGltcG9ydGFudCB0byBub3RlXG4gICAgICBmdW5jdGlvbiBvbkxvYWQoLyogZXZlbnQgKi8pIHtcbiAgICAgICAgLy8gV2hlbiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRzIHJlcS50aW1lb3V0LCB3ZSBjYW5cbiAgICAgICAgLy8gaGF2ZSBib3RoIGEgbG9hZCBhbmQgdGltZW91dCBldmVudCwgc2luY2UgaGFuZGxlZCBieSBhIGR1bWIgc2V0VGltZW91dFxuICAgICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cbiAgICAgICAgdmFyIG91dDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dCA9IHtcbiAgICAgICAgICAgIGJvZHk6IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlVGV4dCksXG4gICAgICAgICAgICByZXNwb25zZVRleHQ6IHJlcS5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiByZXEuc3RhdHVzLFxuICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3QgZG9lcyBub3QgaGF2ZSBhbnkgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgaGVhZGVyczogcmVxLmdldEFsbFJlc3BvbnNlSGVhZGVycyAmJiByZXEuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwge31cbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgb3V0ID0gbmV3IGVycm9ycy5VbnBhcnNhYmxlSlNPTih7XG4gICAgICAgICAgICBtb3JlOiByZXEucmVzcG9uc2VUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0IGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OKSB7XG4gICAgICAgICAgcmVqZWN0KG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuXG4gICAgICAgIC8vIGVycm9yIGV2ZW50IGlzIHRyaWdlcnJlZCBib3RoIHdpdGggWERSL1hIUiBvbjpcbiAgICAgICAgLy8gICAtIEROUyBlcnJvclxuICAgICAgICAvLyAgIC0gdW5hbGxvd2VkIGNyb3NzIGRvbWFpbiByZXF1ZXN0XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgZXJyb3JzLk5ldHdvcmsoe1xuICAgICAgICAgICAgbW9yZTogZXZlbnRcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnMuUmVxdWVzdFRpbWVvdXQoKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ29ubmVjdCgpIHtcbiAgICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuICAgICAgICByZXFUaW1lb3V0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIG9wdHMudGltZW91dHMuY29tcGxldGUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuICAgICAgICBpZiAoIWNvbm5lY3RlZCkgb25Db25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVhZHlTdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCFjb25uZWN0ZWQgJiYgcmVxLnJlYWR5U3RhdGUgPiAxKSBvbkNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3JlcXVlc3QuZmFsbGJhY2sgPSBmdW5jdGlvbiByZXF1ZXN0RmFsbGJhY2sodXJsLCBvcHRzKSB7XG4gICAgdXJsID0gaW5saW5lSGVhZGVycyh1cmwsIG9wdHMuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gd3JhcEpzb25wUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGpzb25wUmVxdWVzdCh1cmwsIG9wdHMsIGZ1bmN0aW9uIGpzb25wUmVxdWVzdERvbmUoZXJyLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQWxnb2xpYVNlYXJjaEJyb3dzZXIucHJvdG90eXBlLl9wcm9taXNlID0ge1xuICAgIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0UHJvbWlzZSh2YWwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWwpO1xuICAgIH0sXG4gICAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbCk7XG4gICAgfSxcbiAgICBkZWxheTogZnVuY3Rpb24gZGVsYXlQcm9taXNlKG1zKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gcmVzb2x2ZU9uVGltZW91dChyZXNvbHZlLyogLCByZWplY3QqLykge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gYWxnb2xpYXNlYXJjaDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvY3JlYXRlQWxnb2xpYXNlYXJjaC5qcyIsInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9nbG9iYWwvd2luZG93LmpzIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICA0LjEuMVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG52YXIgX2lzQXJyYXkgPSB1bmRlZmluZWQ7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdW5kZWZpbmVkO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdW5kZWZpbmVkO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICh7fSkudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdW5kZWZpbmVkO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gIGlmIChfc3RhdGUpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX2FyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDE2KTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgR0VUX1RIRU5fRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihwcm9taXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBHRVRfVEhFTl9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4kJDEsIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuJCQxLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4kJDEsIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJDEgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlJDEpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkMSA9PT0gR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICBHRVRfVEhFTl9FUlJPUi5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGdldFRoZW4odmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHVuZGVmaW5lZCxcbiAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gRXJyb3JPYmplY3QoKSB7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xufVxuXG52YXIgVFJZX0NBVENIX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgcmV0dXJuIFRSWV9DQVRDSF9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB1bmRlZmluZWQsXG4gICAgICBlcnJvciA9IHVuZGVmaW5lZCxcbiAgICAgIHN1Y2NlZWRlZCA9IHVuZGVmaW5lZCxcbiAgICAgIGZhaWxlZCA9IHVuZGVmaW5lZDtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB2YWx1ZSA9IHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgaWYgKHZhbHVlID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgdmFsdWUuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiBFbnVtZXJhdG9yJDEoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cbiAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgIHZhciBfdGhlbiA9IGdldFRoZW4oZW50cnkpO1xuXG4gICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlJDIpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSQkMShlbnRyeSk7XG4gICAgICB9KSwgaSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsJDEoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IkMSh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZSQxKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5mdW5jdGlvbiBQcm9taXNlJDIocmVzb2x2ZXIpIHtcbiAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlJDIgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICB9XG59XG5cblByb21pc2UkMi5hbGwgPSBhbGwkMTtcblByb21pc2UkMi5yYWNlID0gcmFjZSQxO1xuUHJvbWlzZSQyLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDIucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDIuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMi5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDIuX2FzYXAgPSBhc2FwO1xuXG5Qcm9taXNlJDIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUHJvbWlzZSQyLFxuXG4gIC8qKlxuICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIENoYWluaW5nXG4gICAgLS0tLS0tLS1cbiAgXG4gICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgfSk7XG4gIFxuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgIH0pO1xuICAgIGBgYFxuICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBc3NpbWlsYXRpb25cbiAgICAtLS0tLS0tLS0tLS1cbiAgXG4gICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgU2ltcGxlIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgcmVzdWx0O1xuICBcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgYXV0aG9yLCBib29rcztcbiAgXG4gICAgdHJ5IHtcbiAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICBcbiAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgXG4gICAgfVxuICBcbiAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRBdXRob3IoKS5cbiAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgdGhlblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICB0aGVuOiB0aGVuLFxuXG4gIC8qKlxuICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBcbiAgICBgYGBqc1xuICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgIH1cbiAgXG4gICAgLy8gc3luY2hyb25vdXNcbiAgICB0cnkge1xuICAgICAgZmluZEF1dGhvcigpO1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH1cbiAgXG4gICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBjYXRjaFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gICdjYXRjaCc6IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9XG59O1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsJDEoKSB7XG4gICAgdmFyIGxvY2FsID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgaWYgKFApIHtcbiAgICAgICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMjtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQyLnBvbHlmaWxsID0gcG9seWZpbGwkMTtcblByb21pc2UkMi5Qcm9taXNlID0gUHJvbWlzZSQyO1xuXG5yZXR1cm4gUHJvbWlzZSQyO1xuXG59KSkpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB2ZXJ0eCAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMyA0IDUgNiA3IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlubGluZUhlYWRlcnM7XG5cbnZhciBlbmNvZGUgPSByZXF1aXJlKCdxdWVyeXN0cmluZy1lczMvZW5jb2RlJyk7XG5cbmZ1bmN0aW9uIGlubGluZUhlYWRlcnModXJsLCBoZWFkZXJzKSB7XG4gIGlmICgvXFw/Ly50ZXN0KHVybCkpIHtcbiAgICB1cmwgKz0gJyYnO1xuICB9IGVsc2Uge1xuICAgIHVybCArPSAnPyc7XG4gIH1cblxuICByZXR1cm4gdXJsICsgZW5jb2RlKGhlYWRlcnMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2lubGluZS1oZWFkZXJzLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbnBSZXF1ZXN0O1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbnZhciBKU09OUENvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBqc29ucFJlcXVlc3QodXJsLCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgY2IobmV3IEVycm9yKCdNZXRob2QgJyArIG9wdHMubWV0aG9kICsgJyAnICsgdXJsICsgJyBpcyBub3Qgc3VwcG9ydGVkIGJ5IEpTT05QLicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRzLmRlYnVnKCdKU09OUDogc3RhcnQnKTtcblxuICB2YXIgY2JDYWxsZWQgPSBmYWxzZTtcbiAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG5cbiAgSlNPTlBDb3VudGVyICs9IDE7XG4gIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgY2JOYW1lID0gJ2FsZ29saWFKU09OUF8nICsgSlNPTlBDb3VudGVyO1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gIHdpbmRvd1tjYk5hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJlbW92ZUdsb2JhbHMoKTtcblxuICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgb3B0cy5kZWJ1ZygnSlNPTlA6IExhdGUgYW5zd2VyLCBpZ25vcmluZycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNiQ2FsbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFuKCk7XG5cbiAgICBjYihudWxsLCB7XG4gICAgICBib2R5OiBkYXRhLyogLFxuICAgICAgLy8gV2UgZG8gbm90IHNlbmQgdGhlIHN0YXR1c0NvZGUsIHRoZXJlJ3Mgbm8gc3RhdHVzQ29kZSBpbiBKU09OUCwgaXQgd2lsbCBiZVxuICAgICAgLy8gY29tcHV0ZWQgdXNpbmcgZGF0YS5zdGF0dXMgJiYgZGF0YS5tZXNzYWdlIGxpa2Ugd2l0aCBYRFJcbiAgICAgIHN0YXR1c0NvZGUqL1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIGFkZCBjYWxsYmFjayBieSBoYW5kXG4gIHVybCArPSAnJmNhbGxiYWNrPScgKyBjYk5hbWU7XG5cbiAgLy8gYWRkIGJvZHkgcGFyYW1zIG1hbnVhbGx5XG4gIGlmIChvcHRzLmpzb25Cb2R5ICYmIG9wdHMuanNvbkJvZHkucGFyYW1zKSB7XG4gICAgdXJsICs9ICcmJyArIG9wdHMuanNvbkJvZHkucGFyYW1zO1xuICB9XG5cbiAgdmFyIG9udGltZW91dCA9IHNldFRpbWVvdXQodGltZW91dCwgb3B0cy50aW1lb3V0cy5jb21wbGV0ZSk7XG5cbiAgLy8gc2NyaXB0IG9ucmVhZHlzdGF0ZWNoYW5nZSBuZWVkZWQgb25seSBmb3JcbiAgLy8gPD0gSUU4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvaXNzdWVzLzQ1MjNcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2U7XG4gIHNjcmlwdC5vbmxvYWQgPSBzdWNjZXNzO1xuICBzY3JpcHQub25lcnJvciA9IGVycm9yO1xuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICBmdW5jdGlvbiBzdWNjZXNzKCkge1xuICAgIG9wdHMuZGVidWcoJ0pTT05QOiBzdWNjZXNzJyk7XG5cbiAgICBpZiAoZG9uZSB8fCB0aW1lZE91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgLy8gc2NyaXB0IGxvYWRlZCBidXQgZGlkIG5vdCBjYWxsIHRoZSBmbiA9PiBzY3JpcHQgbG9hZGluZyBlcnJvclxuICAgIGlmICghY2JDYWxsZWQpIHtcbiAgICAgIG9wdHMuZGVidWcoJ0pTT05QOiBGYWlsLiBTY3JpcHQgbG9hZGVkIGJ1dCBkaWQgbm90IGNhbGwgdGhlIGNhbGxiYWNrJyk7XG4gICAgICBjbGVhbigpO1xuICAgICAgY2IobmV3IGVycm9ycy5KU09OUFNjcmlwdEZhaWwoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHN1Y2Nlc3MoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICBjbGVhclRpbWVvdXQob250aW1lb3V0KTtcbiAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICBzY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlR2xvYmFscygpIHtcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIHdpbmRvd1tjYk5hbWVdO1xuICAgICAgZGVsZXRlIHdpbmRvd1tjYk5hbWUgKyAnX2xvYWRlZCddO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdpbmRvd1tjYk5hbWVdID0gd2luZG93W2NiTmFtZSArICdfbG9hZGVkJ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGltZW91dCgpIHtcbiAgICBvcHRzLmRlYnVnKCdKU09OUDogU2NyaXB0IHRpbWVvdXQnKTtcbiAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgY2xlYW4oKTtcbiAgICBjYihuZXcgZXJyb3JzLlJlcXVlc3RUaW1lb3V0KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgb3B0cy5kZWJ1ZygnSlNPTlA6IFNjcmlwdCBlcnJvcicpO1xuXG4gICAgaWYgKGRvbmUgfHwgdGltZWRPdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbGVhbigpO1xuICAgIGNiKG5ldyBlcnJvcnMuSlNPTlBTY3JpcHRFcnJvcigpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2pzb25wLXJlcXVlc3QuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVBsYWNlc0NsaWVudDtcblxudmFyIGJ1aWxkU2VhcmNoTWV0aG9kID0gcmVxdWlyZSgnLi9idWlsZFNlYXJjaE1ldGhvZC5qcycpO1xuXG5mdW5jdGlvbiBjcmVhdGVQbGFjZXNDbGllbnQoYWxnb2xpYXNlYXJjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gcGxhY2VzKGFwcElELCBhcGlLZXksIG9wdHMpIHtcbiAgICB2YXIgY2xvbmVEZWVwID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpO1xuXG4gICAgb3B0cyA9IG9wdHMgJiYgY2xvbmVEZWVwKG9wdHMpIHx8IHt9O1xuICAgIG9wdHMuaG9zdHMgPSBvcHRzLmhvc3RzIHx8IFtcbiAgICAgICdwbGFjZXMtZHNuLmFsZ29saWEubmV0JyxcbiAgICAgICdwbGFjZXMtMS5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAncGxhY2VzLTIuYWxnb2xpYW5ldC5jb20nLFxuICAgICAgJ3BsYWNlcy0zLmFsZ29saWFuZXQuY29tJ1xuICAgIF07XG5cbiAgICAvLyBhbGxvdyBpbml0UGxhY2VzKCkgbm8gYXJndW1lbnRzID0+IGNvbW11bml0eSByYXRlIGxpbWl0ZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgYXBwSUQgPT09ICdvYmplY3QnIHx8IGFwcElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFwcElEID0gJyc7XG4gICAgICBhcGlLZXkgPSAnJztcbiAgICAgIG9wdHMuX2FsbG93RW1wdHlDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudCA9IGFsZ29saWFzZWFyY2goYXBwSUQsIGFwaUtleSwgb3B0cyk7XG4gICAgdmFyIGluZGV4ID0gY2xpZW50LmluaXRJbmRleCgncGxhY2VzJyk7XG4gICAgaW5kZXguc2VhcmNoID0gYnVpbGRTZWFyY2hNZXRob2QoJ3F1ZXJ5JywgJy8xL3BsYWNlcy9xdWVyeScpO1xuICAgIGluZGV4LmdldE9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdElELCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgdXJsOiAnLzEvcGxhY2VzLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpLFxuICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9wbGFjZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RG9jdW1lbnRQcm90b2NvbDtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRQcm90b2NvbCgpIHtcbiAgdmFyIHByb3RvY29sID0gd2luZG93LmRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sO1xuXG4gIC8vIHdoZW4gaW4gYGZpbGU6YCBtb2RlIChsb2NhbCBodG1sIGZpbGUpLCBkZWZhdWx0IHRvIGBodHRwOmBcbiAgaWYgKHByb3RvY29sICE9PSAnaHR0cDonICYmIHByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgfVxuXG4gIHJldHVybiBwcm90b2NvbDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9nZXQtZG9jdW1lbnQtcHJvdG9jb2wuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzMuMjQuMyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL3ZlcnNpb24uanMiXSwic291cmNlUm9vdCI6IiJ9